# Dgraph DB schema

type App {
  id: ID!
  ownerId: String! @search(by: [hash])
  pages: [Page] @hasInverse(field: "app")
  name: String!
}

type Page {
  id: ID!
  name: String! @search(by: [term, fulltext])
  app: App!
  rootElement: PageElement!
}

#Note that this PageElement is not the same as the one served in Nest's API, because we transform it to avoid recursion
type PageElement {
  id: ID!
  name: String! @search(by: [term, fulltext])
  page: Page!
  # Only the root page element won't have a parent
  parent: PageElement
  # A PageElement has 1 of 3 ways to be rendered:
  #   1. Atom, with or without children, without component -> render container with children
  #   2. Children, no atom, no component -> render children without container
  #   3. Component, no children, no atom -> render the component itself in place of the element
  # We can add component + children later
  children: [PageElement] @hasInverse(field: "parent")
  atom: Atom
  component: Component
}

type Library {
  id: ID!
  ownerId: String!
  name: String!
  atoms: [Atom] @hasInverse(field: "library")
  components: [Component] @hasInverse(field: "library")
}

type Component {
  id: ID!
  library: Library!
  atom: Atom!
  label: String!
  children: [Component]
  tags: [Tag]
}

type Atom {
  id: ID!
  type: AtomType!
  label: String!
  library: Library
}

type Tag {
  label: String!
}

type Prop {
  id: ID!
  description: String
  type: ValueType!
  props: [Prop]
}

type ValueType {
  id: ID!
  label: String!
  type: String!
}
