# Dgraph DB schema

type App {
    id: ID!
    ownerId: String! @search(by: [hash])
    pages: [Page] @hasInverse(field: "app")
    name: String!
}

type Page {
    id: ID!
    name: String! @search(by: [term, fulltext])
    app: App!
    rootElement: PageElement!
}

#Note that this PageElement is not the same as the one served in Nest's API, because we transform it to avoid recursion
type PageElement {
    id: ID!
    name: String! @search(by: [term, fulltext])
    page: Page!
    # Only the root page element won't have a parent
    parent: PageElement
    # A PageElement has 1 of 3 ways to be rendered:
    #   1. Atom, with or without children, without component -> render container with children
    #   2. Children, no atom, no component -> render children without container
    #   3. Component, no children, no atom -> render the component itself in place of the element
    # We can add component + children later
    children: [PageElement] @hasInverse(field: "parent")
    atom: Atom
    component: Component
}

type Library {
    id: ID!
    ownerId: String!
    name: String!
    atoms: [Atom] @hasInverse(field: "library")
    components: [Component] @hasInverse(field: "library")
}

type Component {
    id: ID!
    library: Library!
    atom: Atom!
    label: String!
    children: [Component]
    tags: [Tag]
}

type Atom {
    id: ID!
    type: AtomType!
    label: String!
    library: Library
    propTypes: Interface! @hasInverse(field: "atom")
}

type Tag {
    label: String!
}


#
# Typing system:
#
enum PrimitiveType {
  String
  Integer
  Float
  Boolean
}

type SimpleType {
    id: ID!
    primitiveType: PrimitiveType!
}

type ArrayType {
    id: ID!
    # that's the type of the array item, e.g. type: (SimpleType) String, would be string[]
    type: Type!
}

type EnumTypeValue {
    id: ID!
    name: String!
}

type EnumType {
    id: ID!
    allowedValues: [EnumTypeValue!]!
}

enum Unit {
  PX
  PT
  EM
  REM
  PERCENT
  VW
  VH
  #... add all units here, this is just an example
}

type UnitType {
    id: ID!
    allowedUnits: [Unit!]!
}

# This is very expandable - want to add Colors? Just create a ColorType with red, green and blue fields
# Want to handle different units, like px, pt, rem? Create an UnitType
# We can add as many types as we need without breaking or even touching existing ones
union Type = SimpleType | Interface | ArrayType | EnumType | UnitType

type RequiredValidator {
  id: ID!
  isRequired: Boolean!
}

type MinMaxValidator {
    id: ID!
    min: Int
    max: Int
}

type ArrayLengthValidator {
    id: ID!
    min: Int
    max: Int
}

union Decorator = MinMaxValidator | RequiredValidator | ArrayLengthValidator #add more decorators here if we need to extend the functionality
type Field {
    id: ID!
    type: Type!
    key: String! @search(by: [hash, fulltext])
    name: String!
    description: String
    decorators: [Decorator]
    interface: Interface!
}

type Interface {
    id: ID!
    atom: Atom
    name: String!
    fields: [Field] @hasInverse(field: "interface")
}


#
# Props
#

type StringValue {
    id: ID!
    value: String!
}

type IntValue {
    id: ID!
    value: Int!
}

type FloatValue {
    id: ID!
    value: Float!
}

type BooleanValue {
    id: ID!
    value: Boolean!
}

type ArrayValue {
    id: ID!
    values: [PropValue!]!
}

type InterfaceValue {
    id: ID!
    props: [Prop!]!
}

union PropValue = StringValue | IntValue | FloatValue | BooleanValue | ArrayValue | InterfaceValue

type Prop {
    id: ID!
    field: Field!
    value: PropValue
}
