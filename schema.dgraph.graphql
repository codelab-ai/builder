directive @auth(
  password: AuthRule
  query: AuthRule
  add: AuthRule
  update: AuthRule
  delete: AuthRule
) on OBJECT | INTERFACE

directive @cacheControl(maxAge: Int!) on QUERY

directive @cascade(fields: [String]) on FIELD

directive @custom(http: CustomHTTP, dql: String) on FIELD_DEFINITION

directive @dgraph(
  type: String
  pred: String
) on OBJECT | INTERFACE | FIELD_DEFINITION

directive @generate(
  query: GenerateQueryParams
  mutation: GenerateMutationParams
  subscription: Boolean
) on OBJECT | INTERFACE

directive @hasInverse(field: String!) on FIELD_DEFINITION

directive @id on FIELD_DEFINITION

directive @lambda on FIELD_DEFINITION

directive @lambdaOnMutate(
  add: Boolean
  update: Boolean
  delete: Boolean
) on OBJECT | INTERFACE

directive @remote on OBJECT | INTERFACE | UNION | INPUT_OBJECT | ENUM

directive @remoteResponse(name: String) on FIELD_DEFINITION

directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION

directive @secret(field: String!, pred: String) on OBJECT | INTERFACE

directive @withSubscription on OBJECT | INTERFACE | FIELD_DEFINITION

input AddAppInput {
  owner: UserRef
  name: String!
}

type AddAppPayload {
  app(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  numUids: Int
}

input AddAtomInput {
  type: String!
  library: LibraryRef
  label: String!
}

type AddAtomPayload {
  atom(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  numUids: Int
}

input AddComponentInput {
  label: String!
  children: [ComponentRef]
  atom: AtomRef
  library: LibraryRef!
  tags: [TagRef]
}

type AddComponentPayload {
  component(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  numUids: Int
}

input AddGetAllUsersPayloadInput {
  email: String
}

type AddGetAllUsersPayloadPayload {
  getAllUsersPayload(
    filter: GetAllUsersPayloadFilter
    order: GetAllUsersPayloadOrder
    first: Int
    offset: Int
  ): [GetAllUsersPayload]
  numUids: Int
}

input AddLibraryInput {
  name: String!
  atoms: [AtomRef]
  components: [ComponentRef]
}

type AddLibraryPayload {
  library(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  numUids: Int
}

input AddTagInput {
  label: String!
}

type AddTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  numUids: Int
}

input AddUserInput {
  email: String!
  apps: [AppRef!]
  libraries: [LibraryRef!]
}

type AddUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

type App {
  id: ID!
  owner(filter: UserFilter): User
  name: String!
}

type AppAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input AppFilter {
  id: [ID!]
  has: [AppHasFilter]
  and: [AppFilter]
  or: [AppFilter]
  not: AppFilter
}

enum AppHasFilter {
  owner
  name
}

input AppOrder {
  asc: AppOrderable
  desc: AppOrderable
  then: AppOrder
}

enum AppOrderable {
  name
}

input AppPatch {
  owner: UserRef
  name: String
}

input AppRef {
  id: ID
  owner: UserRef
  name: String
}

type Atom {
  id: ID!
  type: String!
  library(filter: LibraryFilter): Library
  label: String!
}

type AtomAggregateResult {
  count: Int
  typeMin: String
  typeMax: String
  labelMin: String
  labelMax: String
}

input AtomFilter {
  id: [ID!]
  has: [AtomHasFilter]
  and: [AtomFilter]
  or: [AtomFilter]
  not: AtomFilter
}

enum AtomHasFilter {
  type
  library
  label
}

input AtomOrder {
  asc: AtomOrderable
  desc: AtomOrderable
  then: AtomOrder
}

enum AtomOrderable {
  type
  label
}

input AtomPatch {
  type: String
  library: LibraryRef
  label: String
}

input AtomRef {
  id: ID
  type: String
  library: LibraryRef
  label: String
}

input AuthRule {
  and: [AuthRule]
  or: [AuthRule]
  not: AuthRule
  rule: String
}

type Component {
  id: ID!
  label: String!
  children(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  atom(filter: AtomFilter): Atom
  library(filter: LibraryFilter): Library!
  tags(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  childrenAggregate(filter: ComponentFilter): ComponentAggregateResult
  tagsAggregate(filter: TagFilter): TagAggregateResult
}

type ComponentAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
}

input ComponentFilter {
  id: [ID!]
  has: [ComponentHasFilter]
  and: [ComponentFilter]
  or: [ComponentFilter]
  not: ComponentFilter
}

enum ComponentHasFilter {
  label
  children
  atom
  library
  tags
}

input ComponentOrder {
  asc: ComponentOrderable
  desc: ComponentOrderable
  then: ComponentOrder
}

enum ComponentOrderable {
  label
}

input ComponentPatch {
  label: String
  children: [ComponentRef]
  atom: AtomRef
  library: LibraryRef
  tags: [TagRef]
}

input ComponentRef {
  id: ID
  label: String
  children: [ComponentRef]
  atom: AtomRef
  library: LibraryRef
  tags: [TagRef]
}

input ContainsFilter {
  point: PointRef
  polygon: PolygonRef
}

input CustomHTTP {
  url: String!
  method: HTTPMethod!
  body: String
  graphql: String
  mode: Mode
  forwardHeaders: [String!]
  secretHeaders: [String!]
  introspectionHeaders: [String!]
  skipIntrospection: Boolean
}

"""
The DateTime scalar type represents date and time as a string in RFC3339 format.
For example: "1985-04-12T23:20:50.52Z" represents 20 minutes and 50.52 seconds after the 23rd hour of April 12th, 1985 in UTC.
"""
scalar DateTime

input DateTimeFilter {
  eq: DateTime
  in: [DateTime]
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
  between: DateTimeRange
}

input DateTimeRange {
  min: DateTime!
  max: DateTime!
}

type DeleteAppPayload {
  app(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  msg: String
  numUids: Int
}

type DeleteAtomPayload {
  atom(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  msg: String
  numUids: Int
}

type DeleteComponentPayload {
  component(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  msg: String
  numUids: Int
}

type DeleteGetAllUsersPayloadPayload {
  getAllUsersPayload(
    filter: GetAllUsersPayloadFilter
    order: GetAllUsersPayloadOrder
    first: Int
    offset: Int
  ): [GetAllUsersPayload]
  msg: String
  numUids: Int
}

type DeleteLibraryPayload {
  library(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  msg: String
  numUids: Int
}

type DeleteTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  msg: String
  numUids: Int
}

type DeleteUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  msg: String
  numUids: Int
}

enum DgraphIndex {
  int
  int64
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
  geo
}

input FloatFilter {
  eq: Float
  in: [Float]
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: FloatRange
}

input FloatRange {
  min: Float!
  max: Float!
}

input GenerateMutationParams {
  add: Boolean
  update: Boolean
  delete: Boolean
}

input GenerateQueryParams {
  get: Boolean
  query: Boolean
  password: Boolean
  aggregate: Boolean
}

type GetAllUsersPayload {
  id: ID!
  email: String
}

type GetAllUsersPayloadAggregateResult {
  count: Int
  emailMin: String
  emailMax: String
}

input GetAllUsersPayloadFilter {
  id: [ID!]
  has: [GetAllUsersPayloadHasFilter]
  and: [GetAllUsersPayloadFilter]
  or: [GetAllUsersPayloadFilter]
  not: GetAllUsersPayloadFilter
}

enum GetAllUsersPayloadHasFilter {
  email
}

input GetAllUsersPayloadOrder {
  asc: GetAllUsersPayloadOrderable
  desc: GetAllUsersPayloadOrderable
  then: GetAllUsersPayloadOrder
}

enum GetAllUsersPayloadOrderable {
  email
}

input GetAllUsersPayloadPatch {
  email: String
}

input GetAllUsersPayloadRef {
  id: ID
  email: String
}

enum HTTPMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

"""
The Int64 scalar type represents a signed 64‐bit numeric non‐fractional value.
Int64 can represent values in range [-(2^63),(2^63 - 1)].
"""
scalar Int64

input Int64Filter {
  eq: Int64
  in: [Int64]
  le: Int64
  lt: Int64
  ge: Int64
  gt: Int64
  between: Int64Range
}

input Int64Range {
  min: Int64!
  max: Int64!
}

input IntFilter {
  eq: Int
  in: [Int]
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: IntRange
}

input IntRange {
  min: Int!
  max: Int!
}

input IntersectsFilter {
  polygon: PolygonRef
  multiPolygon: MultiPolygonRef
}

type Library {
  id: ID!
  name: String!
  atoms(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  components(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  atomsAggregate(filter: AtomFilter): AtomAggregateResult
  componentsAggregate(filter: ComponentFilter): ComponentAggregateResult
}

type LibraryAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input LibraryFilter {
  id: [ID!]
  has: [LibraryHasFilter]
  and: [LibraryFilter]
  or: [LibraryFilter]
  not: LibraryFilter
}

enum LibraryHasFilter {
  name
  atoms
  components
}

input LibraryOrder {
  asc: LibraryOrderable
  desc: LibraryOrderable
  then: LibraryOrder
}

enum LibraryOrderable {
  name
}

input LibraryPatch {
  name: String
  atoms: [AtomRef]
  components: [ComponentRef]
}

input LibraryRef {
  id: ID
  name: String
  atoms: [AtomRef]
  components: [ComponentRef]
}

enum Mode {
  BATCH
  SINGLE
}

type MultiPolygon {
  polygons: [Polygon!]!
}

input MultiPolygonRef {
  polygons: [PolygonRef!]!
}

type Mutation {
  addUser(input: [AddUserInput!]!, upsert: Boolean): AddUserPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  deleteUser(filter: UserFilter!): DeleteUserPayload
  addApp(input: [AddAppInput!]!): AddAppPayload
  updateApp(input: UpdateAppInput!): UpdateAppPayload
  deleteApp(filter: AppFilter!): DeleteAppPayload
  addLibrary(input: [AddLibraryInput!]!): AddLibraryPayload
  updateLibrary(input: UpdateLibraryInput!): UpdateLibraryPayload
  deleteLibrary(filter: LibraryFilter!): DeleteLibraryPayload
  addComponent(input: [AddComponentInput!]!): AddComponentPayload
  updateComponent(input: UpdateComponentInput!): UpdateComponentPayload
  deleteComponent(filter: ComponentFilter!): DeleteComponentPayload
  addAtom(input: [AddAtomInput!]!): AddAtomPayload
  updateAtom(input: UpdateAtomInput!): UpdateAtomPayload
  deleteAtom(filter: AtomFilter!): DeleteAtomPayload
  addTag(input: [AddTagInput!]!): AddTagPayload
  updateTag(input: UpdateTagInput!): UpdateTagPayload
  deleteTag(filter: TagFilter!): DeleteTagPayload
  addGetAllUsersPayload(
    input: [AddGetAllUsersPayloadInput!]!
  ): AddGetAllUsersPayloadPayload
  updateGetAllUsersPayload(
    input: UpdateGetAllUsersPayloadInput!
  ): UpdateGetAllUsersPayloadPayload
  deleteGetAllUsersPayload(
    filter: GetAllUsersPayloadFilter!
  ): DeleteGetAllUsersPayloadPayload
}

input NearFilter {
  distance: Float!
  coordinate: PointRef!
}

type Point {
  longitude: Float!
  latitude: Float!
}

input PointGeoFilter {
  near: NearFilter
  within: WithinFilter
}

type PointList {
  points: [Point!]!
}

input PointListRef {
  points: [PointRef!]!
}

input PointRef {
  longitude: Float!
  latitude: Float!
}

type Polygon {
  coordinates: [PointList!]!
}

input PolygonGeoFilter {
  near: NearFilter
  within: WithinFilter
  contains: ContainsFilter
  intersects: IntersectsFilter
}

input PolygonRef {
  coordinates: [PointListRef!]!
}

type Query {
  GetAllUsers: [GetAllUsersPayload]
  userWhere(email: String!): User
  getUser(id: ID, email: String): User
  queryUser(
    filter: UserFilter
    order: UserOrder
    first: Int
    offset: Int
  ): [User]
  aggregateUser(filter: UserFilter): UserAggregateResult
  getApp(id: ID!): App
  queryApp(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  aggregateApp(filter: AppFilter): AppAggregateResult
  getLibrary(id: ID!): Library
  queryLibrary(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  aggregateLibrary(filter: LibraryFilter): LibraryAggregateResult
  getComponent(id: ID!): Component
  queryComponent(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  aggregateComponent(filter: ComponentFilter): ComponentAggregateResult
  getAtom(id: ID!): Atom
  queryAtom(
    filter: AtomFilter
    order: AtomOrder
    first: Int
    offset: Int
  ): [Atom]
  aggregateAtom(filter: AtomFilter): AtomAggregateResult
  queryTag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  aggregateTag(filter: TagFilter): TagAggregateResult
  getGetAllUsersPayload(id: ID!): GetAllUsersPayload
  queryGetAllUsersPayload(
    filter: GetAllUsersPayloadFilter
    order: GetAllUsersPayloadOrder
    first: Int
    offset: Int
  ): [GetAllUsersPayload]
  aggregateGetAllUsersPayload(
    filter: GetAllUsersPayloadFilter
  ): GetAllUsersPayloadAggregateResult
}

input StringExactFilter {
  eq: String
  in: [String]
  le: String
  lt: String
  ge: String
  gt: String
  between: StringRange
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringHashFilter {
  eq: String
  in: [String]
}

input StringRange {
  min: String!
  max: String!
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

type Tag {
  label: String!
}

type TagAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
}

input TagFilter {
  has: [TagHasFilter]
  and: [TagFilter]
  or: [TagFilter]
  not: TagFilter
}

enum TagHasFilter {
  label
}

input TagOrder {
  asc: TagOrderable
  desc: TagOrderable
  then: TagOrder
}

enum TagOrderable {
  label
}

input TagPatch {
  label: String
}

input TagRef {
  label: String
}

input UpdateAppInput {
  filter: AppFilter!
  set: AppPatch
  remove: AppPatch
}

type UpdateAppPayload {
  app(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  numUids: Int
}

input UpdateAtomInput {
  filter: AtomFilter!
  set: AtomPatch
  remove: AtomPatch
}

type UpdateAtomPayload {
  atom(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  numUids: Int
}

input UpdateComponentInput {
  filter: ComponentFilter!
  set: ComponentPatch
  remove: ComponentPatch
}

type UpdateComponentPayload {
  component(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  numUids: Int
}

input UpdateGetAllUsersPayloadInput {
  filter: GetAllUsersPayloadFilter!
  set: GetAllUsersPayloadPatch
  remove: GetAllUsersPayloadPatch
}

type UpdateGetAllUsersPayloadPayload {
  getAllUsersPayload(
    filter: GetAllUsersPayloadFilter
    order: GetAllUsersPayloadOrder
    first: Int
    offset: Int
  ): [GetAllUsersPayload]
  numUids: Int
}

input UpdateLibraryInput {
  filter: LibraryFilter!
  set: LibraryPatch
  remove: LibraryPatch
}

type UpdateLibraryPayload {
  library(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  numUids: Int
}

input UpdateTagInput {
  filter: TagFilter!
  set: TagPatch
  remove: TagPatch
}

type UpdateTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  numUids: Int
}

input UpdateUserInput {
  filter: UserFilter!
  set: UserPatch
  remove: UserPatch
}

type UpdateUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

input UpsertUserInput {
  email: String!
}

type User {
  id: ID!
  email: String!
  apps(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App!]
  libraries(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library!]
  appsAggregate(filter: AppFilter): AppAggregateResult
  librariesAggregate(filter: LibraryFilter): LibraryAggregateResult
}

type UserAggregateResult {
  count: Int
  emailMin: String
  emailMax: String
}

input UserFilter {
  id: [ID!]
  email: StringHashFilter
  has: [UserHasFilter]
  and: [UserFilter]
  or: [UserFilter]
  not: UserFilter
}

enum UserHasFilter {
  email
  apps
  libraries
}

input UserOrder {
  asc: UserOrderable
  desc: UserOrderable
  then: UserOrder
}

enum UserOrderable {
  email
}

input UserPatch {
  apps: [AppRef!]
  libraries: [LibraryRef!]
}

input UserRef {
  id: ID
  email: String
  apps: [AppRef!]
  libraries: [LibraryRef!]
}

input WithinFilter {
  polygon: PolygonRef!
}
