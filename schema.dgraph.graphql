directive @auth(
  password: AuthRule
  query: AuthRule
  add: AuthRule
  update: AuthRule
  delete: AuthRule
) on OBJECT | INTERFACE

directive @cacheControl(maxAge: Int!) on QUERY

directive @cascade(fields: [String]) on FIELD

directive @custom(http: CustomHTTP, dql: String) on FIELD_DEFINITION

directive @dgraph(
  type: String
  pred: String
) on OBJECT | INTERFACE | FIELD_DEFINITION

directive @generate(
  query: GenerateQueryParams
  mutation: GenerateMutationParams
  subscription: Boolean
) on OBJECT | INTERFACE

directive @hasInverse(field: String!) on FIELD_DEFINITION

directive @id on FIELD_DEFINITION

directive @lambda on FIELD_DEFINITION

directive @lambdaOnMutate(
  add: Boolean
  update: Boolean
  delete: Boolean
) on OBJECT | INTERFACE

directive @remote on OBJECT | INTERFACE | UNION | INPUT_OBJECT | ENUM

directive @remoteResponse(name: String) on FIELD_DEFINITION

directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION

directive @secret(field: String!, pred: String) on OBJECT | INTERFACE

directive @withSubscription on OBJECT | INTERFACE | FIELD_DEFINITION

input AddAppInput {
  ownerId: String!
  pages: [PageRef]
  name: String!
}

type AddAppPayload {
  app(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  numUids: Int
}

input AddArrayLengthValidatorInput {
  min: Int
  max: Int
}

type AddArrayLengthValidatorPayload {
  arrayLengthValidator(
    filter: ArrayLengthValidatorFilter
    order: ArrayLengthValidatorOrder
    first: Int
    offset: Int
  ): [ArrayLengthValidator]
  numUids: Int
}

input AddArrayTypeInput {
  type: TypeRef!
}

type AddArrayTypePayload {
  arrayType(filter: ArrayTypeFilter, first: Int, offset: Int): [ArrayType]
  numUids: Int
}

input AddAtomInput {
  type: AtomType!
  label: String!
  library: LibraryRef
  propTypes: InterfaceRef!
}

type AddAtomPayload {
  atom(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  numUids: Int
}

input AddComponentInput {
  library: LibraryRef!
  atom: AtomRef!
  label: String!
  children: [ComponentRef]
  tags: [TagRef]
}

type AddComponentPayload {
  component(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  numUids: Int
}

input AddEnumTypeInput {
  allowedValues: [EnumTypeValueRef!]!
}

type AddEnumTypePayload {
  enumType(filter: EnumTypeFilter, first: Int, offset: Int): [EnumType]
  numUids: Int
}

input AddEnumTypeValueInput {
  name: String!
}

type AddEnumTypeValuePayload {
  enumTypeValue(
    filter: EnumTypeValueFilter
    order: EnumTypeValueOrder
    first: Int
    offset: Int
  ): [EnumTypeValue]
  numUids: Int
}

input AddFieldInput {
  type: TypeRef!
  key: String!
  name: String!
  description: String
  decorators: [DecoratorRef]
  interface: InterfaceRef!
}

type AddFieldPayload {
  field(
    filter: FieldFilter
    order: FieldOrder
    first: Int
    offset: Int
  ): [Field]
  numUids: Int
}

input AddInterfaceInput {
  name: String!
  fields: [FieldRef]
}

type AddInterfacePayload {
  interface(
    filter: InterfaceFilter
    order: InterfaceOrder
    first: Int
    offset: Int
  ): [Interface]
  numUids: Int
}

input AddLibraryInput {
  ownerId: String!
  name: String!
  atoms: [AtomRef]
  components: [ComponentRef]
}

type AddLibraryPayload {
  library(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  numUids: Int
}

input AddMinMaxValidatorInput {
  min: Int
  max: Int
}

type AddMinMaxValidatorPayload {
  minMaxValidator(
    filter: MinMaxValidatorFilter
    order: MinMaxValidatorOrder
    first: Int
    offset: Int
  ): [MinMaxValidator]
  numUids: Int
}

input AddPageElementInput {
  name: String!
  page: PageRef!
  parent: PageElementRef
  children: [PageElementRef]
  atom: AtomRef
  component: ComponentRef
}

type AddPageElementPayload {
  pageElement(
    filter: PageElementFilter
    order: PageElementOrder
    first: Int
    offset: Int
  ): [PageElement]
  numUids: Int
}

input AddPageInput {
  name: String!
  app: AppRef!
  rootElement: PageElementRef!
}

type AddPagePayload {
  page(filter: PageFilter, order: PageOrder, first: Int, offset: Int): [Page]
  numUids: Int
}

input AddPropInput {
  description: String
  type: ValueTypeRef!
  props: [PropRef]
}

type AddPropPayload {
  prop(filter: PropFilter, order: PropOrder, first: Int, offset: Int): [Prop]
  numUids: Int
}

input AddRequiredValidatorInput {
  isRequired: Boolean!
}

type AddRequiredValidatorPayload {
  requiredValidator(
    filter: RequiredValidatorFilter
    first: Int
    offset: Int
  ): [RequiredValidator]
  numUids: Int
}

input AddSimpleTypeInput {
  primitiveType: PrimitiveType!
}

type AddSimpleTypePayload {
  simpleType(filter: SimpleTypeFilter, first: Int, offset: Int): [SimpleType]
  numUids: Int
}

input AddTagInput {
  label: String!
}

type AddTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  numUids: Int
}

input AddUnitTypeInput {
  allowedUnits: [Unit!]!
}

type AddUnitTypePayload {
  unitType(filter: UnitTypeFilter, first: Int, offset: Int): [UnitType]
  numUids: Int
}

input AddValueTypeInput {
  label: String!
  type: String!
}

type AddValueTypePayload {
  valueType(
    filter: ValueTypeFilter
    order: ValueTypeOrder
    first: Int
    offset: Int
  ): [ValueType]
  numUids: Int
}

type App {
  id: ID!
  ownerId: String!
  pages(filter: PageFilter, order: PageOrder, first: Int, offset: Int): [Page]
  name: String!
  pagesAggregate(filter: PageFilter): PageAggregateResult
}

type AppAggregateResult {
  count: Int
  ownerIdMin: String
  ownerIdMax: String
  nameMin: String
  nameMax: String
}

input AppFilter {
  id: [ID!]
  ownerId: StringHashFilter
  has: [AppHasFilter]
  and: [AppFilter]
  or: [AppFilter]
  not: AppFilter
}

enum AppHasFilter {
  ownerId
  pages
  name
}

input AppOrder {
  asc: AppOrderable
  desc: AppOrderable
  then: AppOrder
}

enum AppOrderable {
  ownerId
  name
}

input AppPatch {
  ownerId: String
  pages: [PageRef]
  name: String
}

input AppRef {
  id: ID
  ownerId: String
  pages: [PageRef]
  name: String
}

type ArrayLengthValidator {
  id: ID!
  min: Int
  max: Int
}

type ArrayLengthValidatorAggregateResult {
  count: Int
  minMin: Int
  minMax: Int
  minSum: Int
  minAvg: Float
  maxMin: Int
  maxMax: Int
  maxSum: Int
  maxAvg: Float
}

input ArrayLengthValidatorFilter {
  id: [ID!]
  has: [ArrayLengthValidatorHasFilter]
  and: [ArrayLengthValidatorFilter]
  or: [ArrayLengthValidatorFilter]
  not: ArrayLengthValidatorFilter
}

enum ArrayLengthValidatorHasFilter {
  min
  max
}

input ArrayLengthValidatorOrder {
  asc: ArrayLengthValidatorOrderable
  desc: ArrayLengthValidatorOrderable
  then: ArrayLengthValidatorOrder
}

enum ArrayLengthValidatorOrderable {
  min
  max
}

input ArrayLengthValidatorPatch {
  min: Int
  max: Int
}

input ArrayLengthValidatorRef {
  id: ID
  min: Int
  max: Int
}

type ArrayType {
  id: ID!
  type(filter: TypeFilter): Type!
}

type ArrayTypeAggregateResult {
  count: Int
}

input ArrayTypeFilter {
  id: [ID!]
  has: [ArrayTypeHasFilter]
  and: [ArrayTypeFilter]
  or: [ArrayTypeFilter]
  not: ArrayTypeFilter
}

enum ArrayTypeHasFilter {
  type
}

input ArrayTypePatch {
  type: TypeRef
}

input ArrayTypeRef {
  id: ID
  type: TypeRef
}

type Atom {
  id: ID!
  type: AtomType!
  label: String!
  library(filter: LibraryFilter): Library
  propTypes(filter: InterfaceFilter): Interface!
}

type AtomAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
}

input AtomFilter {
  id: [ID!]
  has: [AtomHasFilter]
  and: [AtomFilter]
  or: [AtomFilter]
  not: AtomFilter
}

enum AtomHasFilter {
  type
  label
  library
  propTypes
}

input AtomOrder {
  asc: AtomOrderable
  desc: AtomOrderable
  then: AtomOrder
}

enum AtomOrderable {
  label
}

input AtomPatch {
  type: AtomType
  label: String
  library: LibraryRef
  propTypes: InterfaceRef
}

input AtomRef {
  id: ID
  type: AtomType
  label: String
  library: LibraryRef
  propTypes: InterfaceRef
}

enum AtomType {
  AntDesignAffix
  AntDesignAlert
  AntDesignAnchor
  AntDesignAnchorLink
  AntDesignAutoComplete
  AntDesignAvatar
  AntDesignBackTop
  AntDesignBadge
  AntDesignBreadcrumb
  AntDesignBreadcrumbItem
  AntDesignButton
  AntDesignCalendar
  AntDesignCard
  AntDesignCardGrid
  AntDesignCardMeta
  AntDesignCarousel
  AntDesignCascader
  AntDesignCheckbox
  AntDesignCollapse
  AntDesignCollapsePanel
  AntDesignComment
  AntDesignConfigProvider
  AntDesignDatePicker
  AntDesignDescriptions
  AntDesignDescriptionsItem
  AntDesignDivider
  AntDesignDrawer
  AntDesignDropdown
  AntDesignEmpty
  AntDesignForm
  AntDesignFormItem
  AntDesignFormItemHook
  AntDesignFormList
  AntDesignGridCol
  AntDesignGridRow
  AntDesignIcon
  AntDesignInput
  AntDesignInputNumber
  AntDesignLayout
  AntDesignLayoutContent
  AntDesignLayoutFooter
  AntDesignLayoutHeader
  AntDesignLayoutSider
  AntDesignList
  AntDesignListItem
  AntDesignListItemMeta
  AntDesignMapper
  AntDesignMentions
  AntDesignMentionsOption
  AntDesignMenu
  AntDesignMenuItem
  AntDesignMenuItemGroup
  AntDesignMenuSubMenu
  AntDesignModal
  AntDesignPageHeader
  AntDesignPageContainer
  AntDesignPagination
  AntDesignPopconfirm
  AntDesignPopover
  AntDesignProgress
  AntDesignProvider
  AntDesignRglContainer
  AntDesignRglItem
  AntDesignRglResponsiveContainer
  AntDesignRadio
  AntDesignRadioGroup
  AntDesignRate
  AntDesignRenderComponent
  AntDesignRenderContainer
  AntDesignResult
  AntDesignSelect
  AntDesignSelectOption
  AntDesignSkeleton
  AntDesignSlider
  AntDesignSpace
  AntDesignSpin
  AntDesignStatistic
  AntDesignSteps
  AntDesignStepsStep
  AntDesignSwitch
  AntDesignTable
  AntDesignTabs
  AntDesignTabsTabPane
  AntDesignTag
  AntDesignTimePicker
  AntDesignTimeline
  AntDesignTimelineItem
  AntDesignTooltip
  AntDesignTransfer
  AntDesignTree
  AntDesignTreeNode
  AntDesignTreeSelect
  AntDesignTypography
  AntDesignTypographyParagraph
  AntDesignTypographyText
  AntDesignTypographyTitle
  AntDesignUpload
  ReactFragment
  HtmlA
  HtmlDiv
  HtmlP
  HtmlSpan
  HtmlText
}

input AuthRule {
  and: [AuthRule]
  or: [AuthRule]
  not: AuthRule
  rule: String
}

type Component {
  id: ID!
  library(filter: LibraryFilter): Library!
  atom(filter: AtomFilter): Atom!
  label: String!
  children(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  tags(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  childrenAggregate(filter: ComponentFilter): ComponentAggregateResult
  tagsAggregate(filter: TagFilter): TagAggregateResult
}

type ComponentAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
}

input ComponentFilter {
  id: [ID!]
  has: [ComponentHasFilter]
  and: [ComponentFilter]
  or: [ComponentFilter]
  not: ComponentFilter
}

enum ComponentHasFilter {
  library
  atom
  label
  children
  tags
}

input ComponentOrder {
  asc: ComponentOrderable
  desc: ComponentOrderable
  then: ComponentOrder
}

enum ComponentOrderable {
  label
}

input ComponentPatch {
  library: LibraryRef
  atom: AtomRef
  label: String
  children: [ComponentRef]
  tags: [TagRef]
}

input ComponentRef {
  id: ID
  library: LibraryRef
  atom: AtomRef
  label: String
  children: [ComponentRef]
  tags: [TagRef]
}

input ContainsFilter {
  point: PointRef
  polygon: PolygonRef
}

input CustomHTTP {
  url: String!
  method: HTTPMethod!
  body: String
  graphql: String
  mode: Mode
  forwardHeaders: [String!]
  secretHeaders: [String!]
  introspectionHeaders: [String!]
  skipIntrospection: Boolean
}

"""
The DateTime scalar type represents date and time as a string in RFC3339 format.
For example: "1985-04-12T23:20:50.52Z" represents 20 minutes and 50.52 seconds after the 23rd hour of April 12th, 1985 in UTC.
"""
scalar DateTime

input DateTimeFilter {
  eq: DateTime
  in: [DateTime]
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
  between: DateTimeRange
}

input DateTimeRange {
  min: DateTime!
  max: DateTime!
}

union Decorator = MinMaxValidator | RequiredValidator | ArrayLengthValidator

input DecoratorFilter {
  memberTypes: [DecoratorType!]
  minMaxValidatorFilter: MinMaxValidatorFilter
  requiredValidatorFilter: RequiredValidatorFilter
  arrayLengthValidatorFilter: ArrayLengthValidatorFilter
}

input DecoratorRef {
  minMaxValidatorRef: MinMaxValidatorRef
  requiredValidatorRef: RequiredValidatorRef
  arrayLengthValidatorRef: ArrayLengthValidatorRef
}

enum DecoratorType {
  MinMaxValidator
  RequiredValidator
  ArrayLengthValidator
}

type DeleteAppPayload {
  app(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  msg: String
  numUids: Int
}

type DeleteArrayLengthValidatorPayload {
  arrayLengthValidator(
    filter: ArrayLengthValidatorFilter
    order: ArrayLengthValidatorOrder
    first: Int
    offset: Int
  ): [ArrayLengthValidator]
  msg: String
  numUids: Int
}

type DeleteArrayTypePayload {
  arrayType(filter: ArrayTypeFilter, first: Int, offset: Int): [ArrayType]
  msg: String
  numUids: Int
}

type DeleteAtomPayload {
  atom(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  msg: String
  numUids: Int
}

type DeleteComponentPayload {
  component(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  msg: String
  numUids: Int
}

type DeleteEnumTypePayload {
  enumType(filter: EnumTypeFilter, first: Int, offset: Int): [EnumType]
  msg: String
  numUids: Int
}

type DeleteEnumTypeValuePayload {
  enumTypeValue(
    filter: EnumTypeValueFilter
    order: EnumTypeValueOrder
    first: Int
    offset: Int
  ): [EnumTypeValue]
  msg: String
  numUids: Int
}

type DeleteFieldPayload {
  field(
    filter: FieldFilter
    order: FieldOrder
    first: Int
    offset: Int
  ): [Field]
  msg: String
  numUids: Int
}

type DeleteInterfacePayload {
  interface(
    filter: InterfaceFilter
    order: InterfaceOrder
    first: Int
    offset: Int
  ): [Interface]
  msg: String
  numUids: Int
}

type DeleteLibraryPayload {
  library(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  msg: String
  numUids: Int
}

type DeleteMinMaxValidatorPayload {
  minMaxValidator(
    filter: MinMaxValidatorFilter
    order: MinMaxValidatorOrder
    first: Int
    offset: Int
  ): [MinMaxValidator]
  msg: String
  numUids: Int
}

type DeletePageElementPayload {
  pageElement(
    filter: PageElementFilter
    order: PageElementOrder
    first: Int
    offset: Int
  ): [PageElement]
  msg: String
  numUids: Int
}

type DeletePagePayload {
  page(filter: PageFilter, order: PageOrder, first: Int, offset: Int): [Page]
  msg: String
  numUids: Int
}

type DeletePropPayload {
  prop(filter: PropFilter, order: PropOrder, first: Int, offset: Int): [Prop]
  msg: String
  numUids: Int
}

type DeleteRequiredValidatorPayload {
  requiredValidator(
    filter: RequiredValidatorFilter
    first: Int
    offset: Int
  ): [RequiredValidator]
  msg: String
  numUids: Int
}

type DeleteSimpleTypePayload {
  simpleType(filter: SimpleTypeFilter, first: Int, offset: Int): [SimpleType]
  msg: String
  numUids: Int
}

type DeleteTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  msg: String
  numUids: Int
}

type DeleteUnitTypePayload {
  unitType(filter: UnitTypeFilter, first: Int, offset: Int): [UnitType]
  msg: String
  numUids: Int
}

type DeleteValueTypePayload {
  valueType(
    filter: ValueTypeFilter
    order: ValueTypeOrder
    first: Int
    offset: Int
  ): [ValueType]
  msg: String
  numUids: Int
}

enum DgraphIndex {
  int
  int64
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
  geo
}

type EnumType {
  id: ID!
  allowedValues(
    filter: EnumTypeValueFilter
    order: EnumTypeValueOrder
    first: Int
    offset: Int
  ): [EnumTypeValue!]!
  allowedValuesAggregate(
    filter: EnumTypeValueFilter
  ): EnumTypeValueAggregateResult
}

type EnumTypeAggregateResult {
  count: Int
}

input EnumTypeFilter {
  id: [ID!]
  has: [EnumTypeHasFilter]
  and: [EnumTypeFilter]
  or: [EnumTypeFilter]
  not: EnumTypeFilter
}

enum EnumTypeHasFilter {
  allowedValues
}

input EnumTypePatch {
  allowedValues: [EnumTypeValueRef!]
}

input EnumTypeRef {
  id: ID
  allowedValues: [EnumTypeValueRef!]
}

type EnumTypeValue {
  id: ID!
  name: String!
}

type EnumTypeValueAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input EnumTypeValueFilter {
  id: [ID!]
  has: [EnumTypeValueHasFilter]
  and: [EnumTypeValueFilter]
  or: [EnumTypeValueFilter]
  not: EnumTypeValueFilter
}

enum EnumTypeValueHasFilter {
  name
}

input EnumTypeValueOrder {
  asc: EnumTypeValueOrderable
  desc: EnumTypeValueOrderable
  then: EnumTypeValueOrder
}

enum EnumTypeValueOrderable {
  name
}

input EnumTypeValuePatch {
  name: String
}

input EnumTypeValueRef {
  id: ID
  name: String
}

type Field {
  id: ID!
  type(filter: TypeFilter): Type!
  key: String!
  name: String!
  description: String
  decorators(filter: DecoratorFilter, first: Int, offset: Int): [Decorator]
  interface(filter: InterfaceFilter): Interface!
}

type FieldAggregateResult {
  count: Int
  keyMin: String
  keyMax: String
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
}

input FieldFilter {
  id: [ID!]
  key: StringFullTextFilter_StringHashFilter
  has: [FieldHasFilter]
  and: [FieldFilter]
  or: [FieldFilter]
  not: FieldFilter
}

enum FieldHasFilter {
  type
  key
  name
  description
  decorators
  interface
}

input FieldOrder {
  asc: FieldOrderable
  desc: FieldOrderable
  then: FieldOrder
}

enum FieldOrderable {
  key
  name
  description
}

input FieldPatch {
  type: TypeRef
  key: String
  name: String
  description: String
  decorators: [DecoratorRef]
  interface: InterfaceRef
}

input FieldRef {
  id: ID
  type: TypeRef
  key: String
  name: String
  description: String
  decorators: [DecoratorRef]
  interface: InterfaceRef
}

input FloatFilter {
  eq: Float
  in: [Float]
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: FloatRange
}

input FloatRange {
  min: Float!
  max: Float!
}

input GenerateMutationParams {
  add: Boolean
  update: Boolean
  delete: Boolean
}

input GenerateQueryParams {
  get: Boolean
  query: Boolean
  password: Boolean
  aggregate: Boolean
}

enum HTTPMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

"""
The Int64 scalar type represents a signed 64‐bit numeric non‐fractional value.
Int64 can represent values in range [-(2^63),(2^63 - 1)].
"""
scalar Int64

input Int64Filter {
  eq: Int64
  in: [Int64]
  le: Int64
  lt: Int64
  ge: Int64
  gt: Int64
  between: Int64Range
}

input Int64Range {
  min: Int64!
  max: Int64!
}

input IntFilter {
  eq: Int
  in: [Int]
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: IntRange
}

input IntRange {
  min: Int!
  max: Int!
}

type Interface {
  id: ID!
  name: String!
  fields(
    filter: FieldFilter
    order: FieldOrder
    first: Int
    offset: Int
  ): [Field]
  fieldsAggregate(filter: FieldFilter): FieldAggregateResult
}

type InterfaceAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input InterfaceFilter {
  id: [ID!]
  has: [InterfaceHasFilter]
  and: [InterfaceFilter]
  or: [InterfaceFilter]
  not: InterfaceFilter
}

enum InterfaceHasFilter {
  name
  fields
}

input InterfaceOrder {
  asc: InterfaceOrderable
  desc: InterfaceOrderable
  then: InterfaceOrder
}

enum InterfaceOrderable {
  name
}

input InterfacePatch {
  name: String
  fields: [FieldRef]
}

input InterfaceRef {
  id: ID
  name: String
  fields: [FieldRef]
}

input IntersectsFilter {
  polygon: PolygonRef
  multiPolygon: MultiPolygonRef
}

type Library {
  id: ID!
  ownerId: String!
  name: String!
  atoms(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  components(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  atomsAggregate(filter: AtomFilter): AtomAggregateResult
  componentsAggregate(filter: ComponentFilter): ComponentAggregateResult
}

type LibraryAggregateResult {
  count: Int
  ownerIdMin: String
  ownerIdMax: String
  nameMin: String
  nameMax: String
}

input LibraryFilter {
  id: [ID!]
  has: [LibraryHasFilter]
  and: [LibraryFilter]
  or: [LibraryFilter]
  not: LibraryFilter
}

enum LibraryHasFilter {
  ownerId
  name
  atoms
  components
}

input LibraryOrder {
  asc: LibraryOrderable
  desc: LibraryOrderable
  then: LibraryOrder
}

enum LibraryOrderable {
  ownerId
  name
}

input LibraryPatch {
  ownerId: String
  name: String
  atoms: [AtomRef]
  components: [ComponentRef]
}

input LibraryRef {
  id: ID
  ownerId: String
  name: String
  atoms: [AtomRef]
  components: [ComponentRef]
}

type MinMaxValidator {
  id: ID!
  min: Int
  max: Int
}

type MinMaxValidatorAggregateResult {
  count: Int
  minMin: Int
  minMax: Int
  minSum: Int
  minAvg: Float
  maxMin: Int
  maxMax: Int
  maxSum: Int
  maxAvg: Float
}

input MinMaxValidatorFilter {
  id: [ID!]
  has: [MinMaxValidatorHasFilter]
  and: [MinMaxValidatorFilter]
  or: [MinMaxValidatorFilter]
  not: MinMaxValidatorFilter
}

enum MinMaxValidatorHasFilter {
  min
  max
}

input MinMaxValidatorOrder {
  asc: MinMaxValidatorOrderable
  desc: MinMaxValidatorOrderable
  then: MinMaxValidatorOrder
}

enum MinMaxValidatorOrderable {
  min
  max
}

input MinMaxValidatorPatch {
  min: Int
  max: Int
}

input MinMaxValidatorRef {
  id: ID
  min: Int
  max: Int
}

enum Mode {
  BATCH
  SINGLE
}

type MultiPolygon {
  polygons: [Polygon!]!
}

input MultiPolygonRef {
  polygons: [PolygonRef!]!
}

type Mutation {
  addApp(input: [AddAppInput!]!): AddAppPayload
  updateApp(input: UpdateAppInput!): UpdateAppPayload
  deleteApp(filter: AppFilter!): DeleteAppPayload
  addPage(input: [AddPageInput!]!): AddPagePayload
  updatePage(input: UpdatePageInput!): UpdatePagePayload
  deletePage(filter: PageFilter!): DeletePagePayload
  addPageElement(input: [AddPageElementInput!]!): AddPageElementPayload
  updatePageElement(input: UpdatePageElementInput!): UpdatePageElementPayload
  deletePageElement(filter: PageElementFilter!): DeletePageElementPayload
  addLibrary(input: [AddLibraryInput!]!): AddLibraryPayload
  updateLibrary(input: UpdateLibraryInput!): UpdateLibraryPayload
  deleteLibrary(filter: LibraryFilter!): DeleteLibraryPayload
  addComponent(input: [AddComponentInput!]!): AddComponentPayload
  updateComponent(input: UpdateComponentInput!): UpdateComponentPayload
  deleteComponent(filter: ComponentFilter!): DeleteComponentPayload
  addAtom(input: [AddAtomInput!]!): AddAtomPayload
  updateAtom(input: UpdateAtomInput!): UpdateAtomPayload
  deleteAtom(filter: AtomFilter!): DeleteAtomPayload
  addTag(input: [AddTagInput!]!): AddTagPayload
  updateTag(input: UpdateTagInput!): UpdateTagPayload
  deleteTag(filter: TagFilter!): DeleteTagPayload
  addProp(input: [AddPropInput!]!): AddPropPayload
  updateProp(input: UpdatePropInput!): UpdatePropPayload
  deleteProp(filter: PropFilter!): DeletePropPayload
  addValueType(input: [AddValueTypeInput!]!): AddValueTypePayload
  updateValueType(input: UpdateValueTypeInput!): UpdateValueTypePayload
  deleteValueType(filter: ValueTypeFilter!): DeleteValueTypePayload
  addSimpleType(input: [AddSimpleTypeInput!]!): AddSimpleTypePayload
  updateSimpleType(input: UpdateSimpleTypeInput!): UpdateSimpleTypePayload
  deleteSimpleType(filter: SimpleTypeFilter!): DeleteSimpleTypePayload
  addArrayType(input: [AddArrayTypeInput!]!): AddArrayTypePayload
  updateArrayType(input: UpdateArrayTypeInput!): UpdateArrayTypePayload
  deleteArrayType(filter: ArrayTypeFilter!): DeleteArrayTypePayload
  addEnumTypeValue(input: [AddEnumTypeValueInput!]!): AddEnumTypeValuePayload
  updateEnumTypeValue(
    input: UpdateEnumTypeValueInput!
  ): UpdateEnumTypeValuePayload
  deleteEnumTypeValue(filter: EnumTypeValueFilter!): DeleteEnumTypeValuePayload
  addEnumType(input: [AddEnumTypeInput!]!): AddEnumTypePayload
  updateEnumType(input: UpdateEnumTypeInput!): UpdateEnumTypePayload
  deleteEnumType(filter: EnumTypeFilter!): DeleteEnumTypePayload
  addUnitType(input: [AddUnitTypeInput!]!): AddUnitTypePayload
  updateUnitType(input: UpdateUnitTypeInput!): UpdateUnitTypePayload
  deleteUnitType(filter: UnitTypeFilter!): DeleteUnitTypePayload
  addRequiredValidator(
    input: [AddRequiredValidatorInput!]!
  ): AddRequiredValidatorPayload
  updateRequiredValidator(
    input: UpdateRequiredValidatorInput!
  ): UpdateRequiredValidatorPayload
  deleteRequiredValidator(
    filter: RequiredValidatorFilter!
  ): DeleteRequiredValidatorPayload
  addMinMaxValidator(
    input: [AddMinMaxValidatorInput!]!
  ): AddMinMaxValidatorPayload
  updateMinMaxValidator(
    input: UpdateMinMaxValidatorInput!
  ): UpdateMinMaxValidatorPayload
  deleteMinMaxValidator(
    filter: MinMaxValidatorFilter!
  ): DeleteMinMaxValidatorPayload
  addArrayLengthValidator(
    input: [AddArrayLengthValidatorInput!]!
  ): AddArrayLengthValidatorPayload
  updateArrayLengthValidator(
    input: UpdateArrayLengthValidatorInput!
  ): UpdateArrayLengthValidatorPayload
  deleteArrayLengthValidator(
    filter: ArrayLengthValidatorFilter!
  ): DeleteArrayLengthValidatorPayload
  addField(input: [AddFieldInput!]!): AddFieldPayload
  updateField(input: UpdateFieldInput!): UpdateFieldPayload
  deleteField(filter: FieldFilter!): DeleteFieldPayload
  addInterface(input: [AddInterfaceInput!]!): AddInterfacePayload
  updateInterface(input: UpdateInterfaceInput!): UpdateInterfacePayload
  deleteInterface(filter: InterfaceFilter!): DeleteInterfacePayload
}

input NearFilter {
  distance: Float!
  coordinate: PointRef!
}

type Page {
  id: ID!
  name: String!
  app(filter: AppFilter): App!
  rootElement(filter: PageElementFilter): PageElement!
}

type PageAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

type PageElement {
  id: ID!
  name: String!
  page(filter: PageFilter): Page!
  parent(filter: PageElementFilter): PageElement
  children(
    filter: PageElementFilter
    order: PageElementOrder
    first: Int
    offset: Int
  ): [PageElement]
  atom(filter: AtomFilter): Atom
  component(filter: ComponentFilter): Component
  childrenAggregate(filter: PageElementFilter): PageElementAggregateResult
}

type PageElementAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input PageElementFilter {
  id: [ID!]
  name: StringFullTextFilter_StringTermFilter
  has: [PageElementHasFilter]
  and: [PageElementFilter]
  or: [PageElementFilter]
  not: PageElementFilter
}

enum PageElementHasFilter {
  name
  page
  parent
  children
  atom
  component
}

input PageElementOrder {
  asc: PageElementOrderable
  desc: PageElementOrderable
  then: PageElementOrder
}

enum PageElementOrderable {
  name
}

input PageElementPatch {
  name: String
  page: PageRef
  parent: PageElementRef
  children: [PageElementRef]
  atom: AtomRef
  component: ComponentRef
}

input PageElementRef {
  id: ID
  name: String
  page: PageRef
  parent: PageElementRef
  children: [PageElementRef]
  atom: AtomRef
  component: ComponentRef
}

input PageFilter {
  id: [ID!]
  name: StringFullTextFilter_StringTermFilter
  has: [PageHasFilter]
  and: [PageFilter]
  or: [PageFilter]
  not: PageFilter
}

enum PageHasFilter {
  name
  app
  rootElement
}

input PageOrder {
  asc: PageOrderable
  desc: PageOrderable
  then: PageOrder
}

enum PageOrderable {
  name
}

input PagePatch {
  name: String
  app: AppRef
  rootElement: PageElementRef
}

input PageRef {
  id: ID
  name: String
  app: AppRef
  rootElement: PageElementRef
}

type Point {
  longitude: Float!
  latitude: Float!
}

input PointGeoFilter {
  near: NearFilter
  within: WithinFilter
}

type PointList {
  points: [Point!]!
}

input PointListRef {
  points: [PointRef!]!
}

input PointRef {
  longitude: Float!
  latitude: Float!
}

type Polygon {
  coordinates: [PointList!]!
}

input PolygonGeoFilter {
  near: NearFilter
  within: WithinFilter
  contains: ContainsFilter
  intersects: IntersectsFilter
}

input PolygonRef {
  coordinates: [PointListRef!]!
}

enum PrimitiveType {
  String
  Integer
  Float
  Boolean
}

type Prop {
  id: ID!
  description: String
  type(filter: ValueTypeFilter): ValueType!
  props(filter: PropFilter, order: PropOrder, first: Int, offset: Int): [Prop]
  propsAggregate(filter: PropFilter): PropAggregateResult
}

type PropAggregateResult {
  count: Int
  descriptionMin: String
  descriptionMax: String
}

input PropFilter {
  id: [ID!]
  has: [PropHasFilter]
  and: [PropFilter]
  or: [PropFilter]
  not: PropFilter
}

enum PropHasFilter {
  description
  type
  props
}

input PropOrder {
  asc: PropOrderable
  desc: PropOrderable
  then: PropOrder
}

enum PropOrderable {
  description
}

input PropPatch {
  description: String
  type: ValueTypeRef
  props: [PropRef]
}

input PropRef {
  id: ID
  description: String
  type: ValueTypeRef
  props: [PropRef]
}

type Query {
  getApp(id: ID!): App
  queryApp(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  aggregateApp(filter: AppFilter): AppAggregateResult
  getPage(id: ID!): Page
  queryPage(
    filter: PageFilter
    order: PageOrder
    first: Int
    offset: Int
  ): [Page]
  aggregatePage(filter: PageFilter): PageAggregateResult
  getPageElement(id: ID!): PageElement
  queryPageElement(
    filter: PageElementFilter
    order: PageElementOrder
    first: Int
    offset: Int
  ): [PageElement]
  aggregatePageElement(filter: PageElementFilter): PageElementAggregateResult
  getLibrary(id: ID!): Library
  queryLibrary(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  aggregateLibrary(filter: LibraryFilter): LibraryAggregateResult
  getComponent(id: ID!): Component
  queryComponent(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  aggregateComponent(filter: ComponentFilter): ComponentAggregateResult
  getAtom(id: ID!): Atom
  queryAtom(
    filter: AtomFilter
    order: AtomOrder
    first: Int
    offset: Int
  ): [Atom]
  aggregateAtom(filter: AtomFilter): AtomAggregateResult
  queryTag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  aggregateTag(filter: TagFilter): TagAggregateResult
  getProp(id: ID!): Prop
  queryProp(
    filter: PropFilter
    order: PropOrder
    first: Int
    offset: Int
  ): [Prop]
  aggregateProp(filter: PropFilter): PropAggregateResult
  getValueType(id: ID!): ValueType
  queryValueType(
    filter: ValueTypeFilter
    order: ValueTypeOrder
    first: Int
    offset: Int
  ): [ValueType]
  aggregateValueType(filter: ValueTypeFilter): ValueTypeAggregateResult
  getSimpleType(id: ID!): SimpleType
  querySimpleType(
    filter: SimpleTypeFilter
    first: Int
    offset: Int
  ): [SimpleType]
  aggregateSimpleType(filter: SimpleTypeFilter): SimpleTypeAggregateResult
  getArrayType(id: ID!): ArrayType
  queryArrayType(filter: ArrayTypeFilter, first: Int, offset: Int): [ArrayType]
  aggregateArrayType(filter: ArrayTypeFilter): ArrayTypeAggregateResult
  getEnumTypeValue(id: ID!): EnumTypeValue
  queryEnumTypeValue(
    filter: EnumTypeValueFilter
    order: EnumTypeValueOrder
    first: Int
    offset: Int
  ): [EnumTypeValue]
  aggregateEnumTypeValue(
    filter: EnumTypeValueFilter
  ): EnumTypeValueAggregateResult
  getEnumType(id: ID!): EnumType
  queryEnumType(filter: EnumTypeFilter, first: Int, offset: Int): [EnumType]
  aggregateEnumType(filter: EnumTypeFilter): EnumTypeAggregateResult
  getUnitType(id: ID!): UnitType
  queryUnitType(filter: UnitTypeFilter, first: Int, offset: Int): [UnitType]
  aggregateUnitType(filter: UnitTypeFilter): UnitTypeAggregateResult
  getRequiredValidator(id: ID!): RequiredValidator
  queryRequiredValidator(
    filter: RequiredValidatorFilter
    first: Int
    offset: Int
  ): [RequiredValidator]
  aggregateRequiredValidator(
    filter: RequiredValidatorFilter
  ): RequiredValidatorAggregateResult
  getMinMaxValidator(id: ID!): MinMaxValidator
  queryMinMaxValidator(
    filter: MinMaxValidatorFilter
    order: MinMaxValidatorOrder
    first: Int
    offset: Int
  ): [MinMaxValidator]
  aggregateMinMaxValidator(
    filter: MinMaxValidatorFilter
  ): MinMaxValidatorAggregateResult
  getArrayLengthValidator(id: ID!): ArrayLengthValidator
  queryArrayLengthValidator(
    filter: ArrayLengthValidatorFilter
    order: ArrayLengthValidatorOrder
    first: Int
    offset: Int
  ): [ArrayLengthValidator]
  aggregateArrayLengthValidator(
    filter: ArrayLengthValidatorFilter
  ): ArrayLengthValidatorAggregateResult
  getField(id: ID!): Field
  queryField(
    filter: FieldFilter
    order: FieldOrder
    first: Int
    offset: Int
  ): [Field]
  aggregateField(filter: FieldFilter): FieldAggregateResult
  getInterface(id: ID!): Interface
  queryInterface(
    filter: InterfaceFilter
    order: InterfaceOrder
    first: Int
    offset: Int
  ): [Interface]
  aggregateInterface(filter: InterfaceFilter): InterfaceAggregateResult
}

type RequiredValidator {
  id: ID!
  isRequired: Boolean!
}

type RequiredValidatorAggregateResult {
  count: Int
}

input RequiredValidatorFilter {
  id: [ID!]
  has: [RequiredValidatorHasFilter]
  and: [RequiredValidatorFilter]
  or: [RequiredValidatorFilter]
  not: RequiredValidatorFilter
}

enum RequiredValidatorHasFilter {
  isRequired
}

input RequiredValidatorPatch {
  isRequired: Boolean
}

input RequiredValidatorRef {
  id: ID
  isRequired: Boolean
}

type SimpleType {
  id: ID!
  primitiveType: PrimitiveType!
}

type SimpleTypeAggregateResult {
  count: Int
}

input SimpleTypeFilter {
  id: [ID!]
  has: [SimpleTypeHasFilter]
  and: [SimpleTypeFilter]
  or: [SimpleTypeFilter]
  not: SimpleTypeFilter
}

enum SimpleTypeHasFilter {
  primitiveType
}

input SimpleTypePatch {
  primitiveType: PrimitiveType
}

input SimpleTypeRef {
  id: ID
  primitiveType: PrimitiveType
}

input StringExactFilter {
  eq: String
  in: [String]
  le: String
  lt: String
  ge: String
  gt: String
  between: StringRange
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringFullTextFilter_StringHashFilter {
  alloftext: String
  anyoftext: String
  eq: String
  in: [String]
}

input StringFullTextFilter_StringTermFilter {
  alloftext: String
  anyoftext: String
  allofterms: String
  anyofterms: String
}

input StringHashFilter {
  eq: String
  in: [String]
}

input StringRange {
  min: String!
  max: String!
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

type Tag {
  label: String!
}

type TagAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
}

input TagFilter {
  has: [TagHasFilter]
  and: [TagFilter]
  or: [TagFilter]
  not: TagFilter
}

enum TagHasFilter {
  label
}

input TagOrder {
  asc: TagOrderable
  desc: TagOrderable
  then: TagOrder
}

enum TagOrderable {
  label
}

input TagPatch {
  label: String
}

input TagRef {
  label: String
}

union Type = SimpleType | Interface | ArrayType | EnumType | UnitType

input TypeFilter {
  memberTypes: [TypeType!]
  simpleTypeFilter: SimpleTypeFilter
  interfaceFilter: InterfaceFilter
  arrayTypeFilter: ArrayTypeFilter
  enumTypeFilter: EnumTypeFilter
  unitTypeFilter: UnitTypeFilter
}

input TypeRef {
  simpleTypeRef: SimpleTypeRef
  interfaceRef: InterfaceRef
  arrayTypeRef: ArrayTypeRef
  enumTypeRef: EnumTypeRef
  unitTypeRef: UnitTypeRef
}

enum TypeType {
  SimpleType
  Interface
  ArrayType
  EnumType
  UnitType
}

enum Unit {
  PX
  PT
  EM
  REM
  PERCENT
  VW
  VH
}

type UnitType {
  id: ID!
  allowedUnits: [Unit!]!
}

type UnitTypeAggregateResult {
  count: Int
}

input UnitTypeFilter {
  id: [ID!]
  has: [UnitTypeHasFilter]
  and: [UnitTypeFilter]
  or: [UnitTypeFilter]
  not: UnitTypeFilter
}

enum UnitTypeHasFilter {
  allowedUnits
}

input UnitTypePatch {
  allowedUnits: [Unit!]
}

input UnitTypeRef {
  id: ID
  allowedUnits: [Unit!]
}

input UpdateAppInput {
  filter: AppFilter!
  set: AppPatch
  remove: AppPatch
}

type UpdateAppPayload {
  app(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  numUids: Int
}

input UpdateArrayLengthValidatorInput {
  filter: ArrayLengthValidatorFilter!
  set: ArrayLengthValidatorPatch
  remove: ArrayLengthValidatorPatch
}

type UpdateArrayLengthValidatorPayload {
  arrayLengthValidator(
    filter: ArrayLengthValidatorFilter
    order: ArrayLengthValidatorOrder
    first: Int
    offset: Int
  ): [ArrayLengthValidator]
  numUids: Int
}

input UpdateArrayTypeInput {
  filter: ArrayTypeFilter!
  set: ArrayTypePatch
  remove: ArrayTypePatch
}

type UpdateArrayTypePayload {
  arrayType(filter: ArrayTypeFilter, first: Int, offset: Int): [ArrayType]
  numUids: Int
}

input UpdateAtomInput {
  filter: AtomFilter!
  set: AtomPatch
  remove: AtomPatch
}

type UpdateAtomPayload {
  atom(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  numUids: Int
}

input UpdateComponentInput {
  filter: ComponentFilter!
  set: ComponentPatch
  remove: ComponentPatch
}

type UpdateComponentPayload {
  component(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  numUids: Int
}

input UpdateEnumTypeInput {
  filter: EnumTypeFilter!
  set: EnumTypePatch
  remove: EnumTypePatch
}

type UpdateEnumTypePayload {
  enumType(filter: EnumTypeFilter, first: Int, offset: Int): [EnumType]
  numUids: Int
}

input UpdateEnumTypeValueInput {
  filter: EnumTypeValueFilter!
  set: EnumTypeValuePatch
  remove: EnumTypeValuePatch
}

type UpdateEnumTypeValuePayload {
  enumTypeValue(
    filter: EnumTypeValueFilter
    order: EnumTypeValueOrder
    first: Int
    offset: Int
  ): [EnumTypeValue]
  numUids: Int
}

input UpdateFieldInput {
  filter: FieldFilter!
  set: FieldPatch
  remove: FieldPatch
}

type UpdateFieldPayload {
  field(
    filter: FieldFilter
    order: FieldOrder
    first: Int
    offset: Int
  ): [Field]
  numUids: Int
}

input UpdateInterfaceInput {
  filter: InterfaceFilter!
  set: InterfacePatch
  remove: InterfacePatch
}

type UpdateInterfacePayload {
  interface(
    filter: InterfaceFilter
    order: InterfaceOrder
    first: Int
    offset: Int
  ): [Interface]
  numUids: Int
}

input UpdateLibraryInput {
  filter: LibraryFilter!
  set: LibraryPatch
  remove: LibraryPatch
}

type UpdateLibraryPayload {
  library(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  numUids: Int
}

input UpdateMinMaxValidatorInput {
  filter: MinMaxValidatorFilter!
  set: MinMaxValidatorPatch
  remove: MinMaxValidatorPatch
}

type UpdateMinMaxValidatorPayload {
  minMaxValidator(
    filter: MinMaxValidatorFilter
    order: MinMaxValidatorOrder
    first: Int
    offset: Int
  ): [MinMaxValidator]
  numUids: Int
}

input UpdatePageElementInput {
  filter: PageElementFilter!
  set: PageElementPatch
  remove: PageElementPatch
}

type UpdatePageElementPayload {
  pageElement(
    filter: PageElementFilter
    order: PageElementOrder
    first: Int
    offset: Int
  ): [PageElement]
  numUids: Int
}

input UpdatePageInput {
  filter: PageFilter!
  set: PagePatch
  remove: PagePatch
}

type UpdatePagePayload {
  page(filter: PageFilter, order: PageOrder, first: Int, offset: Int): [Page]
  numUids: Int
}

input UpdatePropInput {
  filter: PropFilter!
  set: PropPatch
  remove: PropPatch
}

type UpdatePropPayload {
  prop(filter: PropFilter, order: PropOrder, first: Int, offset: Int): [Prop]
  numUids: Int
}

input UpdateRequiredValidatorInput {
  filter: RequiredValidatorFilter!
  set: RequiredValidatorPatch
  remove: RequiredValidatorPatch
}

type UpdateRequiredValidatorPayload {
  requiredValidator(
    filter: RequiredValidatorFilter
    first: Int
    offset: Int
  ): [RequiredValidator]
  numUids: Int
}

input UpdateSimpleTypeInput {
  filter: SimpleTypeFilter!
  set: SimpleTypePatch
  remove: SimpleTypePatch
}

type UpdateSimpleTypePayload {
  simpleType(filter: SimpleTypeFilter, first: Int, offset: Int): [SimpleType]
  numUids: Int
}

input UpdateTagInput {
  filter: TagFilter!
  set: TagPatch
  remove: TagPatch
}

type UpdateTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  numUids: Int
}

input UpdateUnitTypeInput {
  filter: UnitTypeFilter!
  set: UnitTypePatch
  remove: UnitTypePatch
}

type UpdateUnitTypePayload {
  unitType(filter: UnitTypeFilter, first: Int, offset: Int): [UnitType]
  numUids: Int
}

input UpdateValueTypeInput {
  filter: ValueTypeFilter!
  set: ValueTypePatch
  remove: ValueTypePatch
}

type UpdateValueTypePayload {
  valueType(
    filter: ValueTypeFilter
    order: ValueTypeOrder
    first: Int
    offset: Int
  ): [ValueType]
  numUids: Int
}

type ValueType {
  id: ID!
  label: String!
  type: String!
}

type ValueTypeAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
  typeMin: String
  typeMax: String
}

input ValueTypeFilter {
  id: [ID!]
  has: [ValueTypeHasFilter]
  and: [ValueTypeFilter]
  or: [ValueTypeFilter]
  not: ValueTypeFilter
}

enum ValueTypeHasFilter {
  label
  type
}

input ValueTypeOrder {
  asc: ValueTypeOrderable
  desc: ValueTypeOrderable
  then: ValueTypeOrder
}

enum ValueTypeOrderable {
  label
  type
}

input ValueTypePatch {
  label: String
  type: String
}

input ValueTypeRef {
  id: ID
  label: String
  type: String
}

input WithinFilter {
  polygon: PolygonRef!
}
