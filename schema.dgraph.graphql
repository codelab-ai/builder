directive @auth(
  password: AuthRule
  query: AuthRule
  add: AuthRule
  update: AuthRule
  delete: AuthRule
) on OBJECT | INTERFACE

directive @cacheControl(maxAge: Int!) on QUERY

directive @cascade(fields: [String]) on FIELD

directive @custom(http: CustomHTTP, dql: String) on FIELD_DEFINITION

directive @dgraph(
  type: String
  pred: String
) on OBJECT | INTERFACE | FIELD_DEFINITION

directive @generate(
  query: GenerateQueryParams
  mutation: GenerateMutationParams
  subscription: Boolean
) on OBJECT | INTERFACE

directive @hasInverse(field: String!) on FIELD_DEFINITION

directive @id on FIELD_DEFINITION

directive @lambda on FIELD_DEFINITION

directive @lambdaOnMutate(
  add: Boolean
  update: Boolean
  delete: Boolean
) on OBJECT | INTERFACE

directive @remote on OBJECT | INTERFACE | UNION | INPUT_OBJECT | ENUM

directive @remoteResponse(name: String) on FIELD_DEFINITION

directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION

directive @secret(field: String!, pred: String) on OBJECT | INTERFACE

directive @withSubscription on OBJECT | INTERFACE | FIELD_DEFINITION

input AddAppInput {
  ownerId: String!
  pages: [PageRef]
  name: String!
}

type AddAppPayload {
  app(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  numUids: Int
}

input AddAtomInput {
  type: AtomTypeRef!
  label: String!
  library: LibraryRef
}

type AddAtomPayload {
  atom(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  numUids: Int
}

input AddAtomTypeInput {
  label: String!
  type: String!
}

type AddAtomTypePayload {
  atomType(
    filter: AtomTypeFilter
    order: AtomTypeOrder
    first: Int
    offset: Int
  ): [AtomType]
  numUids: Int
}

input AddComponentInput {
  library: LibraryRef!
  atom: AtomRef!
  label: String!
  children: [ComponentRef]
  tags: [TagRef]
}

type AddComponentPayload {
  component(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  numUids: Int
}

input AddLibraryInput {
  ownerId: String!
  name: String!
  atoms: [AtomRef]
  components: [ComponentRef]
}

type AddLibraryPayload {
  library(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  numUids: Int
}

input AddPageInput {
  title: String!
  app: AppRef
}

type AddPagePayload {
  page(filter: PageFilter, order: PageOrder, first: Int, offset: Int): [Page]
  numUids: Int
}

input AddTagInput {
  label: String!
}

type AddTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  numUids: Int
}

type App {
  id: ID!
  ownerId: String!
  pages(filter: PageFilter, order: PageOrder, first: Int, offset: Int): [Page]
  name: String!
  pagesAggregate(filter: PageFilter): PageAggregateResult
}

type AppAggregateResult {
  count: Int
  ownerIdMin: String
  ownerIdMax: String
  nameMin: String
  nameMax: String
}

input AppFilter {
  id: [ID!]
  ownerId: StringHashFilter
  has: [AppHasFilter]
  and: [AppFilter]
  or: [AppFilter]
  not: AppFilter
}

enum AppHasFilter {
  ownerId
  pages
  name
}

input AppOrder {
  asc: AppOrderable
  desc: AppOrderable
  then: AppOrder
}

enum AppOrderable {
  ownerId
  name
}

input AppPatch {
  ownerId: String
  pages: [PageRef]
  name: String
}

input AppRef {
  id: ID
  ownerId: String
  pages: [PageRef]
  name: String
}

type Atom {
  id: ID!
  type(filter: AtomTypeFilter): AtomType!
  label: String!
  library(filter: LibraryFilter): Library
}

type AtomAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
}

input AtomFilter {
  id: [ID!]
  has: [AtomHasFilter]
  and: [AtomFilter]
  or: [AtomFilter]
  not: AtomFilter
}

enum AtomHasFilter {
  type
  label
  library
}

input AtomOrder {
  asc: AtomOrderable
  desc: AtomOrderable
  then: AtomOrder
}

enum AtomOrderable {
  label
}

input AtomPatch {
  type: AtomTypeRef
  label: String
  library: LibraryRef
}

input AtomRef {
  id: ID
  type: AtomTypeRef
  label: String
  library: LibraryRef
}

type AtomType {
  id: ID!
  label: String!
  type: String!
}

type AtomTypeAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
  typeMin: String
  typeMax: String
}

input AtomTypeFilter {
  id: [ID!]
  has: [AtomTypeHasFilter]
  and: [AtomTypeFilter]
  or: [AtomTypeFilter]
  not: AtomTypeFilter
}

enum AtomTypeHasFilter {
  label
  type
}

input AtomTypeOrder {
  asc: AtomTypeOrderable
  desc: AtomTypeOrderable
  then: AtomTypeOrder
}

enum AtomTypeOrderable {
  label
  type
}

input AtomTypePatch {
  label: String
  type: String
}

input AtomTypeRef {
  id: ID
  label: String
  type: String
}

input AuthRule {
  and: [AuthRule]
  or: [AuthRule]
  not: AuthRule
  rule: String
}

type Component {
  id: ID!
  library(filter: LibraryFilter): Library!
  atom(filter: AtomFilter): Atom!
  label: String!
  children(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  tags(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  childrenAggregate(filter: ComponentFilter): ComponentAggregateResult
  tagsAggregate(filter: TagFilter): TagAggregateResult
}

type ComponentAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
}

input ComponentFilter {
  id: [ID!]
  has: [ComponentHasFilter]
  and: [ComponentFilter]
  or: [ComponentFilter]
  not: ComponentFilter
}

enum ComponentHasFilter {
  library
  atom
  label
  children
  tags
}

input ComponentOrder {
  asc: ComponentOrderable
  desc: ComponentOrderable
  then: ComponentOrder
}

enum ComponentOrderable {
  label
}

input ComponentPatch {
  library: LibraryRef
  atom: AtomRef
  label: String
  children: [ComponentRef]
  tags: [TagRef]
}

input ComponentRef {
  id: ID
  library: LibraryRef
  atom: AtomRef
  label: String
  children: [ComponentRef]
  tags: [TagRef]
}

input ContainsFilter {
  point: PointRef
  polygon: PolygonRef
}

input CustomHTTP {
  url: String!
  method: HTTPMethod!
  body: String
  graphql: String
  mode: Mode
  forwardHeaders: [String!]
  secretHeaders: [String!]
  introspectionHeaders: [String!]
  skipIntrospection: Boolean
}

"""
The DateTime scalar type represents date and time as a string in RFC3339 format.
For example: "1985-04-12T23:20:50.52Z" represents 20 minutes and 50.52 seconds after the 23rd hour of April 12th, 1985 in UTC.
"""
scalar DateTime

input DateTimeFilter {
  eq: DateTime
  in: [DateTime]
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
  between: DateTimeRange
}

input DateTimeRange {
  min: DateTime!
  max: DateTime!
}

type DeleteAppPayload {
  app(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  msg: String
  numUids: Int
}

type DeleteAtomPayload {
  atom(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  msg: String
  numUids: Int
}

type DeleteAtomTypePayload {
  atomType(
    filter: AtomTypeFilter
    order: AtomTypeOrder
    first: Int
    offset: Int
  ): [AtomType]
  msg: String
  numUids: Int
}

type DeleteComponentPayload {
  component(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  msg: String
  numUids: Int
}

type DeleteLibraryPayload {
  library(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  msg: String
  numUids: Int
}

type DeletePagePayload {
  page(filter: PageFilter, order: PageOrder, first: Int, offset: Int): [Page]
  msg: String
  numUids: Int
}

type DeleteTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  msg: String
  numUids: Int
}

enum DgraphIndex {
  int
  int64
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
  geo
}

input FloatFilter {
  eq: Float
  in: [Float]
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: FloatRange
}

input FloatRange {
  min: Float!
  max: Float!
}

input GenerateMutationParams {
  add: Boolean
  update: Boolean
  delete: Boolean
}

input GenerateQueryParams {
  get: Boolean
  query: Boolean
  password: Boolean
  aggregate: Boolean
}

enum HTTPMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

"""
The Int64 scalar type represents a signed 64‐bit numeric non‐fractional value.
Int64 can represent values in range [-(2^63),(2^63 - 1)].
"""
scalar Int64

input Int64Filter {
  eq: Int64
  in: [Int64]
  le: Int64
  lt: Int64
  ge: Int64
  gt: Int64
  between: Int64Range
}

input Int64Range {
  min: Int64!
  max: Int64!
}

input IntFilter {
  eq: Int
  in: [Int]
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: IntRange
}

input IntRange {
  min: Int!
  max: Int!
}

input IntersectsFilter {
  polygon: PolygonRef
  multiPolygon: MultiPolygonRef
}

type Library {
  id: ID!
  ownerId: String!
  name: String!
  atoms(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  components(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  atomsAggregate(filter: AtomFilter): AtomAggregateResult
  componentsAggregate(filter: ComponentFilter): ComponentAggregateResult
}

type LibraryAggregateResult {
  count: Int
  ownerIdMin: String
  ownerIdMax: String
  nameMin: String
  nameMax: String
}

input LibraryFilter {
  id: [ID!]
  has: [LibraryHasFilter]
  and: [LibraryFilter]
  or: [LibraryFilter]
  not: LibraryFilter
}

enum LibraryHasFilter {
  ownerId
  name
  atoms
  components
}

input LibraryOrder {
  asc: LibraryOrderable
  desc: LibraryOrderable
  then: LibraryOrder
}

enum LibraryOrderable {
  ownerId
  name
}

input LibraryPatch {
  ownerId: String
  name: String
  atoms: [AtomRef]
  components: [ComponentRef]
}

input LibraryRef {
  id: ID
  ownerId: String
  name: String
  atoms: [AtomRef]
  components: [ComponentRef]
}

enum Mode {
  BATCH
  SINGLE
}

type MultiPolygon {
  polygons: [Polygon!]!
}

input MultiPolygonRef {
  polygons: [PolygonRef!]!
}

type Mutation {
  addApp(input: [AddAppInput!]!): AddAppPayload
  updateApp(input: UpdateAppInput!): UpdateAppPayload
  deleteApp(filter: AppFilter!): DeleteAppPayload
  addPage(input: [AddPageInput!]!): AddPagePayload
  updatePage(input: UpdatePageInput!): UpdatePagePayload
  deletePage(filter: PageFilter!): DeletePagePayload
  addLibrary(input: [AddLibraryInput!]!): AddLibraryPayload
  updateLibrary(input: UpdateLibraryInput!): UpdateLibraryPayload
  deleteLibrary(filter: LibraryFilter!): DeleteLibraryPayload
  addComponent(input: [AddComponentInput!]!): AddComponentPayload
  updateComponent(input: UpdateComponentInput!): UpdateComponentPayload
  deleteComponent(filter: ComponentFilter!): DeleteComponentPayload
  addAtom(input: [AddAtomInput!]!): AddAtomPayload
  updateAtom(input: UpdateAtomInput!): UpdateAtomPayload
  deleteAtom(filter: AtomFilter!): DeleteAtomPayload
  addAtomType(input: [AddAtomTypeInput!]!): AddAtomTypePayload
  updateAtomType(input: UpdateAtomTypeInput!): UpdateAtomTypePayload
  deleteAtomType(filter: AtomTypeFilter!): DeleteAtomTypePayload
  addTag(input: [AddTagInput!]!): AddTagPayload
  updateTag(input: UpdateTagInput!): UpdateTagPayload
  deleteTag(filter: TagFilter!): DeleteTagPayload
}

input NearFilter {
  distance: Float!
  coordinate: PointRef!
}

type Page {
  id: ID!
  title: String!
  app(filter: AppFilter): App
}

type PageAggregateResult {
  count: Int
  titleMin: String
  titleMax: String
}

input PageFilter {
  id: [ID!]
  title: StringFullTextFilter_StringTermFilter
  has: [PageHasFilter]
  and: [PageFilter]
  or: [PageFilter]
  not: PageFilter
}

enum PageHasFilter {
  title
  app
}

input PageOrder {
  asc: PageOrderable
  desc: PageOrderable
  then: PageOrder
}

enum PageOrderable {
  title
}

input PagePatch {
  title: String
  app: AppRef
}

input PageRef {
  id: ID
  title: String
  app: AppRef
}

type Point {
  longitude: Float!
  latitude: Float!
}

input PointGeoFilter {
  near: NearFilter
  within: WithinFilter
}

type PointList {
  points: [Point!]!
}

input PointListRef {
  points: [PointRef!]!
}

input PointRef {
  longitude: Float!
  latitude: Float!
}

type Polygon {
  coordinates: [PointList!]!
}

input PolygonGeoFilter {
  near: NearFilter
  within: WithinFilter
  contains: ContainsFilter
  intersects: IntersectsFilter
}

input PolygonRef {
  coordinates: [PointListRef!]!
}

type Query {
  getApp(id: ID!): App
  queryApp(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  aggregateApp(filter: AppFilter): AppAggregateResult
  getPage(id: ID!): Page
  queryPage(
    filter: PageFilter
    order: PageOrder
    first: Int
    offset: Int
  ): [Page]
  aggregatePage(filter: PageFilter): PageAggregateResult
  getLibrary(id: ID!): Library
  queryLibrary(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  aggregateLibrary(filter: LibraryFilter): LibraryAggregateResult
  getComponent(id: ID!): Component
  queryComponent(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  aggregateComponent(filter: ComponentFilter): ComponentAggregateResult
  getAtom(id: ID!): Atom
  queryAtom(
    filter: AtomFilter
    order: AtomOrder
    first: Int
    offset: Int
  ): [Atom]
  aggregateAtom(filter: AtomFilter): AtomAggregateResult
  getAtomType(id: ID!): AtomType
  queryAtomType(
    filter: AtomTypeFilter
    order: AtomTypeOrder
    first: Int
    offset: Int
  ): [AtomType]
  aggregateAtomType(filter: AtomTypeFilter): AtomTypeAggregateResult
  queryTag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  aggregateTag(filter: TagFilter): TagAggregateResult
}

input StringExactFilter {
  eq: String
  in: [String]
  le: String
  lt: String
  ge: String
  gt: String
  between: StringRange
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringFullTextFilter_StringTermFilter {
  alloftext: String
  anyoftext: String
  allofterms: String
  anyofterms: String
}

input StringHashFilter {
  eq: String
  in: [String]
}

input StringRange {
  min: String!
  max: String!
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

type Tag {
  label: String!
}

type TagAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
}

input TagFilter {
  has: [TagHasFilter]
  and: [TagFilter]
  or: [TagFilter]
  not: TagFilter
}

enum TagHasFilter {
  label
}

input TagOrder {
  asc: TagOrderable
  desc: TagOrderable
  then: TagOrder
}

enum TagOrderable {
  label
}

input TagPatch {
  label: String
}

input TagRef {
  label: String
}

input UpdateAppInput {
  filter: AppFilter!
  set: AppPatch
  remove: AppPatch
}

type UpdateAppPayload {
  app(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  numUids: Int
}

input UpdateAtomInput {
  filter: AtomFilter!
  set: AtomPatch
  remove: AtomPatch
}

type UpdateAtomPayload {
  atom(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  numUids: Int
}

input UpdateAtomTypeInput {
  filter: AtomTypeFilter!
  set: AtomTypePatch
  remove: AtomTypePatch
}

type UpdateAtomTypePayload {
  atomType(
    filter: AtomTypeFilter
    order: AtomTypeOrder
    first: Int
    offset: Int
  ): [AtomType]
  numUids: Int
}

input UpdateComponentInput {
  filter: ComponentFilter!
  set: ComponentPatch
  remove: ComponentPatch
}

type UpdateComponentPayload {
  component(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  numUids: Int
}

input UpdateLibraryInput {
  filter: LibraryFilter!
  set: LibraryPatch
  remove: LibraryPatch
}

type UpdateLibraryPayload {
  library(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  numUids: Int
}

input UpdatePageInput {
  filter: PageFilter!
  set: PagePatch
  remove: PagePatch
}

type UpdatePagePayload {
  page(filter: PageFilter, order: PageOrder, first: Int, offset: Int): [Page]
  numUids: Int
}

input UpdateTagInput {
  filter: TagFilter!
  set: TagPatch
  remove: TagPatch
}

type UpdateTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  numUids: Int
}

input WithinFilter {
  polygon: PolygonRef!
}
