directive @auth(
  password: AuthRule
  query: AuthRule
  add: AuthRule
  update: AuthRule
  delete: AuthRule
) on OBJECT | INTERFACE

directive @cacheControl(maxAge: Int!) on QUERY

directive @cascade(fields: [String]) on FIELD

directive @custom(http: CustomHTTP, dql: String) on FIELD_DEFINITION

directive @dgraph(
  type: String
  pred: String
) on OBJECT | INTERFACE | FIELD_DEFINITION

directive @generate(
  query: GenerateQueryParams
  mutation: GenerateMutationParams
  subscription: Boolean
) on OBJECT | INTERFACE

directive @hasInverse(field: String!) on FIELD_DEFINITION

directive @id on FIELD_DEFINITION

directive @lambda on FIELD_DEFINITION

directive @lambdaOnMutate(
  add: Boolean
  update: Boolean
  delete: Boolean
) on OBJECT | INTERFACE

directive @remote on OBJECT | INTERFACE | UNION | INPUT_OBJECT | ENUM

directive @remoteResponse(name: String) on FIELD_DEFINITION

directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION

directive @secret(field: String!, pred: String) on OBJECT | INTERFACE

directive @withSubscription on OBJECT | INTERFACE | FIELD_DEFINITION

input AddAppInput {
  ownerId: String!
  pages: [PageRef]
  name: String!
}

type AddAppPayload {
  app(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  numUids: Int
}

input AddAtomInput {
  type: String!
  label: String
  library: LibraryRef
}

type AddAtomPayload {
  atom(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  numUids: Int
}

input AddComponentInput {
  library: LibraryRef!
  atom: AtomRef!
  label: String!
  children: [ComponentRef]
  tags: [TagRef]
}

type AddComponentPayload {
  component(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  numUids: Int
}

input AddLibraryInput {
  ownerId: String!
  name: String!
  atoms: [AtomRef]
  components: [ComponentRef]
}

type AddLibraryPayload {
  library(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  numUids: Int
}

input AddPageElementInput {
  name: String!
  page: PageRef!
  parent: PageElementRef
  children: [PageElementRef]
  atom: AtomRef
  component: ComponentRef
}

type AddPageElementPayload {
  pageElement(
    filter: PageElementFilter
    order: PageElementOrder
    first: Int
    offset: Int
  ): [PageElement]
  numUids: Int
}

input AddPageInput {
  name: String!
  app: AppRef!
  rootElement: PageElementRef!
}

type AddPagePayload {
  page(filter: PageFilter, order: PageOrder, first: Int, offset: Int): [Page]
  numUids: Int
}

input AddPropInput {
  description: String
  type: ValueTypeRef!
  props: [PropRef]
}

type AddPropPayload {
  prop(filter: PropFilter, order: PropOrder, first: Int, offset: Int): [Prop]
  numUids: Int
}

input AddTagInput {
  label: String!
}

type AddTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  numUids: Int
}

input AddValueTypeInput {
  label: String!
  type: String!
}

type AddValueTypePayload {
  valueType(
    filter: ValueTypeFilter
    order: ValueTypeOrder
    first: Int
    offset: Int
  ): [ValueType]
  numUids: Int
}

type App {
  id: ID!
  ownerId: String!
  pages(filter: PageFilter, order: PageOrder, first: Int, offset: Int): [Page]
  name: String!
  pagesAggregate(filter: PageFilter): PageAggregateResult
}

type AppAggregateResult {
  count: Int
  ownerIdMin: String
  ownerIdMax: String
  nameMin: String
  nameMax: String
}

input AppFilter {
  id: [ID!]
  ownerId: StringHashFilter
  has: [AppHasFilter]
  and: [AppFilter]
  or: [AppFilter]
  not: AppFilter
}

enum AppHasFilter {
  ownerId
  pages
  name
}

input AppOrder {
  asc: AppOrderable
  desc: AppOrderable
  then: AppOrder
}

enum AppOrderable {
  ownerId
  name
}

input AppPatch {
  ownerId: String
  pages: [PageRef]
  name: String
}

input AppRef {
  id: ID
  ownerId: String
  pages: [PageRef]
  name: String
}

type Atom {
  id: ID!
  type: String!
  label: String
  library(filter: LibraryFilter): Library
}

type AtomAggregateResult {
  count: Int
  typeMin: String
  typeMax: String
  labelMin: String
  labelMax: String
}

input AtomFilter {
  id: [ID!]
  has: [AtomHasFilter]
  and: [AtomFilter]
  or: [AtomFilter]
  not: AtomFilter
}

enum AtomHasFilter {
  type
  label
  library
}

input AtomOrder {
  asc: AtomOrderable
  desc: AtomOrderable
  then: AtomOrder
}

enum AtomOrderable {
  type
  label
}

input AtomPatch {
  type: String
  label: String
  library: LibraryRef
}

input AtomRef {
  id: ID
  type: String
  label: String
  library: LibraryRef
}

input AuthRule {
  and: [AuthRule]
  or: [AuthRule]
  not: AuthRule
  rule: String
}

type Component {
  id: ID!
  library(filter: LibraryFilter): Library!
  atom(filter: AtomFilter): Atom!
  label: String!
  children(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  tags(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  childrenAggregate(filter: ComponentFilter): ComponentAggregateResult
  tagsAggregate(filter: TagFilter): TagAggregateResult
}

type ComponentAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
}

input ComponentFilter {
  id: [ID!]
  has: [ComponentHasFilter]
  and: [ComponentFilter]
  or: [ComponentFilter]
  not: ComponentFilter
}

enum ComponentHasFilter {
  library
  atom
  label
  children
  tags
}

input ComponentOrder {
  asc: ComponentOrderable
  desc: ComponentOrderable
  then: ComponentOrder
}

enum ComponentOrderable {
  label
}

input ComponentPatch {
  library: LibraryRef
  atom: AtomRef
  label: String
  children: [ComponentRef]
  tags: [TagRef]
}

input ComponentRef {
  id: ID
  library: LibraryRef
  atom: AtomRef
  label: String
  children: [ComponentRef]
  tags: [TagRef]
}

input ContainsFilter {
  point: PointRef
  polygon: PolygonRef
}

input CustomHTTP {
  url: String!
  method: HTTPMethod!
  body: String
  graphql: String
  mode: Mode
  forwardHeaders: [String!]
  secretHeaders: [String!]
  introspectionHeaders: [String!]
  skipIntrospection: Boolean
}

"""
The DateTime scalar type represents date and time as a string in RFC3339 format.
For example: "1985-04-12T23:20:50.52Z" represents 20 minutes and 50.52 seconds after the 23rd hour of April 12th, 1985 in UTC.
"""
scalar DateTime

input DateTimeFilter {
  eq: DateTime
  in: [DateTime]
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
  between: DateTimeRange
}

input DateTimeRange {
  min: DateTime!
  max: DateTime!
}

type DeleteAppPayload {
  app(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  msg: String
  numUids: Int
}

type DeleteAtomPayload {
  atom(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  msg: String
  numUids: Int
}

type DeleteComponentPayload {
  component(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  msg: String
  numUids: Int
}

type DeleteLibraryPayload {
  library(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  msg: String
  numUids: Int
}

type DeletePageElementPayload {
  pageElement(
    filter: PageElementFilter
    order: PageElementOrder
    first: Int
    offset: Int
  ): [PageElement]
  msg: String
  numUids: Int
}

type DeletePagePayload {
  page(filter: PageFilter, order: PageOrder, first: Int, offset: Int): [Page]
  msg: String
  numUids: Int
}

type DeletePropPayload {
  prop(filter: PropFilter, order: PropOrder, first: Int, offset: Int): [Prop]
  msg: String
  numUids: Int
}

type DeleteTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  msg: String
  numUids: Int
}

type DeleteValueTypePayload {
  valueType(
    filter: ValueTypeFilter
    order: ValueTypeOrder
    first: Int
    offset: Int
  ): [ValueType]
  msg: String
  numUids: Int
}

enum DgraphIndex {
  int
  int64
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
  geo
}

input FloatFilter {
  eq: Float
  in: [Float]
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: FloatRange
}

input FloatRange {
  min: Float!
  max: Float!
}

input GenerateMutationParams {
  add: Boolean
  update: Boolean
  delete: Boolean
}

input GenerateQueryParams {
  get: Boolean
  query: Boolean
  password: Boolean
  aggregate: Boolean
}

enum HTTPMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

"""
The Int64 scalar type represents a signed 64‐bit numeric non‐fractional value.
Int64 can represent values in range [-(2^63),(2^63 - 1)].
"""
scalar Int64

input Int64Filter {
  eq: Int64
  in: [Int64]
  le: Int64
  lt: Int64
  ge: Int64
  gt: Int64
  between: Int64Range
}

input Int64Range {
  min: Int64!
  max: Int64!
}

input IntFilter {
  eq: Int
  in: [Int]
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: IntRange
}

input IntRange {
  min: Int!
  max: Int!
}

input IntersectsFilter {
  polygon: PolygonRef
  multiPolygon: MultiPolygonRef
}

type Library {
  id: ID!
  ownerId: String!
  name: String!
  atoms(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  components(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  atomsAggregate(filter: AtomFilter): AtomAggregateResult
  componentsAggregate(filter: ComponentFilter): ComponentAggregateResult
}

type LibraryAggregateResult {
  count: Int
  ownerIdMin: String
  ownerIdMax: String
  nameMin: String
  nameMax: String
}

input LibraryFilter {
  id: [ID!]
  has: [LibraryHasFilter]
  and: [LibraryFilter]
  or: [LibraryFilter]
  not: LibraryFilter
}

enum LibraryHasFilter {
  ownerId
  name
  atoms
  components
}

input LibraryOrder {
  asc: LibraryOrderable
  desc: LibraryOrderable
  then: LibraryOrder
}

enum LibraryOrderable {
  ownerId
  name
}

input LibraryPatch {
  ownerId: String
  name: String
  atoms: [AtomRef]
  components: [ComponentRef]
}

input LibraryRef {
  id: ID
  ownerId: String
  name: String
  atoms: [AtomRef]
  components: [ComponentRef]
}

enum Mode {
  BATCH
  SINGLE
}

type MultiPolygon {
  polygons: [Polygon!]!
}

input MultiPolygonRef {
  polygons: [PolygonRef!]!
}

type Mutation {
  addApp(input: [AddAppInput!]!): AddAppPayload
  updateApp(input: UpdateAppInput!): UpdateAppPayload
  deleteApp(filter: AppFilter!): DeleteAppPayload
  addPage(input: [AddPageInput!]!): AddPagePayload
  updatePage(input: UpdatePageInput!): UpdatePagePayload
  deletePage(filter: PageFilter!): DeletePagePayload
  addPageElement(input: [AddPageElementInput!]!): AddPageElementPayload
  updatePageElement(input: UpdatePageElementInput!): UpdatePageElementPayload
  deletePageElement(filter: PageElementFilter!): DeletePageElementPayload
  addLibrary(input: [AddLibraryInput!]!): AddLibraryPayload
  updateLibrary(input: UpdateLibraryInput!): UpdateLibraryPayload
  deleteLibrary(filter: LibraryFilter!): DeleteLibraryPayload
  addComponent(input: [AddComponentInput!]!): AddComponentPayload
  updateComponent(input: UpdateComponentInput!): UpdateComponentPayload
  deleteComponent(filter: ComponentFilter!): DeleteComponentPayload
  addAtom(input: [AddAtomInput!]!): AddAtomPayload
  updateAtom(input: UpdateAtomInput!): UpdateAtomPayload
  deleteAtom(filter: AtomFilter!): DeleteAtomPayload
  addTag(input: [AddTagInput!]!): AddTagPayload
  updateTag(input: UpdateTagInput!): UpdateTagPayload
  deleteTag(filter: TagFilter!): DeleteTagPayload
  addProp(input: [AddPropInput!]!): AddPropPayload
  updateProp(input: UpdatePropInput!): UpdatePropPayload
  deleteProp(filter: PropFilter!): DeletePropPayload
  addValueType(input: [AddValueTypeInput!]!): AddValueTypePayload
  updateValueType(input: UpdateValueTypeInput!): UpdateValueTypePayload
  deleteValueType(filter: ValueTypeFilter!): DeleteValueTypePayload
}

input NearFilter {
  distance: Float!
  coordinate: PointRef!
}

type Page {
  id: ID!
  name: String!
  app(filter: AppFilter): App!
  rootElement(filter: PageElementFilter): PageElement!
}

type PageAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

type PageElement {
  id: ID!
  name: String!
  page(filter: PageFilter): Page!
  parent(filter: PageElementFilter): PageElement
  children(
    filter: PageElementFilter
    order: PageElementOrder
    first: Int
    offset: Int
  ): [PageElement]
  atom(filter: AtomFilter): Atom
  component(filter: ComponentFilter): Component
  childrenAggregate(filter: PageElementFilter): PageElementAggregateResult
}

type PageElementAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input PageElementFilter {
  id: [ID!]
  name: StringFullTextFilter_StringTermFilter
  has: [PageElementHasFilter]
  and: [PageElementFilter]
  or: [PageElementFilter]
  not: PageElementFilter
}

enum PageElementHasFilter {
  name
  page
  parent
  children
  atom
  component
}

input PageElementOrder {
  asc: PageElementOrderable
  desc: PageElementOrderable
  then: PageElementOrder
}

enum PageElementOrderable {
  name
}

input PageElementPatch {
  name: String
  page: PageRef
  parent: PageElementRef
  children: [PageElementRef]
  atom: AtomRef
  component: ComponentRef
}

input PageElementRef {
  id: ID
  name: String
  page: PageRef
  parent: PageElementRef
  children: [PageElementRef]
  atom: AtomRef
  component: ComponentRef
}

input PageFilter {
  id: [ID!]
  name: StringFullTextFilter_StringTermFilter
  has: [PageHasFilter]
  and: [PageFilter]
  or: [PageFilter]
  not: PageFilter
}

enum PageHasFilter {
  name
  app
  rootElement
}

input PageOrder {
  asc: PageOrderable
  desc: PageOrderable
  then: PageOrder
}

enum PageOrderable {
  name
}

input PagePatch {
  name: String
  app: AppRef
  rootElement: PageElementRef
}

input PageRef {
  id: ID
  name: String
  app: AppRef
  rootElement: PageElementRef
}

type Point {
  longitude: Float!
  latitude: Float!
}

input PointGeoFilter {
  near: NearFilter
  within: WithinFilter
}

type PointList {
  points: [Point!]!
}

input PointListRef {
  points: [PointRef!]!
}

input PointRef {
  longitude: Float!
  latitude: Float!
}

type Polygon {
  coordinates: [PointList!]!
}

input PolygonGeoFilter {
  near: NearFilter
  within: WithinFilter
  contains: ContainsFilter
  intersects: IntersectsFilter
}

input PolygonRef {
  coordinates: [PointListRef!]!
}

type Prop {
  id: ID!
  description: String
  type(filter: ValueTypeFilter): ValueType!
  props(filter: PropFilter, order: PropOrder, first: Int, offset: Int): [Prop]
  propsAggregate(filter: PropFilter): PropAggregateResult
}

type PropAggregateResult {
  count: Int
  descriptionMin: String
  descriptionMax: String
}

input PropFilter {
  id: [ID!]
  has: [PropHasFilter]
  and: [PropFilter]
  or: [PropFilter]
  not: PropFilter
}

enum PropHasFilter {
  description
  type
  props
}

input PropOrder {
  asc: PropOrderable
  desc: PropOrderable
  then: PropOrder
}

enum PropOrderable {
  description
}

input PropPatch {
  description: String
  type: ValueTypeRef
  props: [PropRef]
}

input PropRef {
  id: ID
  description: String
  type: ValueTypeRef
  props: [PropRef]
}

type Query {
  getApp(id: ID!): App
  queryApp(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  aggregateApp(filter: AppFilter): AppAggregateResult
  getPage(id: ID!): Page
  queryPage(
    filter: PageFilter
    order: PageOrder
    first: Int
    offset: Int
  ): [Page]
  aggregatePage(filter: PageFilter): PageAggregateResult
  getPageElement(id: ID!): PageElement
  queryPageElement(
    filter: PageElementFilter
    order: PageElementOrder
    first: Int
    offset: Int
  ): [PageElement]
  aggregatePageElement(filter: PageElementFilter): PageElementAggregateResult
  getLibrary(id: ID!): Library
  queryLibrary(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  aggregateLibrary(filter: LibraryFilter): LibraryAggregateResult
  getComponent(id: ID!): Component
  queryComponent(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  aggregateComponent(filter: ComponentFilter): ComponentAggregateResult
  getAtom(id: ID!): Atom
  queryAtom(
    filter: AtomFilter
    order: AtomOrder
    first: Int
    offset: Int
  ): [Atom]
  aggregateAtom(filter: AtomFilter): AtomAggregateResult
  queryTag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  aggregateTag(filter: TagFilter): TagAggregateResult
  getProp(id: ID!): Prop
  queryProp(
    filter: PropFilter
    order: PropOrder
    first: Int
    offset: Int
  ): [Prop]
  aggregateProp(filter: PropFilter): PropAggregateResult
  getValueType(id: ID!): ValueType
  queryValueType(
    filter: ValueTypeFilter
    order: ValueTypeOrder
    first: Int
    offset: Int
  ): [ValueType]
  aggregateValueType(filter: ValueTypeFilter): ValueTypeAggregateResult
}

input StringExactFilter {
  eq: String
  in: [String]
  le: String
  lt: String
  ge: String
  gt: String
  between: StringRange
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringFullTextFilter_StringTermFilter {
  alloftext: String
  anyoftext: String
  allofterms: String
  anyofterms: String
}

input StringHashFilter {
  eq: String
  in: [String]
}

input StringRange {
  min: String!
  max: String!
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

type Tag {
  label: String!
}

type TagAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
}

input TagFilter {
  has: [TagHasFilter]
  and: [TagFilter]
  or: [TagFilter]
  not: TagFilter
}

enum TagHasFilter {
  label
}

input TagOrder {
  asc: TagOrderable
  desc: TagOrderable
  then: TagOrder
}

enum TagOrderable {
  label
}

input TagPatch {
  label: String
}

input TagRef {
  label: String
}

input UpdateAppInput {
  filter: AppFilter!
  set: AppPatch
  remove: AppPatch
}

type UpdateAppPayload {
  app(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  numUids: Int
}

input UpdateAtomInput {
  filter: AtomFilter!
  set: AtomPatch
  remove: AtomPatch
}

type UpdateAtomPayload {
  atom(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  numUids: Int
}

input UpdateComponentInput {
  filter: ComponentFilter!
  set: ComponentPatch
  remove: ComponentPatch
}

type UpdateComponentPayload {
  component(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  numUids: Int
}

input UpdateLibraryInput {
  filter: LibraryFilter!
  set: LibraryPatch
  remove: LibraryPatch
}

type UpdateLibraryPayload {
  library(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  numUids: Int
}

input UpdatePageElementInput {
  filter: PageElementFilter!
  set: PageElementPatch
  remove: PageElementPatch
}

type UpdatePageElementPayload {
  pageElement(
    filter: PageElementFilter
    order: PageElementOrder
    first: Int
    offset: Int
  ): [PageElement]
  numUids: Int
}

input UpdatePageInput {
  filter: PageFilter!
  set: PagePatch
  remove: PagePatch
}

type UpdatePagePayload {
  page(filter: PageFilter, order: PageOrder, first: Int, offset: Int): [Page]
  numUids: Int
}

input UpdatePropInput {
  filter: PropFilter!
  set: PropPatch
  remove: PropPatch
}

type UpdatePropPayload {
  prop(filter: PropFilter, order: PropOrder, first: Int, offset: Int): [Prop]
  numUids: Int
}

input UpdateTagInput {
  filter: TagFilter!
  set: TagPatch
  remove: TagPatch
}

type UpdateTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  numUids: Int
}

input UpdateValueTypeInput {
  filter: ValueTypeFilter!
  set: ValueTypePatch
  remove: ValueTypePatch
}

type UpdateValueTypePayload {
  valueType(
    filter: ValueTypeFilter
    order: ValueTypeOrder
    first: Int
    offset: Int
  ): [ValueType]
  numUids: Int
}

type ValueType {
  id: ID!
  label: String!
  type: String!
}

type ValueTypeAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
  typeMin: String
  typeMax: String
}

input ValueTypeFilter {
  id: [ID!]
  has: [ValueTypeHasFilter]
  and: [ValueTypeFilter]
  or: [ValueTypeFilter]
  not: ValueTypeFilter
}

enum ValueTypeHasFilter {
  label
  type
}

input ValueTypeOrder {
  asc: ValueTypeOrderable
  desc: ValueTypeOrderable
  then: ValueTypeOrder
}

enum ValueTypeOrderable {
  label
  type
}

input ValueTypePatch {
  label: String
  type: String
}

input ValueTypeRef {
  id: ID
  label: String
  type: String
}

input WithinFilter {
  polygon: PolygonRef!
}
