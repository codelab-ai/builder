schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

"""
columns and relationships of "app"
"""
type app {
  id: uuid!
  name: String!

  """
  An object relationship
  """
  owner: user!

  """
  An array relationship
  """
  pages(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): [page!]!

  """
  An aggregate relationship
  """
  pages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): page_aggregate!
  user_id: String!
}

"""
aggregated selection of "app"
"""
type app_aggregate {
  aggregate: app_aggregate_fields
  nodes: [app!]!
}

"""
aggregate fields of "app"
"""
type app_aggregate_fields {
  count(columns: [app_select_column!], distinct: Boolean): Int!
  max: app_max_fields
  min: app_min_fields
}

"""
Boolean expression to filter rows from the table "app". All fields are combined with a logical 'AND'.
"""
input app_bool_exp {
  _and: [app_bool_exp!]
  _not: app_bool_exp
  _or: [app_bool_exp!]
  id: uuid_comparison_exp
  name: String_comparison_exp
  owner: user_bool_exp
  pages: page_bool_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "app"
"""
enum app_constraint {
  """
  unique or primary key constraint
  """
  apps_pkey
}

"""
input type for inserting data into table "app"
"""
input app_insert_input {
  id: uuid
  name: String
  owner: user_obj_rel_insert_input
  pages: page_arr_rel_insert_input
  user_id: String
}

"""
aggregate max on columns
"""
type app_max_fields {
  id: uuid
  name: String
  user_id: String
}

"""
aggregate min on columns
"""
type app_min_fields {
  id: uuid
  name: String
  user_id: String
}

"""
response of any mutation on the table "app"
"""
type app_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [app!]!
}

"""
input type for inserting object relation for remote table "app"
"""
input app_obj_rel_insert_input {
  data: app_insert_input!

  """
  on conflict condition
  """
  on_conflict: app_on_conflict
}

"""
on conflict condition type for table "app"
"""
input app_on_conflict {
  constraint: app_constraint!
  update_columns: [app_update_column!]!
  where: app_bool_exp
}

"""
Ordering options when selecting data from "app".
"""
input app_order_by {
  id: order_by
  name: order_by
  owner: user_order_by
  pages_aggregate: page_aggregate_order_by
  user_id: order_by
}

"""
primary key columns input for table: app
"""
input app_pk_columns_input {
  id: uuid!
}

"""
select columns of table "app"
"""
enum app_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  user_id
}

"""
input type for updating data in table "app"
"""
input app_set_input {
  id: uuid
  name: String
  user_id: String
}

"""
update columns of table "app"
"""
enum app_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  user_id
}

"""
columns and relationships of "atom"
"""
type atom {
  component_id: uuid!
  id: uuid!
  type: atom_types_enum!
}

"""
aggregated selection of "atom"
"""
type atom_aggregate {
  aggregate: atom_aggregate_fields
  nodes: [atom!]!
}

"""
aggregate fields of "atom"
"""
type atom_aggregate_fields {
  count(columns: [atom_select_column!], distinct: Boolean): Int!
  max: atom_max_fields
  min: atom_min_fields
}

"""
Boolean expression to filter rows from the table "atom". All fields are combined with a logical 'AND'.
"""
input atom_bool_exp {
  _and: [atom_bool_exp!]
  _not: atom_bool_exp
  _or: [atom_bool_exp!]
  component_id: uuid_comparison_exp
  id: uuid_comparison_exp
  type: atom_types_enum_comparison_exp
}

"""
unique or primary key constraints on table "atom"
"""
enum atom_constraint {
  """
  unique or primary key constraint
  """
  vertices_pkey
}

"""
input type for inserting data into table "atom"
"""
input atom_insert_input {
  component_id: uuid
  id: uuid
  type: atom_types_enum
}

"""
aggregate max on columns
"""
type atom_max_fields {
  component_id: uuid
  id: uuid
}

"""
aggregate min on columns
"""
type atom_min_fields {
  component_id: uuid
  id: uuid
}

"""
response of any mutation on the table "atom"
"""
type atom_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [atom!]!
}

"""
on conflict condition type for table "atom"
"""
input atom_on_conflict {
  constraint: atom_constraint!
  update_columns: [atom_update_column!]!
  where: atom_bool_exp
}

"""
Ordering options when selecting data from "atom".
"""
input atom_order_by {
  component_id: order_by
  id: order_by
  type: order_by
}

"""
primary key columns input for table: atom
"""
input atom_pk_columns_input {
  id: uuid!
}

"""
select columns of table "atom"
"""
enum atom_select_column {
  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  type
}

"""
input type for updating data in table "atom"
"""
input atom_set_input {
  component_id: uuid
  id: uuid
  type: atom_types_enum
}

"""
columns and relationships of "atom_types"
"""
type atom_types {
  description: String
  value: String!
}

"""
aggregated selection of "atom_types"
"""
type atom_types_aggregate {
  aggregate: atom_types_aggregate_fields
  nodes: [atom_types!]!
}

"""
aggregate fields of "atom_types"
"""
type atom_types_aggregate_fields {
  count(columns: [atom_types_select_column!], distinct: Boolean): Int!
  max: atom_types_max_fields
  min: atom_types_min_fields
}

"""
Boolean expression to filter rows from the table "atom_types". All fields are combined with a logical 'AND'.
"""
input atom_types_bool_exp {
  _and: [atom_types_bool_exp!]
  _not: atom_types_bool_exp
  _or: [atom_types_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "atom_types"
"""
enum atom_types_constraint {
  """
  unique or primary key constraint
  """
  vertexType_pkey
}

enum atom_types_enum {
  React_Affix
  React_Alert
  React_Anchor
  React_Anchor_Link
  React_AutoComplete
  React_Avatar
  React_BackTop
  React_Badge
  React_Breadcrumb
  React_Breadcrumb_Item
  React_Button
  React_Calendar
  React_Card
  React_Card_Grid
  React_Card_Meta
  React_Carousel
  React_Cascader
  React_Checkbox
  React_Collapse
  React_Collapse_Panel
  React_Comment
  React_ConfigProvider
  React_DatePicker
  React_Descriptions
  React_Descriptions_Item
  React_Divider
  React_Drawer
  React_Dropdown
  React_Empty
  React_Form
  React_Form_Item
  React_Form_ItemHook
  React_Form_List
  React_Fragment
  React_Grid_Col
  React_Grid_Row
  React_Html_A
  React_Html_Div
  React_Html_P
  React_Html_Span
  React_Icon
  React_Input
  React_InputNumber
  React_Layout
  React_Layout_Content
  React_Layout_Footer
  React_Layout_Header
  React_Layout_Sider
  React_List
  React_List_Item
  React_List_Item_Meta
  React_Mapper
  React_Mentions
  React_Mentions_Option
  React_Menu
  React_Menu_Item
  React_Menu_ItemGroup
  React_Menu_SubMenu
  React_Modal
  React_PageHeader
  React_Page_Container
  React_Pagination
  React_Popconfirm
  React_Popover
  React_Progress
  React_Provider
  React_RGL_Container
  React_RGL_Item
  React_RGL_ResponsiveContainer
  React_Radio
  React_Radio_Group
  React_Rate
  React_RenderComponent
  React_RenderContainer
  React_Result
  React_Select
  React_Select_Option
  React_Skeleton
  React_Slider
  React_Space
  React_Spin
  React_Statistic
  React_Steps
  React_Steps_Step
  React_Switch
  React_Table
  React_Tabs
  React_Tabs_TabPane
  React_Tag
  React_Text
  React_TimePicker
  React_Timeline
  React_Timeline_Item
  React_Tooltip
  React_Transfer
  React_Tree
  React_TreeNode
  React_TreeSelect
  React_Typography
  React_Typography_Paragraph
  React_Typography_Text
  React_Typography_Title
  React_Upload
}

"""
Boolean expression to compare columns of type "atom_types_enum". All fields are combined with logical 'AND'.
"""
input atom_types_enum_comparison_exp {
  _eq: atom_types_enum
  _in: [atom_types_enum!]
  _is_null: Boolean
  _neq: atom_types_enum
  _nin: [atom_types_enum!]
}

"""
input type for inserting data into table "atom_types"
"""
input atom_types_insert_input {
  description: String
  value: String
}

"""
aggregate max on columns
"""
type atom_types_max_fields {
  description: String
  value: String
}

"""
aggregate min on columns
"""
type atom_types_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "atom_types"
"""
type atom_types_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [atom_types!]!
}

"""
on conflict condition type for table "atom_types"
"""
input atom_types_on_conflict {
  constraint: atom_types_constraint!
  update_columns: [atom_types_update_column!]!
  where: atom_types_bool_exp
}

"""
Ordering options when selecting data from "atom_types".
"""
input atom_types_order_by {
  description: order_by
  value: order_by
}

"""
primary key columns input for table: atom_types
"""
input atom_types_pk_columns_input {
  value: String!
}

"""
select columns of table "atom_types"
"""
enum atom_types_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

"""
input type for updating data in table "atom_types"
"""
input atom_types_set_input {
  description: String
  value: String
}

"""
update columns of table "atom_types"
"""
enum atom_types_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

"""
update columns of table "atom"
"""
enum atom_update_column {
  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  type
}

"""
columns and relationships of "attribute"
"""
type attribute {
  id: uuid!
  key: String!
  type: atom_types_enum!
}

"""
aggregated selection of "attribute"
"""
type attribute_aggregate {
  aggregate: attribute_aggregate_fields
  nodes: [attribute!]!
}

"""
aggregate fields of "attribute"
"""
type attribute_aggregate_fields {
  count(columns: [attribute_select_column!], distinct: Boolean): Int!
  max: attribute_max_fields
  min: attribute_min_fields
}

"""
Boolean expression to filter rows from the table "attribute". All fields are combined with a logical 'AND'.
"""
input attribute_bool_exp {
  _and: [attribute_bool_exp!]
  _not: attribute_bool_exp
  _or: [attribute_bool_exp!]
  id: uuid_comparison_exp
  key: String_comparison_exp
  type: atom_types_enum_comparison_exp
}

"""
unique or primary key constraints on table "attribute"
"""
enum attribute_constraint {
  """
  unique or primary key constraint
  """
  attributes_pkey
}

"""
input type for inserting data into table "attribute"
"""
input attribute_insert_input {
  id: uuid
  key: String
  type: atom_types_enum
}

"""
aggregate max on columns
"""
type attribute_max_fields {
  id: uuid
  key: String
}

"""
aggregate min on columns
"""
type attribute_min_fields {
  id: uuid
  key: String
}

"""
response of any mutation on the table "attribute"
"""
type attribute_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [attribute!]!
}

"""
on conflict condition type for table "attribute"
"""
input attribute_on_conflict {
  constraint: attribute_constraint!
  update_columns: [attribute_update_column!]!
  where: attribute_bool_exp
}

"""
Ordering options when selecting data from "attribute".
"""
input attribute_order_by {
  id: order_by
  key: order_by
  type: order_by
}

"""
primary key columns input for table: attribute
"""
input attribute_pk_columns_input {
  id: uuid!
}

"""
select columns of table "attribute"
"""
enum attribute_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  key

  """
  column name
  """
  type
}

"""
input type for updating data in table "attribute"
"""
input attribute_set_input {
  id: uuid
  key: String
  type: atom_types_enum
}

"""
update columns of table "attribute"
"""
enum attribute_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  key

  """
  column name
  """
  type
}

"""
columns and relationships of "category"
"""
type category {
  id: uuid!
}

"""
aggregated selection of "category"
"""
type category_aggregate {
  aggregate: category_aggregate_fields
  nodes: [category!]!
}

"""
aggregate fields of "category"
"""
type category_aggregate_fields {
  count(columns: [category_select_column!], distinct: Boolean): Int!
  max: category_max_fields
  min: category_min_fields
}

"""
Boolean expression to filter rows from the table "category". All fields are combined with a logical 'AND'.
"""
input category_bool_exp {
  _and: [category_bool_exp!]
  _not: category_bool_exp
  _or: [category_bool_exp!]
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "category"
"""
enum category_constraint {
  """
  unique or primary key constraint
  """
  categories_pkey
}

"""
input type for inserting data into table "category"
"""
input category_insert_input {
  id: uuid
}

"""
aggregate max on columns
"""
type category_max_fields {
  id: uuid
}

"""
aggregate min on columns
"""
type category_min_fields {
  id: uuid
}

"""
response of any mutation on the table "category"
"""
type category_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [category!]!
}

"""
on conflict condition type for table "category"
"""
input category_on_conflict {
  constraint: category_constraint!
  update_columns: [category_update_column!]!
  where: category_bool_exp
}

"""
Ordering options when selecting data from "category".
"""
input category_order_by {
  id: order_by
}

"""
primary key columns input for table: category
"""
input category_pk_columns_input {
  id: uuid!
}

"""
select columns of table "category"
"""
enum category_select_column {
  """
  column name
  """
  id
}

"""
input type for updating data in table "category"
"""
input category_set_input {
  id: uuid
}

"""
update columns of table "category"
"""
enum category_update_column {
  """
  column name
  """
  id
}

"""
columns and relationships of "component"
"""
type component {
  id: uuid!
  label: String!
  library_id: uuid!
}

"""
aggregated selection of "component"
"""
type component_aggregate {
  aggregate: component_aggregate_fields
  nodes: [component!]!
}

"""
aggregate fields of "component"
"""
type component_aggregate_fields {
  count(columns: [component_select_column!], distinct: Boolean): Int!
  max: component_max_fields
  min: component_min_fields
}

"""
Boolean expression to filter rows from the table "component". All fields are combined with a logical 'AND'.
"""
input component_bool_exp {
  _and: [component_bool_exp!]
  _not: component_bool_exp
  _or: [component_bool_exp!]
  id: uuid_comparison_exp
  label: String_comparison_exp
  library_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "component"
"""
enum component_constraint {
  """
  unique or primary key constraint
  """
  components_pkey
}

"""
columns and relationships of "component_element"
"""
type component_element {
  atom_id: uuid!
  component_id: uuid!
  id: uuid!
  label: String!
}

"""
aggregated selection of "component_element"
"""
type component_element_aggregate {
  aggregate: component_element_aggregate_fields
  nodes: [component_element!]!
}

"""
aggregate fields of "component_element"
"""
type component_element_aggregate_fields {
  count(columns: [component_element_select_column!], distinct: Boolean): Int!
  max: component_element_max_fields
  min: component_element_min_fields
}

"""
Boolean expression to filter rows from the table "component_element". All fields are combined with a logical 'AND'.
"""
input component_element_bool_exp {
  _and: [component_element_bool_exp!]
  _not: component_element_bool_exp
  _or: [component_element_bool_exp!]
  atom_id: uuid_comparison_exp
  component_id: uuid_comparison_exp
  id: uuid_comparison_exp
  label: String_comparison_exp
}

"""
unique or primary key constraints on table "component_element"
"""
enum component_element_constraint {
  """
  unique or primary key constraint
  """
  component_elements_pkey
}

"""
input type for inserting data into table "component_element"
"""
input component_element_insert_input {
  atom_id: uuid
  component_id: uuid
  id: uuid
  label: String
}

"""
aggregate max on columns
"""
type component_element_max_fields {
  atom_id: uuid
  component_id: uuid
  id: uuid
  label: String
}

"""
aggregate min on columns
"""
type component_element_min_fields {
  atom_id: uuid
  component_id: uuid
  id: uuid
  label: String
}

"""
response of any mutation on the table "component_element"
"""
type component_element_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [component_element!]!
}

"""
on conflict condition type for table "component_element"
"""
input component_element_on_conflict {
  constraint: component_element_constraint!
  update_columns: [component_element_update_column!]!
  where: component_element_bool_exp
}

"""
Ordering options when selecting data from "component_element".
"""
input component_element_order_by {
  atom_id: order_by
  component_id: order_by
  id: order_by
  label: order_by
}

"""
primary key columns input for table: component_element
"""
input component_element_pk_columns_input {
  id: uuid!
}

"""
select columns of table "component_element"
"""
enum component_element_select_column {
  """
  column name
  """
  atom_id

  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  label
}

"""
input type for updating data in table "component_element"
"""
input component_element_set_input {
  atom_id: uuid
  component_id: uuid
  id: uuid
  label: String
}

"""
update columns of table "component_element"
"""
enum component_element_update_column {
  """
  column name
  """
  atom_id

  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  label
}

"""
input type for inserting data into table "component"
"""
input component_insert_input {
  id: uuid
  label: String
  library_id: uuid
}

"""
columns and relationships of "component_link"
"""
type component_link {
  category_id: uuid
  component_id: uuid!
  id: uuid!
  order: Int
  props(
    """
    JSON select path
    """
    path: String
  ): jsonb
  source_element_id: uuid!
  target_element_id: uuid
}

"""
aggregated selection of "component_link"
"""
type component_link_aggregate {
  aggregate: component_link_aggregate_fields
  nodes: [component_link!]!
}

"""
aggregate fields of "component_link"
"""
type component_link_aggregate_fields {
  avg: component_link_avg_fields
  count(columns: [component_link_select_column!], distinct: Boolean): Int!
  max: component_link_max_fields
  min: component_link_min_fields
  stddev: component_link_stddev_fields
  stddev_pop: component_link_stddev_pop_fields
  stddev_samp: component_link_stddev_samp_fields
  sum: component_link_sum_fields
  var_pop: component_link_var_pop_fields
  var_samp: component_link_var_samp_fields
  variance: component_link_variance_fields
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input component_link_append_input {
  props: jsonb
}

"""
aggregate avg on columns
"""
type component_link_avg_fields {
  order: Float
}

"""
Boolean expression to filter rows from the table "component_link". All fields are combined with a logical 'AND'.
"""
input component_link_bool_exp {
  _and: [component_link_bool_exp!]
  _not: component_link_bool_exp
  _or: [component_link_bool_exp!]
  category_id: uuid_comparison_exp
  component_id: uuid_comparison_exp
  id: uuid_comparison_exp
  order: Int_comparison_exp
  props: jsonb_comparison_exp
  source_element_id: uuid_comparison_exp
  target_element_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "component_link"
"""
enum component_link_constraint {
  """
  unique or primary key constraint
  """
  vertex_edge_type_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input component_link_delete_at_path_input {
  props: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input component_link_delete_elem_input {
  props: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input component_link_delete_key_input {
  props: String
}

"""
input type for incrementing numeric columns in table "component_link"
"""
input component_link_inc_input {
  order: Int
}

"""
input type for inserting data into table "component_link"
"""
input component_link_insert_input {
  category_id: uuid
  component_id: uuid
  id: uuid
  order: Int
  props: jsonb
  source_element_id: uuid
  target_element_id: uuid
}

"""
aggregate max on columns
"""
type component_link_max_fields {
  category_id: uuid
  component_id: uuid
  id: uuid
  order: Int
  source_element_id: uuid
  target_element_id: uuid
}

"""
aggregate min on columns
"""
type component_link_min_fields {
  category_id: uuid
  component_id: uuid
  id: uuid
  order: Int
  source_element_id: uuid
  target_element_id: uuid
}

"""
response of any mutation on the table "component_link"
"""
type component_link_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [component_link!]!
}

"""
on conflict condition type for table "component_link"
"""
input component_link_on_conflict {
  constraint: component_link_constraint!
  update_columns: [component_link_update_column!]!
  where: component_link_bool_exp
}

"""
Ordering options when selecting data from "component_link".
"""
input component_link_order_by {
  category_id: order_by
  component_id: order_by
  id: order_by
  order: order_by
  props: order_by
  source_element_id: order_by
  target_element_id: order_by
}

"""
primary key columns input for table: component_link
"""
input component_link_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input component_link_prepend_input {
  props: jsonb
}

"""
select columns of table "component_link"
"""
enum component_link_select_column {
  """
  column name
  """
  category_id

  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  order

  """
  column name
  """
  props

  """
  column name
  """
  source_element_id

  """
  column name
  """
  target_element_id
}

"""
input type for updating data in table "component_link"
"""
input component_link_set_input {
  category_id: uuid
  component_id: uuid
  id: uuid
  order: Int
  props: jsonb
  source_element_id: uuid
  target_element_id: uuid
}

"""
aggregate stddev on columns
"""
type component_link_stddev_fields {
  order: Float
}

"""
aggregate stddev_pop on columns
"""
type component_link_stddev_pop_fields {
  order: Float
}

"""
aggregate stddev_samp on columns
"""
type component_link_stddev_samp_fields {
  order: Float
}

"""
aggregate sum on columns
"""
type component_link_sum_fields {
  order: Int
}

"""
update columns of table "component_link"
"""
enum component_link_update_column {
  """
  column name
  """
  category_id

  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  order

  """
  column name
  """
  props

  """
  column name
  """
  source_element_id

  """
  column name
  """
  target_element_id
}

"""
aggregate var_pop on columns
"""
type component_link_var_pop_fields {
  order: Float
}

"""
aggregate var_samp on columns
"""
type component_link_var_samp_fields {
  order: Float
}

"""
aggregate variance on columns
"""
type component_link_variance_fields {
  order: Float
}

"""
aggregate max on columns
"""
type component_max_fields {
  id: uuid
  label: String
  library_id: uuid
}

"""
aggregate min on columns
"""
type component_min_fields {
  id: uuid
  label: String
  library_id: uuid
}

"""
response of any mutation on the table "component"
"""
type component_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [component!]!
}

"""
on conflict condition type for table "component"
"""
input component_on_conflict {
  constraint: component_constraint!
  update_columns: [component_update_column!]!
  where: component_bool_exp
}

"""
Ordering options when selecting data from "component".
"""
input component_order_by {
  id: order_by
  label: order_by
  library_id: order_by
}

"""
primary key columns input for table: component
"""
input component_pk_columns_input {
  id: uuid!
}

"""
select columns of table "component"
"""
enum component_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  label

  """
  column name
  """
  library_id
}

"""
input type for updating data in table "component"
"""
input component_set_input {
  id: uuid
  label: String
  library_id: uuid
}

"""
update columns of table "component"
"""
enum component_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  label

  """
  column name
  """
  library_id
}

scalar jsonb

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  """
  is the column contained in the given json value
  """
  _contained_in: jsonb

  """
  does the column contain the given json value at the top level
  """
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """
  does the string exist as a top-level key in the column
  """
  _has_key: String

  """
  do all of these strings exist as top-level keys in the column
  """
  _has_keys_all: [String!]

  """
  do any of these strings exist as top-level keys in the column
  """
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "lambda"
"""
type lambda {
  body: String!
  id: uuid!
  libraryId: uuid!
  name: String!
}

"""
aggregated selection of "lambda"
"""
type lambda_aggregate {
  aggregate: lambda_aggregate_fields
  nodes: [lambda!]!
}

"""
aggregate fields of "lambda"
"""
type lambda_aggregate_fields {
  count(columns: [lambda_select_column!], distinct: Boolean): Int!
  max: lambda_max_fields
  min: lambda_min_fields
}

"""
Boolean expression to filter rows from the table "lambda". All fields are combined with a logical 'AND'.
"""
input lambda_bool_exp {
  _and: [lambda_bool_exp!]
  _not: lambda_bool_exp
  _or: [lambda_bool_exp!]
  body: String_comparison_exp
  id: uuid_comparison_exp
  libraryId: uuid_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "lambda"
"""
enum lambda_constraint {
  """
  unique or primary key constraint
  """
  lambdas_pkey
}

"""
input type for inserting data into table "lambda"
"""
input lambda_insert_input {
  body: String
  id: uuid
  libraryId: uuid
  name: String
}

"""
aggregate max on columns
"""
type lambda_max_fields {
  body: String
  id: uuid
  libraryId: uuid
  name: String
}

"""
aggregate min on columns
"""
type lambda_min_fields {
  body: String
  id: uuid
  libraryId: uuid
  name: String
}

"""
response of any mutation on the table "lambda"
"""
type lambda_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [lambda!]!
}

"""
on conflict condition type for table "lambda"
"""
input lambda_on_conflict {
  constraint: lambda_constraint!
  update_columns: [lambda_update_column!]!
  where: lambda_bool_exp
}

"""
Ordering options when selecting data from "lambda".
"""
input lambda_order_by {
  body: order_by
  id: order_by
  libraryId: order_by
  name: order_by
}

"""
primary key columns input for table: lambda
"""
input lambda_pk_columns_input {
  id: uuid!
}

"""
select columns of table "lambda"
"""
enum lambda_select_column {
  """
  column name
  """
  body

  """
  column name
  """
  id

  """
  column name
  """
  libraryId

  """
  column name
  """
  name
}

"""
input type for updating data in table "lambda"
"""
input lambda_set_input {
  body: String
  id: uuid
  libraryId: uuid
  name: String
}

"""
update columns of table "lambda"
"""
enum lambda_update_column {
  """
  column name
  """
  body

  """
  column name
  """
  id

  """
  column name
  """
  libraryId

  """
  column name
  """
  name
}

"""
columns and relationships of "library"
"""
type library {
  id: uuid!
  name: String
  user_id: String!
}

"""
aggregated selection of "library"
"""
type library_aggregate {
  aggregate: library_aggregate_fields
  nodes: [library!]!
}

"""
aggregate fields of "library"
"""
type library_aggregate_fields {
  count(columns: [library_select_column!], distinct: Boolean): Int!
  max: library_max_fields
  min: library_min_fields
}

"""
Boolean expression to filter rows from the table "library". All fields are combined with a logical 'AND'.
"""
input library_bool_exp {
  _and: [library_bool_exp!]
  _not: library_bool_exp
  _or: [library_bool_exp!]
  id: uuid_comparison_exp
  name: String_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "library"
"""
enum library_constraint {
  """
  unique or primary key constraint
  """
  libraries_pkey
}

"""
input type for inserting data into table "library"
"""
input library_insert_input {
  id: uuid
  name: String
  user_id: String
}

"""
aggregate max on columns
"""
type library_max_fields {
  id: uuid
  name: String
  user_id: String
}

"""
aggregate min on columns
"""
type library_min_fields {
  id: uuid
  name: String
  user_id: String
}

"""
response of any mutation on the table "library"
"""
type library_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [library!]!
}

"""
input type for inserting object relation for remote table "library"
"""
input library_obj_rel_insert_input {
  data: library_insert_input!

  """
  on conflict condition
  """
  on_conflict: library_on_conflict
}

"""
on conflict condition type for table "library"
"""
input library_on_conflict {
  constraint: library_constraint!
  update_columns: [library_update_column!]!
  where: library_bool_exp
}

"""
Ordering options when selecting data from "library".
"""
input library_order_by {
  id: order_by
  name: order_by
  user_id: order_by
}

"""
primary key columns input for table: library
"""
input library_pk_columns_input {
  id: uuid!
}

"""
select columns of table "library"
"""
enum library_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  user_id
}

"""
input type for updating data in table "library"
"""
input library_set_input {
  id: uuid
  name: String
  user_id: String
}

"""
update columns of table "library"
"""
enum library_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  user_id
}

"""
mutation root
"""
type mutation_root {
  """
  delete data from the table: "app"
  """
  delete_app(
    """
    filter the rows which have to be deleted
    """
    where: app_bool_exp!
  ): app_mutation_response

  """
  delete single row from the table: "app"
  """
  delete_app_by_pk(id: uuid!): app

  """
  delete data from the table: "atom"
  """
  delete_atom(
    """
    filter the rows which have to be deleted
    """
    where: atom_bool_exp!
  ): atom_mutation_response

  """
  delete single row from the table: "atom"
  """
  delete_atom_by_pk(id: uuid!): atom

  """
  delete data from the table: "atom_types"
  """
  delete_atom_types(
    """
    filter the rows which have to be deleted
    """
    where: atom_types_bool_exp!
  ): atom_types_mutation_response

  """
  delete single row from the table: "atom_types"
  """
  delete_atom_types_by_pk(value: String!): atom_types

  """
  delete data from the table: "attribute"
  """
  delete_attribute(
    """
    filter the rows which have to be deleted
    """
    where: attribute_bool_exp!
  ): attribute_mutation_response

  """
  delete single row from the table: "attribute"
  """
  delete_attribute_by_pk(id: uuid!): attribute

  """
  delete data from the table: "category"
  """
  delete_category(
    """
    filter the rows which have to be deleted
    """
    where: category_bool_exp!
  ): category_mutation_response

  """
  delete single row from the table: "category"
  """
  delete_category_by_pk(id: uuid!): category

  """
  delete data from the table: "component"
  """
  delete_component(
    """
    filter the rows which have to be deleted
    """
    where: component_bool_exp!
  ): component_mutation_response

  """
  delete single row from the table: "component"
  """
  delete_component_by_pk(id: uuid!): component

  """
  delete data from the table: "component_element"
  """
  delete_component_element(
    """
    filter the rows which have to be deleted
    """
    where: component_element_bool_exp!
  ): component_element_mutation_response

  """
  delete single row from the table: "component_element"
  """
  delete_component_element_by_pk(id: uuid!): component_element

  """
  delete data from the table: "component_link"
  """
  delete_component_link(
    """
    filter the rows which have to be deleted
    """
    where: component_link_bool_exp!
  ): component_link_mutation_response

  """
  delete single row from the table: "component_link"
  """
  delete_component_link_by_pk(id: uuid!): component_link

  """
  delete data from the table: "lambda"
  """
  delete_lambda(
    """
    filter the rows which have to be deleted
    """
    where: lambda_bool_exp!
  ): lambda_mutation_response

  """
  delete single row from the table: "lambda"
  """
  delete_lambda_by_pk(id: uuid!): lambda

  """
  delete data from the table: "library"
  """
  delete_library(
    """
    filter the rows which have to be deleted
    """
    where: library_bool_exp!
  ): library_mutation_response

  """
  delete single row from the table: "library"
  """
  delete_library_by_pk(id: uuid!): library

  """
  delete data from the table: "page"
  """
  delete_page(
    """
    filter the rows which have to be deleted
    """
    where: page_bool_exp!
  ): page_mutation_response

  """
  delete single row from the table: "page"
  """
  delete_page_by_pk(id: uuid!): page

  """
  delete data from the table: "page_element"
  """
  delete_page_element(
    """
    filter the rows which have to be deleted
    """
    where: page_element_bool_exp!
  ): page_element_mutation_response

  """
  delete single row from the table: "page_element"
  """
  delete_page_element_by_pk(id: uuid!): page_element

  """
  delete data from the table: "page_links"
  """
  delete_page_links(
    """
    filter the rows which have to be deleted
    """
    where: page_links_bool_exp!
  ): page_links_mutation_response

  """
  delete single row from the table: "page_links"
  """
  delete_page_links_by_pk(id: uuid!): page_links

  """
  delete data from the table: "prop"
  """
  delete_prop(
    """
    filter the rows which have to be deleted
    """
    where: prop_bool_exp!
  ): prop_mutation_response

  """
  delete single row from the table: "prop"
  """
  delete_prop_by_pk(id: uuid!): prop

  """
  delete data from the table: "prop_element"
  """
  delete_prop_element(
    """
    filter the rows which have to be deleted
    """
    where: prop_element_bool_exp!
  ): prop_element_mutation_response

  """
  delete single row from the table: "prop_element"
  """
  delete_prop_element_by_pk(element_id: uuid!, prop_id: uuid!): prop_element

  """
  delete data from the table: "prop_value_tag"
  """
  delete_prop_value_tag(
    """
    filter the rows which have to be deleted
    """
    where: prop_value_tag_bool_exp!
  ): prop_value_tag_mutation_response

  """
  delete single row from the table: "prop_value_tag"
  """
  delete_prop_value_tag_by_pk(
    prop_value_id: uuid!
    tag_id: uuid!
  ): prop_value_tag

  """
  delete data from the table: "prop_value_type"
  """
  delete_prop_value_type(
    """
    filter the rows which have to be deleted
    """
    where: prop_value_type_bool_exp!
  ): prop_value_type_mutation_response

  """
  delete single row from the table: "prop_value_type"
  """
  delete_prop_value_type_by_pk(value: String!): prop_value_type

  """
  delete data from the table: "prop_values"
  """
  delete_prop_values(
    """
    filter the rows which have to be deleted
    """
    where: prop_values_bool_exp!
  ): prop_values_mutation_response

  """
  delete single row from the table: "prop_values"
  """
  delete_prop_values_by_pk(id: uuid!): prop_values

  """
  delete data from the table: "style"
  """
  delete_style(
    """
    filter the rows which have to be deleted
    """
    where: style_bool_exp!
  ): style_mutation_response

  """
  delete single row from the table: "style"
  """
  delete_style_by_pk(id: uuid!): style

  """
  delete data from the table: "tag"
  """
  delete_tag(
    """
    filter the rows which have to be deleted
    """
    where: tag_bool_exp!
  ): tag_mutation_response

  """
  delete single row from the table: "tag"
  """
  delete_tag_by_pk(id: uuid!): tag

  """
  delete data from the table: "user"
  """
  delete_user(
    """
    filter the rows which have to be deleted
    """
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(id: String!): user

  """
  insert data into the table: "app"
  """
  insert_app(
    """
    the rows to be inserted
    """
    objects: [app_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: app_on_conflict
  ): app_mutation_response

  """
  insert a single row into the table: "app"
  """
  insert_app_one(
    """
    the row to be inserted
    """
    object: app_insert_input!

    """
    on conflict condition
    """
    on_conflict: app_on_conflict
  ): app

  """
  insert data into the table: "atom"
  """
  insert_atom(
    """
    the rows to be inserted
    """
    objects: [atom_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: atom_on_conflict
  ): atom_mutation_response

  """
  insert a single row into the table: "atom"
  """
  insert_atom_one(
    """
    the row to be inserted
    """
    object: atom_insert_input!

    """
    on conflict condition
    """
    on_conflict: atom_on_conflict
  ): atom

  """
  insert data into the table: "atom_types"
  """
  insert_atom_types(
    """
    the rows to be inserted
    """
    objects: [atom_types_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: atom_types_on_conflict
  ): atom_types_mutation_response

  """
  insert a single row into the table: "atom_types"
  """
  insert_atom_types_one(
    """
    the row to be inserted
    """
    object: atom_types_insert_input!

    """
    on conflict condition
    """
    on_conflict: atom_types_on_conflict
  ): atom_types

  """
  insert data into the table: "attribute"
  """
  insert_attribute(
    """
    the rows to be inserted
    """
    objects: [attribute_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: attribute_on_conflict
  ): attribute_mutation_response

  """
  insert a single row into the table: "attribute"
  """
  insert_attribute_one(
    """
    the row to be inserted
    """
    object: attribute_insert_input!

    """
    on conflict condition
    """
    on_conflict: attribute_on_conflict
  ): attribute

  """
  insert data into the table: "category"
  """
  insert_category(
    """
    the rows to be inserted
    """
    objects: [category_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: category_on_conflict
  ): category_mutation_response

  """
  insert a single row into the table: "category"
  """
  insert_category_one(
    """
    the row to be inserted
    """
    object: category_insert_input!

    """
    on conflict condition
    """
    on_conflict: category_on_conflict
  ): category

  """
  insert data into the table: "component"
  """
  insert_component(
    """
    the rows to be inserted
    """
    objects: [component_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: component_on_conflict
  ): component_mutation_response

  """
  insert data into the table: "component_element"
  """
  insert_component_element(
    """
    the rows to be inserted
    """
    objects: [component_element_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: component_element_on_conflict
  ): component_element_mutation_response

  """
  insert a single row into the table: "component_element"
  """
  insert_component_element_one(
    """
    the row to be inserted
    """
    object: component_element_insert_input!

    """
    on conflict condition
    """
    on_conflict: component_element_on_conflict
  ): component_element

  """
  insert data into the table: "component_link"
  """
  insert_component_link(
    """
    the rows to be inserted
    """
    objects: [component_link_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: component_link_on_conflict
  ): component_link_mutation_response

  """
  insert a single row into the table: "component_link"
  """
  insert_component_link_one(
    """
    the row to be inserted
    """
    object: component_link_insert_input!

    """
    on conflict condition
    """
    on_conflict: component_link_on_conflict
  ): component_link

  """
  insert a single row into the table: "component"
  """
  insert_component_one(
    """
    the row to be inserted
    """
    object: component_insert_input!

    """
    on conflict condition
    """
    on_conflict: component_on_conflict
  ): component

  """
  insert data into the table: "lambda"
  """
  insert_lambda(
    """
    the rows to be inserted
    """
    objects: [lambda_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: lambda_on_conflict
  ): lambda_mutation_response

  """
  insert a single row into the table: "lambda"
  """
  insert_lambda_one(
    """
    the row to be inserted
    """
    object: lambda_insert_input!

    """
    on conflict condition
    """
    on_conflict: lambda_on_conflict
  ): lambda

  """
  insert data into the table: "library"
  """
  insert_library(
    """
    the rows to be inserted
    """
    objects: [library_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: library_on_conflict
  ): library_mutation_response

  """
  insert a single row into the table: "library"
  """
  insert_library_one(
    """
    the row to be inserted
    """
    object: library_insert_input!

    """
    on conflict condition
    """
    on_conflict: library_on_conflict
  ): library

  """
  insert data into the table: "page"
  """
  insert_page(
    """
    the rows to be inserted
    """
    objects: [page_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: page_on_conflict
  ): page_mutation_response

  """
  insert data into the table: "page_element"
  """
  insert_page_element(
    """
    the rows to be inserted
    """
    objects: [page_element_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: page_element_on_conflict
  ): page_element_mutation_response

  """
  insert a single row into the table: "page_element"
  """
  insert_page_element_one(
    """
    the row to be inserted
    """
    object: page_element_insert_input!

    """
    on conflict condition
    """
    on_conflict: page_element_on_conflict
  ): page_element

  """
  insert data into the table: "page_links"
  """
  insert_page_links(
    """
    the rows to be inserted
    """
    objects: [page_links_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: page_links_on_conflict
  ): page_links_mutation_response

  """
  insert a single row into the table: "page_links"
  """
  insert_page_links_one(
    """
    the row to be inserted
    """
    object: page_links_insert_input!

    """
    on conflict condition
    """
    on_conflict: page_links_on_conflict
  ): page_links

  """
  insert a single row into the table: "page"
  """
  insert_page_one(
    """
    the row to be inserted
    """
    object: page_insert_input!

    """
    on conflict condition
    """
    on_conflict: page_on_conflict
  ): page

  """
  insert data into the table: "prop"
  """
  insert_prop(
    """
    the rows to be inserted
    """
    objects: [prop_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: prop_on_conflict
  ): prop_mutation_response

  """
  insert data into the table: "prop_element"
  """
  insert_prop_element(
    """
    the rows to be inserted
    """
    objects: [prop_element_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: prop_element_on_conflict
  ): prop_element_mutation_response

  """
  insert a single row into the table: "prop_element"
  """
  insert_prop_element_one(
    """
    the row to be inserted
    """
    object: prop_element_insert_input!

    """
    on conflict condition
    """
    on_conflict: prop_element_on_conflict
  ): prop_element

  """
  insert a single row into the table: "prop"
  """
  insert_prop_one(
    """
    the row to be inserted
    """
    object: prop_insert_input!

    """
    on conflict condition
    """
    on_conflict: prop_on_conflict
  ): prop

  """
  insert data into the table: "prop_value_tag"
  """
  insert_prop_value_tag(
    """
    the rows to be inserted
    """
    objects: [prop_value_tag_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: prop_value_tag_on_conflict
  ): prop_value_tag_mutation_response

  """
  insert a single row into the table: "prop_value_tag"
  """
  insert_prop_value_tag_one(
    """
    the row to be inserted
    """
    object: prop_value_tag_insert_input!

    """
    on conflict condition
    """
    on_conflict: prop_value_tag_on_conflict
  ): prop_value_tag

  """
  insert data into the table: "prop_value_type"
  """
  insert_prop_value_type(
    """
    the rows to be inserted
    """
    objects: [prop_value_type_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: prop_value_type_on_conflict
  ): prop_value_type_mutation_response

  """
  insert a single row into the table: "prop_value_type"
  """
  insert_prop_value_type_one(
    """
    the row to be inserted
    """
    object: prop_value_type_insert_input!

    """
    on conflict condition
    """
    on_conflict: prop_value_type_on_conflict
  ): prop_value_type

  """
  insert data into the table: "prop_values"
  """
  insert_prop_values(
    """
    the rows to be inserted
    """
    objects: [prop_values_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: prop_values_on_conflict
  ): prop_values_mutation_response

  """
  insert a single row into the table: "prop_values"
  """
  insert_prop_values_one(
    """
    the row to be inserted
    """
    object: prop_values_insert_input!

    """
    on conflict condition
    """
    on_conflict: prop_values_on_conflict
  ): prop_values

  """
  insert data into the table: "style"
  """
  insert_style(
    """
    the rows to be inserted
    """
    objects: [style_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: style_on_conflict
  ): style_mutation_response

  """
  insert a single row into the table: "style"
  """
  insert_style_one(
    """
    the row to be inserted
    """
    object: style_insert_input!

    """
    on conflict condition
    """
    on_conflict: style_on_conflict
  ): style

  """
  insert data into the table: "tag"
  """
  insert_tag(
    """
    the rows to be inserted
    """
    objects: [tag_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: tag_on_conflict
  ): tag_mutation_response

  """
  insert a single row into the table: "tag"
  """
  insert_tag_one(
    """
    the row to be inserted
    """
    object: tag_insert_input!

    """
    on conflict condition
    """
    on_conflict: tag_on_conflict
  ): tag

  """
  insert data into the table: "user"
  """
  insert_user(
    """
    the rows to be inserted
    """
    objects: [user_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """
    the row to be inserted
    """
    object: user_insert_input!

    """
    on conflict condition
    """
    on_conflict: user_on_conflict
  ): user

  """
  update data of the table: "app"
  """
  update_app(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: app_set_input

    """
    filter the rows which have to be updated
    """
    where: app_bool_exp!
  ): app_mutation_response

  """
  update single row of the table: "app"
  """
  update_app_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: app_set_input
    pk_columns: app_pk_columns_input!
  ): app

  """
  update data of the table: "atom"
  """
  update_atom(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: atom_set_input

    """
    filter the rows which have to be updated
    """
    where: atom_bool_exp!
  ): atom_mutation_response

  """
  update single row of the table: "atom"
  """
  update_atom_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: atom_set_input
    pk_columns: atom_pk_columns_input!
  ): atom

  """
  update data of the table: "atom_types"
  """
  update_atom_types(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: atom_types_set_input

    """
    filter the rows which have to be updated
    """
    where: atom_types_bool_exp!
  ): atom_types_mutation_response

  """
  update single row of the table: "atom_types"
  """
  update_atom_types_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: atom_types_set_input
    pk_columns: atom_types_pk_columns_input!
  ): atom_types

  """
  update data of the table: "attribute"
  """
  update_attribute(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: attribute_set_input

    """
    filter the rows which have to be updated
    """
    where: attribute_bool_exp!
  ): attribute_mutation_response

  """
  update single row of the table: "attribute"
  """
  update_attribute_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: attribute_set_input
    pk_columns: attribute_pk_columns_input!
  ): attribute

  """
  update data of the table: "category"
  """
  update_category(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: category_set_input

    """
    filter the rows which have to be updated
    """
    where: category_bool_exp!
  ): category_mutation_response

  """
  update single row of the table: "category"
  """
  update_category_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: category_set_input
    pk_columns: category_pk_columns_input!
  ): category

  """
  update data of the table: "component"
  """
  update_component(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: component_set_input

    """
    filter the rows which have to be updated
    """
    where: component_bool_exp!
  ): component_mutation_response

  """
  update single row of the table: "component"
  """
  update_component_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: component_set_input
    pk_columns: component_pk_columns_input!
  ): component

  """
  update data of the table: "component_element"
  """
  update_component_element(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: component_element_set_input

    """
    filter the rows which have to be updated
    """
    where: component_element_bool_exp!
  ): component_element_mutation_response

  """
  update single row of the table: "component_element"
  """
  update_component_element_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: component_element_set_input
    pk_columns: component_element_pk_columns_input!
  ): component_element

  """
  update data of the table: "component_link"
  """
  update_component_link(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: component_link_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: component_link_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: component_link_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: component_link_delete_key_input

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: component_link_inc_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: component_link_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: component_link_set_input

    """
    filter the rows which have to be updated
    """
    where: component_link_bool_exp!
  ): component_link_mutation_response

  """
  update single row of the table: "component_link"
  """
  update_component_link_by_pk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: component_link_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: component_link_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: component_link_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: component_link_delete_key_input

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: component_link_inc_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: component_link_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: component_link_set_input
    pk_columns: component_link_pk_columns_input!
  ): component_link

  """
  update data of the table: "lambda"
  """
  update_lambda(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: lambda_set_input

    """
    filter the rows which have to be updated
    """
    where: lambda_bool_exp!
  ): lambda_mutation_response

  """
  update single row of the table: "lambda"
  """
  update_lambda_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: lambda_set_input
    pk_columns: lambda_pk_columns_input!
  ): lambda

  """
  update data of the table: "library"
  """
  update_library(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: library_set_input

    """
    filter the rows which have to be updated
    """
    where: library_bool_exp!
  ): library_mutation_response

  """
  update single row of the table: "library"
  """
  update_library_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: library_set_input
    pk_columns: library_pk_columns_input!
  ): library

  """
  update data of the table: "page"
  """
  update_page(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_set_input

    """
    filter the rows which have to be updated
    """
    where: page_bool_exp!
  ): page_mutation_response

  """
  update single row of the table: "page"
  """
  update_page_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_set_input
    pk_columns: page_pk_columns_input!
  ): page

  """
  update data of the table: "page_element"
  """
  update_page_element(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_element_set_input

    """
    filter the rows which have to be updated
    """
    where: page_element_bool_exp!
  ): page_element_mutation_response

  """
  update single row of the table: "page_element"
  """
  update_page_element_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_element_set_input
    pk_columns: page_element_pk_columns_input!
  ): page_element

  """
  update data of the table: "page_links"
  """
  update_page_links(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: page_links_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: page_links_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: page_links_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: page_links_delete_key_input

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: page_links_inc_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: page_links_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_links_set_input

    """
    filter the rows which have to be updated
    """
    where: page_links_bool_exp!
  ): page_links_mutation_response

  """
  update single row of the table: "page_links"
  """
  update_page_links_by_pk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: page_links_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: page_links_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: page_links_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: page_links_delete_key_input

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: page_links_inc_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: page_links_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_links_set_input
    pk_columns: page_links_pk_columns_input!
  ): page_links

  """
  update data of the table: "prop"
  """
  update_prop(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_set_input

    """
    filter the rows which have to be updated
    """
    where: prop_bool_exp!
  ): prop_mutation_response

  """
  update single row of the table: "prop"
  """
  update_prop_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_set_input
    pk_columns: prop_pk_columns_input!
  ): prop

  """
  update data of the table: "prop_element"
  """
  update_prop_element(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_element_set_input

    """
    filter the rows which have to be updated
    """
    where: prop_element_bool_exp!
  ): prop_element_mutation_response

  """
  update single row of the table: "prop_element"
  """
  update_prop_element_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_element_set_input
    pk_columns: prop_element_pk_columns_input!
  ): prop_element

  """
  update data of the table: "prop_value_tag"
  """
  update_prop_value_tag(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_value_tag_set_input

    """
    filter the rows which have to be updated
    """
    where: prop_value_tag_bool_exp!
  ): prop_value_tag_mutation_response

  """
  update single row of the table: "prop_value_tag"
  """
  update_prop_value_tag_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_value_tag_set_input
    pk_columns: prop_value_tag_pk_columns_input!
  ): prop_value_tag

  """
  update data of the table: "prop_value_type"
  """
  update_prop_value_type(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_value_type_set_input

    """
    filter the rows which have to be updated
    """
    where: prop_value_type_bool_exp!
  ): prop_value_type_mutation_response

  """
  update single row of the table: "prop_value_type"
  """
  update_prop_value_type_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_value_type_set_input
    pk_columns: prop_value_type_pk_columns_input!
  ): prop_value_type

  """
  update data of the table: "prop_values"
  """
  update_prop_values(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_values_set_input

    """
    filter the rows which have to be updated
    """
    where: prop_values_bool_exp!
  ): prop_values_mutation_response

  """
  update single row of the table: "prop_values"
  """
  update_prop_values_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_values_set_input
    pk_columns: prop_values_pk_columns_input!
  ): prop_values

  """
  update data of the table: "style"
  """
  update_style(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: style_set_input

    """
    filter the rows which have to be updated
    """
    where: style_bool_exp!
  ): style_mutation_response

  """
  update single row of the table: "style"
  """
  update_style_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: style_set_input
    pk_columns: style_pk_columns_input!
  ): style

  """
  update data of the table: "tag"
  """
  update_tag(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_set_input

    """
    filter the rows which have to be updated
    """
    where: tag_bool_exp!
  ): tag_mutation_response

  """
  update single row of the table: "tag"
  """
  update_tag_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_set_input
    pk_columns: tag_pk_columns_input!
  ): tag

  """
  update data of the table: "user"
  """
  update_user(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: user_set_input

    """
    filter the rows which have to be updated
    """
    where: user_bool_exp!
  ): user_mutation_response

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc

  """
  in ascending order, nulls first
  """
  asc_nulls_first

  """
  in ascending order, nulls last
  """
  asc_nulls_last

  """
  in descending order, nulls first
  """
  desc

  """
  in descending order, nulls first
  """
  desc_nulls_first

  """
  in descending order, nulls last
  """
  desc_nulls_last
}

"""
columns and relationships of "page"
"""
type page {
  """
  An object relationship
  """
  app: app!
  app_id: uuid!
  id: uuid!
  name: String!
  owner_id: String!
}

"""
aggregated selection of "page"
"""
type page_aggregate {
  aggregate: page_aggregate_fields
  nodes: [page!]!
}

"""
aggregate fields of "page"
"""
type page_aggregate_fields {
  count(columns: [page_select_column!], distinct: Boolean): Int!
  max: page_max_fields
  min: page_min_fields
}

"""
order by aggregate values of table "page"
"""
input page_aggregate_order_by {
  count: order_by
  max: page_max_order_by
  min: page_min_order_by
}

"""
input type for inserting array relation for remote table "page"
"""
input page_arr_rel_insert_input {
  data: [page_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: page_on_conflict
}

"""
Boolean expression to filter rows from the table "page". All fields are combined with a logical 'AND'.
"""
input page_bool_exp {
  _and: [page_bool_exp!]
  _not: page_bool_exp
  _or: [page_bool_exp!]
  app: app_bool_exp
  app_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  owner_id: String_comparison_exp
}

"""
unique or primary key constraints on table "page"
"""
enum page_constraint {
  """
  unique or primary key constraint
  """
  pages_pkey
}

"""
columns and relationships of "page_element"
"""
type page_element {
  component_id: uuid!
  id: uuid!
  name: String
  page_id: uuid!
}

"""
aggregated selection of "page_element"
"""
type page_element_aggregate {
  aggregate: page_element_aggregate_fields
  nodes: [page_element!]!
}

"""
aggregate fields of "page_element"
"""
type page_element_aggregate_fields {
  count(columns: [page_element_select_column!], distinct: Boolean): Int!
  max: page_element_max_fields
  min: page_element_min_fields
}

"""
Boolean expression to filter rows from the table "page_element". All fields are combined with a logical 'AND'.
"""
input page_element_bool_exp {
  _and: [page_element_bool_exp!]
  _not: page_element_bool_exp
  _or: [page_element_bool_exp!]
  component_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  page_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "page_element"
"""
enum page_element_constraint {
  """
  unique or primary key constraint
  """
  elements_pkey
}

"""
input type for inserting data into table "page_element"
"""
input page_element_insert_input {
  component_id: uuid
  id: uuid
  name: String
  page_id: uuid
}

"""
aggregate max on columns
"""
type page_element_max_fields {
  component_id: uuid
  id: uuid
  name: String
  page_id: uuid
}

"""
aggregate min on columns
"""
type page_element_min_fields {
  component_id: uuid
  id: uuid
  name: String
  page_id: uuid
}

"""
response of any mutation on the table "page_element"
"""
type page_element_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [page_element!]!
}

"""
on conflict condition type for table "page_element"
"""
input page_element_on_conflict {
  constraint: page_element_constraint!
  update_columns: [page_element_update_column!]!
  where: page_element_bool_exp
}

"""
Ordering options when selecting data from "page_element".
"""
input page_element_order_by {
  component_id: order_by
  id: order_by
  name: order_by
  page_id: order_by
}

"""
primary key columns input for table: page_element
"""
input page_element_pk_columns_input {
  id: uuid!
}

"""
select columns of table "page_element"
"""
enum page_element_select_column {
  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  page_id
}

"""
input type for updating data in table "page_element"
"""
input page_element_set_input {
  component_id: uuid
  id: uuid
  name: String
  page_id: uuid
}

"""
update columns of table "page_element"
"""
enum page_element_update_column {
  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  page_id
}

"""
input type for inserting data into table "page"
"""
input page_insert_input {
  app: app_obj_rel_insert_input
  app_id: uuid
  id: uuid
  name: String
  owner_id: String
}

"""
columns and relationships of "page_links"
"""
type page_links {
  id: uuid!
  order: Int
  page_id: uuid!
  props(
    """
    JSON select path
    """
    path: String
  ): jsonb
  source_element_id: uuid!
  target_element_id: uuid!
}

"""
aggregated selection of "page_links"
"""
type page_links_aggregate {
  aggregate: page_links_aggregate_fields
  nodes: [page_links!]!
}

"""
aggregate fields of "page_links"
"""
type page_links_aggregate_fields {
  avg: page_links_avg_fields
  count(columns: [page_links_select_column!], distinct: Boolean): Int!
  max: page_links_max_fields
  min: page_links_min_fields
  stddev: page_links_stddev_fields
  stddev_pop: page_links_stddev_pop_fields
  stddev_samp: page_links_stddev_samp_fields
  sum: page_links_sum_fields
  var_pop: page_links_var_pop_fields
  var_samp: page_links_var_samp_fields
  variance: page_links_variance_fields
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input page_links_append_input {
  props: jsonb
}

"""
aggregate avg on columns
"""
type page_links_avg_fields {
  order: Float
}

"""
Boolean expression to filter rows from the table "page_links". All fields are combined with a logical 'AND'.
"""
input page_links_bool_exp {
  _and: [page_links_bool_exp!]
  _not: page_links_bool_exp
  _or: [page_links_bool_exp!]
  id: uuid_comparison_exp
  order: Int_comparison_exp
  page_id: uuid_comparison_exp
  props: jsonb_comparison_exp
  source_element_id: uuid_comparison_exp
  target_element_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "page_links"
"""
enum page_links_constraint {
  """
  unique or primary key constraint
  """
  page_links_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input page_links_delete_at_path_input {
  props: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input page_links_delete_elem_input {
  props: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input page_links_delete_key_input {
  props: String
}

"""
input type for incrementing numeric columns in table "page_links"
"""
input page_links_inc_input {
  order: Int
}

"""
input type for inserting data into table "page_links"
"""
input page_links_insert_input {
  id: uuid
  order: Int
  page_id: uuid
  props: jsonb
  source_element_id: uuid
  target_element_id: uuid
}

"""
aggregate max on columns
"""
type page_links_max_fields {
  id: uuid
  order: Int
  page_id: uuid
  source_element_id: uuid
  target_element_id: uuid
}

"""
aggregate min on columns
"""
type page_links_min_fields {
  id: uuid
  order: Int
  page_id: uuid
  source_element_id: uuid
  target_element_id: uuid
}

"""
response of any mutation on the table "page_links"
"""
type page_links_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [page_links!]!
}

"""
on conflict condition type for table "page_links"
"""
input page_links_on_conflict {
  constraint: page_links_constraint!
  update_columns: [page_links_update_column!]!
  where: page_links_bool_exp
}

"""
Ordering options when selecting data from "page_links".
"""
input page_links_order_by {
  id: order_by
  order: order_by
  page_id: order_by
  props: order_by
  source_element_id: order_by
  target_element_id: order_by
}

"""
primary key columns input for table: page_links
"""
input page_links_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input page_links_prepend_input {
  props: jsonb
}

"""
select columns of table "page_links"
"""
enum page_links_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  order

  """
  column name
  """
  page_id

  """
  column name
  """
  props

  """
  column name
  """
  source_element_id

  """
  column name
  """
  target_element_id
}

"""
input type for updating data in table "page_links"
"""
input page_links_set_input {
  id: uuid
  order: Int
  page_id: uuid
  props: jsonb
  source_element_id: uuid
  target_element_id: uuid
}

"""
aggregate stddev on columns
"""
type page_links_stddev_fields {
  order: Float
}

"""
aggregate stddev_pop on columns
"""
type page_links_stddev_pop_fields {
  order: Float
}

"""
aggregate stddev_samp on columns
"""
type page_links_stddev_samp_fields {
  order: Float
}

"""
aggregate sum on columns
"""
type page_links_sum_fields {
  order: Int
}

"""
update columns of table "page_links"
"""
enum page_links_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  order

  """
  column name
  """
  page_id

  """
  column name
  """
  props

  """
  column name
  """
  source_element_id

  """
  column name
  """
  target_element_id
}

"""
aggregate var_pop on columns
"""
type page_links_var_pop_fields {
  order: Float
}

"""
aggregate var_samp on columns
"""
type page_links_var_samp_fields {
  order: Float
}

"""
aggregate variance on columns
"""
type page_links_variance_fields {
  order: Float
}

"""
aggregate max on columns
"""
type page_max_fields {
  app_id: uuid
  id: uuid
  name: String
  owner_id: String
}

"""
order by max() on columns of table "page"
"""
input page_max_order_by {
  app_id: order_by
  id: order_by
  name: order_by
  owner_id: order_by
}

"""
aggregate min on columns
"""
type page_min_fields {
  app_id: uuid
  id: uuid
  name: String
  owner_id: String
}

"""
order by min() on columns of table "page"
"""
input page_min_order_by {
  app_id: order_by
  id: order_by
  name: order_by
  owner_id: order_by
}

"""
response of any mutation on the table "page"
"""
type page_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [page!]!
}

"""
on conflict condition type for table "page"
"""
input page_on_conflict {
  constraint: page_constraint!
  update_columns: [page_update_column!]!
  where: page_bool_exp
}

"""
Ordering options when selecting data from "page".
"""
input page_order_by {
  app: app_order_by
  app_id: order_by
  id: order_by
  name: order_by
  owner_id: order_by
}

"""
primary key columns input for table: page
"""
input page_pk_columns_input {
  id: uuid!
}

"""
select columns of table "page"
"""
enum page_select_column {
  """
  column name
  """
  app_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  owner_id
}

"""
input type for updating data in table "page"
"""
input page_set_input {
  app_id: uuid
  id: uuid
  name: String
  owner_id: String
}

"""
update columns of table "page"
"""
enum page_update_column {
  """
  column name
  """
  app_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  owner_id
}

"""
columns and relationships of "prop"
"""
type prop {
  id: uuid!

  """
  An object relationship
  """
  library: library!
  library_id: uuid!
}

"""
aggregated selection of "prop"
"""
type prop_aggregate {
  aggregate: prop_aggregate_fields
  nodes: [prop!]!
}

"""
aggregate fields of "prop"
"""
type prop_aggregate_fields {
  count(columns: [prop_select_column!], distinct: Boolean): Int!
  max: prop_max_fields
  min: prop_min_fields
}

"""
Boolean expression to filter rows from the table "prop". All fields are combined with a logical 'AND'.
"""
input prop_bool_exp {
  _and: [prop_bool_exp!]
  _not: prop_bool_exp
  _or: [prop_bool_exp!]
  id: uuid_comparison_exp
  library: library_bool_exp
  library_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "prop"
"""
enum prop_constraint {
  """
  unique or primary key constraint
  """
  props_pkey
}

"""
columns and relationships of "prop_element"
"""
type prop_element {
  element_id: uuid!
  prop_id: uuid!
}

"""
aggregated selection of "prop_element"
"""
type prop_element_aggregate {
  aggregate: prop_element_aggregate_fields
  nodes: [prop_element!]!
}

"""
aggregate fields of "prop_element"
"""
type prop_element_aggregate_fields {
  count(columns: [prop_element_select_column!], distinct: Boolean): Int!
  max: prop_element_max_fields
  min: prop_element_min_fields
}

"""
Boolean expression to filter rows from the table "prop_element". All fields are combined with a logical 'AND'.
"""
input prop_element_bool_exp {
  _and: [prop_element_bool_exp!]
  _not: prop_element_bool_exp
  _or: [prop_element_bool_exp!]
  element_id: uuid_comparison_exp
  prop_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "prop_element"
"""
enum prop_element_constraint {
  """
  unique or primary key constraint
  """
  prop_element_pkey
}

"""
input type for inserting data into table "prop_element"
"""
input prop_element_insert_input {
  element_id: uuid
  prop_id: uuid
}

"""
aggregate max on columns
"""
type prop_element_max_fields {
  element_id: uuid
  prop_id: uuid
}

"""
aggregate min on columns
"""
type prop_element_min_fields {
  element_id: uuid
  prop_id: uuid
}

"""
response of any mutation on the table "prop_element"
"""
type prop_element_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [prop_element!]!
}

"""
on conflict condition type for table "prop_element"
"""
input prop_element_on_conflict {
  constraint: prop_element_constraint!
  update_columns: [prop_element_update_column!]!
  where: prop_element_bool_exp
}

"""
Ordering options when selecting data from "prop_element".
"""
input prop_element_order_by {
  element_id: order_by
  prop_id: order_by
}

"""
primary key columns input for table: prop_element
"""
input prop_element_pk_columns_input {
  element_id: uuid!
  prop_id: uuid!
}

"""
select columns of table "prop_element"
"""
enum prop_element_select_column {
  """
  column name
  """
  element_id

  """
  column name
  """
  prop_id
}

"""
input type for updating data in table "prop_element"
"""
input prop_element_set_input {
  element_id: uuid
  prop_id: uuid
}

"""
update columns of table "prop_element"
"""
enum prop_element_update_column {
  """
  column name
  """
  element_id

  """
  column name
  """
  prop_id
}

"""
input type for inserting data into table "prop"
"""
input prop_insert_input {
  id: uuid
  library: library_obj_rel_insert_input
  library_id: uuid
}

"""
aggregate max on columns
"""
type prop_max_fields {
  id: uuid
  library_id: uuid
}

"""
aggregate min on columns
"""
type prop_min_fields {
  id: uuid
  library_id: uuid
}

"""
response of any mutation on the table "prop"
"""
type prop_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [prop!]!
}

"""
on conflict condition type for table "prop"
"""
input prop_on_conflict {
  constraint: prop_constraint!
  update_columns: [prop_update_column!]!
  where: prop_bool_exp
}

"""
Ordering options when selecting data from "prop".
"""
input prop_order_by {
  id: order_by
  library: library_order_by
  library_id: order_by
}

"""
primary key columns input for table: prop
"""
input prop_pk_columns_input {
  id: uuid!
}

"""
select columns of table "prop"
"""
enum prop_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  library_id
}

"""
input type for updating data in table "prop"
"""
input prop_set_input {
  id: uuid
  library_id: uuid
}

"""
update columns of table "prop"
"""
enum prop_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  library_id
}

"""
columns and relationships of "prop_value_tag"
"""
type prop_value_tag {
  prop_value_id: uuid!
  tag_id: uuid!
}

"""
aggregated selection of "prop_value_tag"
"""
type prop_value_tag_aggregate {
  aggregate: prop_value_tag_aggregate_fields
  nodes: [prop_value_tag!]!
}

"""
aggregate fields of "prop_value_tag"
"""
type prop_value_tag_aggregate_fields {
  count(columns: [prop_value_tag_select_column!], distinct: Boolean): Int!
  max: prop_value_tag_max_fields
  min: prop_value_tag_min_fields
}

"""
Boolean expression to filter rows from the table "prop_value_tag". All fields are combined with a logical 'AND'.
"""
input prop_value_tag_bool_exp {
  _and: [prop_value_tag_bool_exp!]
  _not: prop_value_tag_bool_exp
  _or: [prop_value_tag_bool_exp!]
  prop_value_id: uuid_comparison_exp
  tag_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "prop_value_tag"
"""
enum prop_value_tag_constraint {
  """
  unique or primary key constraint
  """
  prop_value_tag_pkey
}

"""
input type for inserting data into table "prop_value_tag"
"""
input prop_value_tag_insert_input {
  prop_value_id: uuid
  tag_id: uuid
}

"""
aggregate max on columns
"""
type prop_value_tag_max_fields {
  prop_value_id: uuid
  tag_id: uuid
}

"""
aggregate min on columns
"""
type prop_value_tag_min_fields {
  prop_value_id: uuid
  tag_id: uuid
}

"""
response of any mutation on the table "prop_value_tag"
"""
type prop_value_tag_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [prop_value_tag!]!
}

"""
on conflict condition type for table "prop_value_tag"
"""
input prop_value_tag_on_conflict {
  constraint: prop_value_tag_constraint!
  update_columns: [prop_value_tag_update_column!]!
  where: prop_value_tag_bool_exp
}

"""
Ordering options when selecting data from "prop_value_tag".
"""
input prop_value_tag_order_by {
  prop_value_id: order_by
  tag_id: order_by
}

"""
primary key columns input for table: prop_value_tag
"""
input prop_value_tag_pk_columns_input {
  prop_value_id: uuid!
  tag_id: uuid!
}

"""
select columns of table "prop_value_tag"
"""
enum prop_value_tag_select_column {
  """
  column name
  """
  prop_value_id

  """
  column name
  """
  tag_id
}

"""
input type for updating data in table "prop_value_tag"
"""
input prop_value_tag_set_input {
  prop_value_id: uuid
  tag_id: uuid
}

"""
update columns of table "prop_value_tag"
"""
enum prop_value_tag_update_column {
  """
  column name
  """
  prop_value_id

  """
  column name
  """
  tag_id
}

"""
columns and relationships of "prop_value_type"
"""
type prop_value_type {
  description: String
  value: String!
}

"""
aggregated selection of "prop_value_type"
"""
type prop_value_type_aggregate {
  aggregate: prop_value_type_aggregate_fields
  nodes: [prop_value_type!]!
}

"""
aggregate fields of "prop_value_type"
"""
type prop_value_type_aggregate_fields {
  count(columns: [prop_value_type_select_column!], distinct: Boolean): Int!
  max: prop_value_type_max_fields
  min: prop_value_type_min_fields
}

"""
Boolean expression to filter rows from the table "prop_value_type". All fields are combined with a logical 'AND'.
"""
input prop_value_type_bool_exp {
  _and: [prop_value_type_bool_exp!]
  _not: prop_value_type_bool_exp
  _or: [prop_value_type_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "prop_value_type"
"""
enum prop_value_type_constraint {
  """
  unique or primary key constraint
  """
  prop_value_types_pkey
}

"""
input type for inserting data into table "prop_value_type"
"""
input prop_value_type_insert_input {
  description: String
  value: String
}

"""
aggregate max on columns
"""
type prop_value_type_max_fields {
  description: String
  value: String
}

"""
aggregate min on columns
"""
type prop_value_type_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "prop_value_type"
"""
type prop_value_type_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [prop_value_type!]!
}

"""
on conflict condition type for table "prop_value_type"
"""
input prop_value_type_on_conflict {
  constraint: prop_value_type_constraint!
  update_columns: [prop_value_type_update_column!]!
  where: prop_value_type_bool_exp
}

"""
Ordering options when selecting data from "prop_value_type".
"""
input prop_value_type_order_by {
  description: order_by
  value: order_by
}

"""
primary key columns input for table: prop_value_type
"""
input prop_value_type_pk_columns_input {
  value: String!
}

"""
select columns of table "prop_value_type"
"""
enum prop_value_type_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

"""
input type for updating data in table "prop_value_type"
"""
input prop_value_type_set_input {
  description: String
  value: String
}

"""
update columns of table "prop_value_type"
"""
enum prop_value_type_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

"""
columns and relationships of "prop_values"
"""
type prop_values {
  id: uuid!

  """
  This is used as a value
  """
  lambda_id: uuid
  name: String!

  """
  This is the prop that owns this value
  """
  parent_prop_id: uuid!
  type: String!
  value: String

  """
  This is the prop that is used as a value
  """
  value_prop_id: uuid
}

"""
aggregated selection of "prop_values"
"""
type prop_values_aggregate {
  aggregate: prop_values_aggregate_fields
  nodes: [prop_values!]!
}

"""
aggregate fields of "prop_values"
"""
type prop_values_aggregate_fields {
  count(columns: [prop_values_select_column!], distinct: Boolean): Int!
  max: prop_values_max_fields
  min: prop_values_min_fields
}

"""
Boolean expression to filter rows from the table "prop_values". All fields are combined with a logical 'AND'.
"""
input prop_values_bool_exp {
  _and: [prop_values_bool_exp!]
  _not: prop_values_bool_exp
  _or: [prop_values_bool_exp!]
  id: uuid_comparison_exp
  lambda_id: uuid_comparison_exp
  name: String_comparison_exp
  parent_prop_id: uuid_comparison_exp
  type: String_comparison_exp
  value: String_comparison_exp
  value_prop_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "prop_values"
"""
enum prop_values_constraint {
  """
  unique or primary key constraint
  """
  prop_values_pkey
}

"""
input type for inserting data into table "prop_values"
"""
input prop_values_insert_input {
  id: uuid

  """
  This is used as a value
  """
  lambda_id: uuid
  name: String

  """
  This is the prop that owns this value
  """
  parent_prop_id: uuid
  type: String
  value: String

  """
  This is the prop that is used as a value
  """
  value_prop_id: uuid
}

"""
aggregate max on columns
"""
type prop_values_max_fields {
  id: uuid

  """
  This is used as a value
  """
  lambda_id: uuid
  name: String

  """
  This is the prop that owns this value
  """
  parent_prop_id: uuid
  type: String
  value: String

  """
  This is the prop that is used as a value
  """
  value_prop_id: uuid
}

"""
aggregate min on columns
"""
type prop_values_min_fields {
  id: uuid

  """
  This is used as a value
  """
  lambda_id: uuid
  name: String

  """
  This is the prop that owns this value
  """
  parent_prop_id: uuid
  type: String
  value: String

  """
  This is the prop that is used as a value
  """
  value_prop_id: uuid
}

"""
response of any mutation on the table "prop_values"
"""
type prop_values_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [prop_values!]!
}

"""
on conflict condition type for table "prop_values"
"""
input prop_values_on_conflict {
  constraint: prop_values_constraint!
  update_columns: [prop_values_update_column!]!
  where: prop_values_bool_exp
}

"""
Ordering options when selecting data from "prop_values".
"""
input prop_values_order_by {
  id: order_by
  lambda_id: order_by
  name: order_by
  parent_prop_id: order_by
  type: order_by
  value: order_by
  value_prop_id: order_by
}

"""
primary key columns input for table: prop_values
"""
input prop_values_pk_columns_input {
  id: uuid!
}

"""
select columns of table "prop_values"
"""
enum prop_values_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  lambda_id

  """
  column name
  """
  name

  """
  column name
  """
  parent_prop_id

  """
  column name
  """
  type

  """
  column name
  """
  value

  """
  column name
  """
  value_prop_id
}

"""
input type for updating data in table "prop_values"
"""
input prop_values_set_input {
  id: uuid

  """
  This is used as a value
  """
  lambda_id: uuid
  name: String

  """
  This is the prop that owns this value
  """
  parent_prop_id: uuid
  type: String
  value: String

  """
  This is the prop that is used as a value
  """
  value_prop_id: uuid
}

"""
update columns of table "prop_values"
"""
enum prop_values_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  lambda_id

  """
  column name
  """
  name

  """
  column name
  """
  parent_prop_id

  """
  column name
  """
  type

  """
  column name
  """
  value

  """
  column name
  """
  value_prop_id
}

type query_root {
  """
  fetch data from the table: "app"
  """
  app(
    """
    distinct select on columns
    """
    distinct_on: [app_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [app_order_by!]

    """
    filter the rows returned
    """
    where: app_bool_exp
  ): [app!]!

  """
  fetch aggregated fields from the table: "app"
  """
  app_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [app_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [app_order_by!]

    """
    filter the rows returned
    """
    where: app_bool_exp
  ): app_aggregate!

  """
  fetch data from the table: "app" using primary key columns
  """
  app_by_pk(id: uuid!): app

  """
  fetch data from the table: "atom"
  """
  atom(
    """
    distinct select on columns
    """
    distinct_on: [atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_order_by!]

    """
    filter the rows returned
    """
    where: atom_bool_exp
  ): [atom!]!

  """
  fetch aggregated fields from the table: "atom"
  """
  atom_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_order_by!]

    """
    filter the rows returned
    """
    where: atom_bool_exp
  ): atom_aggregate!

  """
  fetch data from the table: "atom" using primary key columns
  """
  atom_by_pk(id: uuid!): atom

  """
  fetch data from the table: "atom_types"
  """
  atom_types(
    """
    distinct select on columns
    """
    distinct_on: [atom_types_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_types_order_by!]

    """
    filter the rows returned
    """
    where: atom_types_bool_exp
  ): [atom_types!]!

  """
  fetch aggregated fields from the table: "atom_types"
  """
  atom_types_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [atom_types_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_types_order_by!]

    """
    filter the rows returned
    """
    where: atom_types_bool_exp
  ): atom_types_aggregate!

  """
  fetch data from the table: "atom_types" using primary key columns
  """
  atom_types_by_pk(value: String!): atom_types

  """
  fetch data from the table: "attribute"
  """
  attribute(
    """
    distinct select on columns
    """
    distinct_on: [attribute_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [attribute_order_by!]

    """
    filter the rows returned
    """
    where: attribute_bool_exp
  ): [attribute!]!

  """
  fetch aggregated fields from the table: "attribute"
  """
  attribute_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [attribute_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [attribute_order_by!]

    """
    filter the rows returned
    """
    where: attribute_bool_exp
  ): attribute_aggregate!

  """
  fetch data from the table: "attribute" using primary key columns
  """
  attribute_by_pk(id: uuid!): attribute

  """
  fetch data from the table: "category"
  """
  category(
    """
    distinct select on columns
    """
    distinct_on: [category_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [category_order_by!]

    """
    filter the rows returned
    """
    where: category_bool_exp
  ): [category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  category_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [category_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [category_order_by!]

    """
    filter the rows returned
    """
    where: category_bool_exp
  ): category_aggregate!

  """
  fetch data from the table: "category" using primary key columns
  """
  category_by_pk(id: uuid!): category

  """
  fetch data from the table: "component"
  """
  component(
    """
    distinct select on columns
    """
    distinct_on: [component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_order_by!]

    """
    filter the rows returned
    """
    where: component_bool_exp
  ): [component!]!

  """
  fetch aggregated fields from the table: "component"
  """
  component_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_order_by!]

    """
    filter the rows returned
    """
    where: component_bool_exp
  ): component_aggregate!

  """
  fetch data from the table: "component" using primary key columns
  """
  component_by_pk(id: uuid!): component

  """
  fetch data from the table: "component_element"
  """
  component_element(
    """
    distinct select on columns
    """
    distinct_on: [component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_element_order_by!]

    """
    filter the rows returned
    """
    where: component_element_bool_exp
  ): [component_element!]!

  """
  fetch aggregated fields from the table: "component_element"
  """
  component_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_element_order_by!]

    """
    filter the rows returned
    """
    where: component_element_bool_exp
  ): component_element_aggregate!

  """
  fetch data from the table: "component_element" using primary key columns
  """
  component_element_by_pk(id: uuid!): component_element

  """
  fetch data from the table: "component_link"
  """
  component_link(
    """
    distinct select on columns
    """
    distinct_on: [component_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_link_order_by!]

    """
    filter the rows returned
    """
    where: component_link_bool_exp
  ): [component_link!]!

  """
  fetch aggregated fields from the table: "component_link"
  """
  component_link_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_link_order_by!]

    """
    filter the rows returned
    """
    where: component_link_bool_exp
  ): component_link_aggregate!

  """
  fetch data from the table: "component_link" using primary key columns
  """
  component_link_by_pk(id: uuid!): component_link

  """
  fetch data from the table: "lambda"
  """
  lambda(
    """
    distinct select on columns
    """
    distinct_on: [lambda_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [lambda_order_by!]

    """
    filter the rows returned
    """
    where: lambda_bool_exp
  ): [lambda!]!

  """
  fetch aggregated fields from the table: "lambda"
  """
  lambda_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [lambda_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [lambda_order_by!]

    """
    filter the rows returned
    """
    where: lambda_bool_exp
  ): lambda_aggregate!

  """
  fetch data from the table: "lambda" using primary key columns
  """
  lambda_by_pk(id: uuid!): lambda

  """
  fetch data from the table: "library"
  """
  library(
    """
    distinct select on columns
    """
    distinct_on: [library_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [library_order_by!]

    """
    filter the rows returned
    """
    where: library_bool_exp
  ): [library!]!

  """
  fetch aggregated fields from the table: "library"
  """
  library_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [library_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [library_order_by!]

    """
    filter the rows returned
    """
    where: library_bool_exp
  ): library_aggregate!

  """
  fetch data from the table: "library" using primary key columns
  """
  library_by_pk(id: uuid!): library

  """
  fetch data from the table: "page"
  """
  page(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): [page!]!

  """
  fetch aggregated fields from the table: "page"
  """
  page_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): page_aggregate!

  """
  fetch data from the table: "page" using primary key columns
  """
  page_by_pk(id: uuid!): page

  """
  fetch data from the table: "page_element"
  """
  page_element(
    """
    distinct select on columns
    """
    distinct_on: [page_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_element_order_by!]

    """
    filter the rows returned
    """
    where: page_element_bool_exp
  ): [page_element!]!

  """
  fetch aggregated fields from the table: "page_element"
  """
  page_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_element_order_by!]

    """
    filter the rows returned
    """
    where: page_element_bool_exp
  ): page_element_aggregate!

  """
  fetch data from the table: "page_element" using primary key columns
  """
  page_element_by_pk(id: uuid!): page_element

  """
  fetch data from the table: "page_links"
  """
  page_links(
    """
    distinct select on columns
    """
    distinct_on: [page_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_links_order_by!]

    """
    filter the rows returned
    """
    where: page_links_bool_exp
  ): [page_links!]!

  """
  fetch aggregated fields from the table: "page_links"
  """
  page_links_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_links_order_by!]

    """
    filter the rows returned
    """
    where: page_links_bool_exp
  ): page_links_aggregate!

  """
  fetch data from the table: "page_links" using primary key columns
  """
  page_links_by_pk(id: uuid!): page_links

  """
  fetch data from the table: "prop"
  """
  prop(
    """
    distinct select on columns
    """
    distinct_on: [prop_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_order_by!]

    """
    filter the rows returned
    """
    where: prop_bool_exp
  ): [prop!]!

  """
  fetch aggregated fields from the table: "prop"
  """
  prop_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_order_by!]

    """
    filter the rows returned
    """
    where: prop_bool_exp
  ): prop_aggregate!

  """
  fetch data from the table: "prop" using primary key columns
  """
  prop_by_pk(id: uuid!): prop

  """
  fetch data from the table: "prop_element"
  """
  prop_element(
    """
    distinct select on columns
    """
    distinct_on: [prop_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_element_order_by!]

    """
    filter the rows returned
    """
    where: prop_element_bool_exp
  ): [prop_element!]!

  """
  fetch aggregated fields from the table: "prop_element"
  """
  prop_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_element_order_by!]

    """
    filter the rows returned
    """
    where: prop_element_bool_exp
  ): prop_element_aggregate!

  """
  fetch data from the table: "prop_element" using primary key columns
  """
  prop_element_by_pk(element_id: uuid!, prop_id: uuid!): prop_element

  """
  fetch data from the table: "prop_value_tag"
  """
  prop_value_tag(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_tag_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_tag_bool_exp
  ): [prop_value_tag!]!

  """
  fetch aggregated fields from the table: "prop_value_tag"
  """
  prop_value_tag_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_tag_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_tag_bool_exp
  ): prop_value_tag_aggregate!

  """
  fetch data from the table: "prop_value_tag" using primary key columns
  """
  prop_value_tag_by_pk(prop_value_id: uuid!, tag_id: uuid!): prop_value_tag

  """
  fetch data from the table: "prop_value_type"
  """
  prop_value_type(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_type_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_type_bool_exp
  ): [prop_value_type!]!

  """
  fetch aggregated fields from the table: "prop_value_type"
  """
  prop_value_type_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_type_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_type_bool_exp
  ): prop_value_type_aggregate!

  """
  fetch data from the table: "prop_value_type" using primary key columns
  """
  prop_value_type_by_pk(value: String!): prop_value_type

  """
  fetch data from the table: "prop_values"
  """
  prop_values(
    """
    distinct select on columns
    """
    distinct_on: [prop_values_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_values_order_by!]

    """
    filter the rows returned
    """
    where: prop_values_bool_exp
  ): [prop_values!]!

  """
  fetch aggregated fields from the table: "prop_values"
  """
  prop_values_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_values_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_values_order_by!]

    """
    filter the rows returned
    """
    where: prop_values_bool_exp
  ): prop_values_aggregate!

  """
  fetch data from the table: "prop_values" using primary key columns
  """
  prop_values_by_pk(id: uuid!): prop_values

  """
  fetch data from the table: "style"
  """
  style(
    """
    distinct select on columns
    """
    distinct_on: [style_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_order_by!]

    """
    filter the rows returned
    """
    where: style_bool_exp
  ): [style!]!

  """
  fetch aggregated fields from the table: "style"
  """
  style_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [style_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_order_by!]

    """
    filter the rows returned
    """
    where: style_bool_exp
  ): style_aggregate!

  """
  fetch data from the table: "style" using primary key columns
  """
  style_by_pk(id: uuid!): style

  """
  fetch data from the table: "tag"
  """
  tag(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): [tag!]!

  """
  fetch aggregated fields from the table: "tag"
  """
  tag_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): tag_aggregate!

  """
  fetch data from the table: "tag" using primary key columns
  """
  tag_by_pk(id: uuid!): tag

  """
  fetch data from the table: "user"
  """
  user(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): user_aggregate!

  """
  fetch data from the table: "user" using primary key columns
  """
  user_by_pk(id: String!): user
}

"""
columns and relationships of "style"
"""
type style {
  id: uuid!
  library_id: uuid!
  name: String!
}

"""
aggregated selection of "style"
"""
type style_aggregate {
  aggregate: style_aggregate_fields
  nodes: [style!]!
}

"""
aggregate fields of "style"
"""
type style_aggregate_fields {
  count(columns: [style_select_column!], distinct: Boolean): Int!
  max: style_max_fields
  min: style_min_fields
}

"""
Boolean expression to filter rows from the table "style". All fields are combined with a logical 'AND'.
"""
input style_bool_exp {
  _and: [style_bool_exp!]
  _not: style_bool_exp
  _or: [style_bool_exp!]
  id: uuid_comparison_exp
  library_id: uuid_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "style"
"""
enum style_constraint {
  """
  unique or primary key constraint
  """
  styles_pkey
}

"""
input type for inserting data into table "style"
"""
input style_insert_input {
  id: uuid
  library_id: uuid
  name: String
}

"""
aggregate max on columns
"""
type style_max_fields {
  id: uuid
  library_id: uuid
  name: String
}

"""
aggregate min on columns
"""
type style_min_fields {
  id: uuid
  library_id: uuid
  name: String
}

"""
response of any mutation on the table "style"
"""
type style_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [style!]!
}

"""
on conflict condition type for table "style"
"""
input style_on_conflict {
  constraint: style_constraint!
  update_columns: [style_update_column!]!
  where: style_bool_exp
}

"""
Ordering options when selecting data from "style".
"""
input style_order_by {
  id: order_by
  library_id: order_by
  name: order_by
}

"""
primary key columns input for table: style
"""
input style_pk_columns_input {
  id: uuid!
}

"""
select columns of table "style"
"""
enum style_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  library_id

  """
  column name
  """
  name
}

"""
input type for updating data in table "style"
"""
input style_set_input {
  id: uuid
  library_id: uuid
  name: String
}

"""
update columns of table "style"
"""
enum style_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  library_id

  """
  column name
  """
  name
}

type subscription_root {
  """
  fetch data from the table: "app"
  """
  app(
    """
    distinct select on columns
    """
    distinct_on: [app_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [app_order_by!]

    """
    filter the rows returned
    """
    where: app_bool_exp
  ): [app!]!

  """
  fetch aggregated fields from the table: "app"
  """
  app_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [app_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [app_order_by!]

    """
    filter the rows returned
    """
    where: app_bool_exp
  ): app_aggregate!

  """
  fetch data from the table: "app" using primary key columns
  """
  app_by_pk(id: uuid!): app

  """
  fetch data from the table: "atom"
  """
  atom(
    """
    distinct select on columns
    """
    distinct_on: [atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_order_by!]

    """
    filter the rows returned
    """
    where: atom_bool_exp
  ): [atom!]!

  """
  fetch aggregated fields from the table: "atom"
  """
  atom_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_order_by!]

    """
    filter the rows returned
    """
    where: atom_bool_exp
  ): atom_aggregate!

  """
  fetch data from the table: "atom" using primary key columns
  """
  atom_by_pk(id: uuid!): atom

  """
  fetch data from the table: "atom_types"
  """
  atom_types(
    """
    distinct select on columns
    """
    distinct_on: [atom_types_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_types_order_by!]

    """
    filter the rows returned
    """
    where: atom_types_bool_exp
  ): [atom_types!]!

  """
  fetch aggregated fields from the table: "atom_types"
  """
  atom_types_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [atom_types_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_types_order_by!]

    """
    filter the rows returned
    """
    where: atom_types_bool_exp
  ): atom_types_aggregate!

  """
  fetch data from the table: "atom_types" using primary key columns
  """
  atom_types_by_pk(value: String!): atom_types

  """
  fetch data from the table: "attribute"
  """
  attribute(
    """
    distinct select on columns
    """
    distinct_on: [attribute_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [attribute_order_by!]

    """
    filter the rows returned
    """
    where: attribute_bool_exp
  ): [attribute!]!

  """
  fetch aggregated fields from the table: "attribute"
  """
  attribute_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [attribute_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [attribute_order_by!]

    """
    filter the rows returned
    """
    where: attribute_bool_exp
  ): attribute_aggregate!

  """
  fetch data from the table: "attribute" using primary key columns
  """
  attribute_by_pk(id: uuid!): attribute

  """
  fetch data from the table: "category"
  """
  category(
    """
    distinct select on columns
    """
    distinct_on: [category_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [category_order_by!]

    """
    filter the rows returned
    """
    where: category_bool_exp
  ): [category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  category_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [category_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [category_order_by!]

    """
    filter the rows returned
    """
    where: category_bool_exp
  ): category_aggregate!

  """
  fetch data from the table: "category" using primary key columns
  """
  category_by_pk(id: uuid!): category

  """
  fetch data from the table: "component"
  """
  component(
    """
    distinct select on columns
    """
    distinct_on: [component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_order_by!]

    """
    filter the rows returned
    """
    where: component_bool_exp
  ): [component!]!

  """
  fetch aggregated fields from the table: "component"
  """
  component_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_order_by!]

    """
    filter the rows returned
    """
    where: component_bool_exp
  ): component_aggregate!

  """
  fetch data from the table: "component" using primary key columns
  """
  component_by_pk(id: uuid!): component

  """
  fetch data from the table: "component_element"
  """
  component_element(
    """
    distinct select on columns
    """
    distinct_on: [component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_element_order_by!]

    """
    filter the rows returned
    """
    where: component_element_bool_exp
  ): [component_element!]!

  """
  fetch aggregated fields from the table: "component_element"
  """
  component_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_element_order_by!]

    """
    filter the rows returned
    """
    where: component_element_bool_exp
  ): component_element_aggregate!

  """
  fetch data from the table: "component_element" using primary key columns
  """
  component_element_by_pk(id: uuid!): component_element

  """
  fetch data from the table: "component_link"
  """
  component_link(
    """
    distinct select on columns
    """
    distinct_on: [component_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_link_order_by!]

    """
    filter the rows returned
    """
    where: component_link_bool_exp
  ): [component_link!]!

  """
  fetch aggregated fields from the table: "component_link"
  """
  component_link_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_link_order_by!]

    """
    filter the rows returned
    """
    where: component_link_bool_exp
  ): component_link_aggregate!

  """
  fetch data from the table: "component_link" using primary key columns
  """
  component_link_by_pk(id: uuid!): component_link

  """
  fetch data from the table: "lambda"
  """
  lambda(
    """
    distinct select on columns
    """
    distinct_on: [lambda_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [lambda_order_by!]

    """
    filter the rows returned
    """
    where: lambda_bool_exp
  ): [lambda!]!

  """
  fetch aggregated fields from the table: "lambda"
  """
  lambda_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [lambda_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [lambda_order_by!]

    """
    filter the rows returned
    """
    where: lambda_bool_exp
  ): lambda_aggregate!

  """
  fetch data from the table: "lambda" using primary key columns
  """
  lambda_by_pk(id: uuid!): lambda

  """
  fetch data from the table: "library"
  """
  library(
    """
    distinct select on columns
    """
    distinct_on: [library_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [library_order_by!]

    """
    filter the rows returned
    """
    where: library_bool_exp
  ): [library!]!

  """
  fetch aggregated fields from the table: "library"
  """
  library_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [library_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [library_order_by!]

    """
    filter the rows returned
    """
    where: library_bool_exp
  ): library_aggregate!

  """
  fetch data from the table: "library" using primary key columns
  """
  library_by_pk(id: uuid!): library

  """
  fetch data from the table: "page"
  """
  page(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): [page!]!

  """
  fetch aggregated fields from the table: "page"
  """
  page_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): page_aggregate!

  """
  fetch data from the table: "page" using primary key columns
  """
  page_by_pk(id: uuid!): page

  """
  fetch data from the table: "page_element"
  """
  page_element(
    """
    distinct select on columns
    """
    distinct_on: [page_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_element_order_by!]

    """
    filter the rows returned
    """
    where: page_element_bool_exp
  ): [page_element!]!

  """
  fetch aggregated fields from the table: "page_element"
  """
  page_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_element_order_by!]

    """
    filter the rows returned
    """
    where: page_element_bool_exp
  ): page_element_aggregate!

  """
  fetch data from the table: "page_element" using primary key columns
  """
  page_element_by_pk(id: uuid!): page_element

  """
  fetch data from the table: "page_links"
  """
  page_links(
    """
    distinct select on columns
    """
    distinct_on: [page_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_links_order_by!]

    """
    filter the rows returned
    """
    where: page_links_bool_exp
  ): [page_links!]!

  """
  fetch aggregated fields from the table: "page_links"
  """
  page_links_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_links_order_by!]

    """
    filter the rows returned
    """
    where: page_links_bool_exp
  ): page_links_aggregate!

  """
  fetch data from the table: "page_links" using primary key columns
  """
  page_links_by_pk(id: uuid!): page_links

  """
  fetch data from the table: "prop"
  """
  prop(
    """
    distinct select on columns
    """
    distinct_on: [prop_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_order_by!]

    """
    filter the rows returned
    """
    where: prop_bool_exp
  ): [prop!]!

  """
  fetch aggregated fields from the table: "prop"
  """
  prop_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_order_by!]

    """
    filter the rows returned
    """
    where: prop_bool_exp
  ): prop_aggregate!

  """
  fetch data from the table: "prop" using primary key columns
  """
  prop_by_pk(id: uuid!): prop

  """
  fetch data from the table: "prop_element"
  """
  prop_element(
    """
    distinct select on columns
    """
    distinct_on: [prop_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_element_order_by!]

    """
    filter the rows returned
    """
    where: prop_element_bool_exp
  ): [prop_element!]!

  """
  fetch aggregated fields from the table: "prop_element"
  """
  prop_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_element_order_by!]

    """
    filter the rows returned
    """
    where: prop_element_bool_exp
  ): prop_element_aggregate!

  """
  fetch data from the table: "prop_element" using primary key columns
  """
  prop_element_by_pk(element_id: uuid!, prop_id: uuid!): prop_element

  """
  fetch data from the table: "prop_value_tag"
  """
  prop_value_tag(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_tag_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_tag_bool_exp
  ): [prop_value_tag!]!

  """
  fetch aggregated fields from the table: "prop_value_tag"
  """
  prop_value_tag_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_tag_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_tag_bool_exp
  ): prop_value_tag_aggregate!

  """
  fetch data from the table: "prop_value_tag" using primary key columns
  """
  prop_value_tag_by_pk(prop_value_id: uuid!, tag_id: uuid!): prop_value_tag

  """
  fetch data from the table: "prop_value_type"
  """
  prop_value_type(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_type_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_type_bool_exp
  ): [prop_value_type!]!

  """
  fetch aggregated fields from the table: "prop_value_type"
  """
  prop_value_type_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_type_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_type_bool_exp
  ): prop_value_type_aggregate!

  """
  fetch data from the table: "prop_value_type" using primary key columns
  """
  prop_value_type_by_pk(value: String!): prop_value_type

  """
  fetch data from the table: "prop_values"
  """
  prop_values(
    """
    distinct select on columns
    """
    distinct_on: [prop_values_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_values_order_by!]

    """
    filter the rows returned
    """
    where: prop_values_bool_exp
  ): [prop_values!]!

  """
  fetch aggregated fields from the table: "prop_values"
  """
  prop_values_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_values_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_values_order_by!]

    """
    filter the rows returned
    """
    where: prop_values_bool_exp
  ): prop_values_aggregate!

  """
  fetch data from the table: "prop_values" using primary key columns
  """
  prop_values_by_pk(id: uuid!): prop_values

  """
  fetch data from the table: "style"
  """
  style(
    """
    distinct select on columns
    """
    distinct_on: [style_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_order_by!]

    """
    filter the rows returned
    """
    where: style_bool_exp
  ): [style!]!

  """
  fetch aggregated fields from the table: "style"
  """
  style_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [style_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_order_by!]

    """
    filter the rows returned
    """
    where: style_bool_exp
  ): style_aggregate!

  """
  fetch data from the table: "style" using primary key columns
  """
  style_by_pk(id: uuid!): style

  """
  fetch data from the table: "tag"
  """
  tag(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): [tag!]!

  """
  fetch aggregated fields from the table: "tag"
  """
  tag_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): tag_aggregate!

  """
  fetch data from the table: "tag" using primary key columns
  """
  tag_by_pk(id: uuid!): tag

  """
  fetch data from the table: "user"
  """
  user(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): user_aggregate!

  """
  fetch data from the table: "user" using primary key columns
  """
  user_by_pk(id: String!): user
}

"""
columns and relationships of "tag"
"""
type tag {
  category_id: uuid
  id: uuid!
  label: String!
}

"""
aggregated selection of "tag"
"""
type tag_aggregate {
  aggregate: tag_aggregate_fields
  nodes: [tag!]!
}

"""
aggregate fields of "tag"
"""
type tag_aggregate_fields {
  count(columns: [tag_select_column!], distinct: Boolean): Int!
  max: tag_max_fields
  min: tag_min_fields
}

"""
Boolean expression to filter rows from the table "tag". All fields are combined with a logical 'AND'.
"""
input tag_bool_exp {
  _and: [tag_bool_exp!]
  _not: tag_bool_exp
  _or: [tag_bool_exp!]
  category_id: uuid_comparison_exp
  id: uuid_comparison_exp
  label: String_comparison_exp
}

"""
unique or primary key constraints on table "tag"
"""
enum tag_constraint {
  """
  unique or primary key constraint
  """
  tags_pkey
}

"""
input type for inserting data into table "tag"
"""
input tag_insert_input {
  category_id: uuid
  id: uuid
  label: String
}

"""
aggregate max on columns
"""
type tag_max_fields {
  category_id: uuid
  id: uuid
  label: String
}

"""
aggregate min on columns
"""
type tag_min_fields {
  category_id: uuid
  id: uuid
  label: String
}

"""
response of any mutation on the table "tag"
"""
type tag_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [tag!]!
}

"""
on conflict condition type for table "tag"
"""
input tag_on_conflict {
  constraint: tag_constraint!
  update_columns: [tag_update_column!]!
  where: tag_bool_exp
}

"""
Ordering options when selecting data from "tag".
"""
input tag_order_by {
  category_id: order_by
  id: order_by
  label: order_by
}

"""
primary key columns input for table: tag
"""
input tag_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tag"
"""
enum tag_select_column {
  """
  column name
  """
  category_id

  """
  column name
  """
  id

  """
  column name
  """
  label
}

"""
input type for updating data in table "tag"
"""
input tag_set_input {
  category_id: uuid
  id: uuid
  label: String
}

"""
update columns of table "tag"
"""
enum tag_update_column {
  """
  column name
  """
  category_id

  """
  column name
  """
  id

  """
  column name
  """
  label
}

"""
columns and relationships of "user"
"""
type user {
  id: String!
  name: String
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  count(columns: [user_select_column!], distinct: Boolean): Int!
  max: user_max_fields
  min: user_min_fields
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  id: String_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """
  unique or primary key constraint
  """
  users_pkey
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  id: String
  name: String
}

"""
aggregate max on columns
"""
type user_max_fields {
  id: String
  name: String
}

"""
aggregate min on columns
"""
type user_min_fields {
  id: String
  name: String
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!

  """
  on conflict condition
  """
  on_conflict: user_on_conflict
}

"""
on conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]!
  where: user_bool_exp
}

"""
Ordering options when selecting data from "user".
"""
input user_order_by {
  id: order_by
  name: order_by
}

"""
primary key columns input for table: user
"""
input user_pk_columns_input {
  id: String!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  name
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  id: String
  name: String
}

"""
update columns of table "user"
"""
enum user_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  name
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}
