schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

"""
columns and relationships of "apps"
"""
type apps {
  id: uuid!
  name: String!

  """
  An array relationship
  """
  pages(
    """
    distinct select on columns
    """
    distinct_on: [pages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [pages_order_by!]

    """
    filter the rows returned
    """
    where: pages_bool_exp
  ): [pages!]!

  """
  An aggregate relationship
  """
  pages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [pages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [pages_order_by!]

    """
    filter the rows returned
    """
    where: pages_bool_exp
  ): pages_aggregate!

  """
  An object relationship
  """
  user: users!
  userId: String!
}

"""
aggregated selection of "apps"
"""
type apps_aggregate {
  aggregate: apps_aggregate_fields
  nodes: [apps!]!
}

"""
aggregate fields of "apps"
"""
type apps_aggregate_fields {
  count(columns: [apps_select_column!], distinct: Boolean): Int!
  max: apps_max_fields
  min: apps_min_fields
}

"""
order by aggregate values of table "apps"
"""
input apps_aggregate_order_by {
  count: order_by
  max: apps_max_order_by
  min: apps_min_order_by
}

"""
input type for inserting array relation for remote table "apps"
"""
input apps_arr_rel_insert_input {
  data: [apps_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: apps_on_conflict
}

"""
Boolean expression to filter rows from the table "apps". All fields are combined with a logical 'AND'.
"""
input apps_bool_exp {
  _and: [apps_bool_exp!]
  _not: apps_bool_exp
  _or: [apps_bool_exp!]
  id: uuid_comparison_exp
  name: String_comparison_exp
  pages: pages_bool_exp
  user: users_bool_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "apps"
"""
enum apps_constraint {
  """
  unique or primary key constraint
  """
  apps_pkey
}

"""
input type for inserting data into table "apps"
"""
input apps_insert_input {
  id: uuid
  name: String
  pages: pages_arr_rel_insert_input
  user: users_obj_rel_insert_input
  userId: String
}

"""
aggregate max on columns
"""
type apps_max_fields {
  id: uuid
  name: String
  userId: String
}

"""
order by max() on columns of table "apps"
"""
input apps_max_order_by {
  id: order_by
  name: order_by
  userId: order_by
}

"""
aggregate min on columns
"""
type apps_min_fields {
  id: uuid
  name: String
  userId: String
}

"""
order by min() on columns of table "apps"
"""
input apps_min_order_by {
  id: order_by
  name: order_by
  userId: order_by
}

"""
response of any mutation on the table "apps"
"""
type apps_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [apps!]!
}

"""
input type for inserting object relation for remote table "apps"
"""
input apps_obj_rel_insert_input {
  data: apps_insert_input!

  """
  on conflict condition
  """
  on_conflict: apps_on_conflict
}

"""
on conflict condition type for table "apps"
"""
input apps_on_conflict {
  constraint: apps_constraint!
  update_columns: [apps_update_column!]!
  where: apps_bool_exp
}

"""
Ordering options when selecting data from "apps".
"""
input apps_order_by {
  id: order_by
  name: order_by
  pages_aggregate: pages_aggregate_order_by
  user: users_order_by
  userId: order_by
}

"""
primary key columns input for table: apps
"""
input apps_pk_columns_input {
  id: uuid!
}

"""
select columns of table "apps"
"""
enum apps_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  userId
}

"""
input type for updating data in table "apps"
"""
input apps_set_input {
  id: uuid
  name: String
  userId: String
}

"""
update columns of table "apps"
"""
enum apps_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  userId
}

"""
columns and relationships of "atom_types"
"""
type atom_types {
  description: String
  value: String!
}

"""
aggregated selection of "atom_types"
"""
type atom_types_aggregate {
  aggregate: atom_types_aggregate_fields
  nodes: [atom_types!]!
}

"""
aggregate fields of "atom_types"
"""
type atom_types_aggregate_fields {
  count(columns: [atom_types_select_column!], distinct: Boolean): Int!
  max: atom_types_max_fields
  min: atom_types_min_fields
}

"""
Boolean expression to filter rows from the table "atom_types". All fields are combined with a logical 'AND'.
"""
input atom_types_bool_exp {
  _and: [atom_types_bool_exp!]
  _not: atom_types_bool_exp
  _or: [atom_types_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "atom_types"
"""
enum atom_types_constraint {
  """
  unique or primary key constraint
  """
  vertexType_pkey
}

"""
input type for inserting data into table "atom_types"
"""
input atom_types_insert_input {
  description: String
  value: String
}

"""
aggregate max on columns
"""
type atom_types_max_fields {
  description: String
  value: String
}

"""
aggregate min on columns
"""
type atom_types_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "atom_types"
"""
type atom_types_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [atom_types!]!
}

"""
input type for inserting object relation for remote table "atom_types"
"""
input atom_types_obj_rel_insert_input {
  data: atom_types_insert_input!

  """
  on conflict condition
  """
  on_conflict: atom_types_on_conflict
}

"""
on conflict condition type for table "atom_types"
"""
input atom_types_on_conflict {
  constraint: atom_types_constraint!
  update_columns: [atom_types_update_column!]!
  where: atom_types_bool_exp
}

"""
Ordering options when selecting data from "atom_types".
"""
input atom_types_order_by {
  description: order_by
  value: order_by
}

"""
primary key columns input for table: atom_types
"""
input atom_types_pk_columns_input {
  value: String!
}

"""
select columns of table "atom_types"
"""
enum atom_types_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

"""
input type for updating data in table "atom_types"
"""
input atom_types_set_input {
  description: String
  value: String
}

"""
update columns of table "atom_types"
"""
enum atom_types_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

"""
columns and relationships of "atoms"
"""
type atoms {
  """
  An object relationship
  """
  atomType: atom_types!

  """
  An object relationship
  """
  component: components!
  component_id: uuid!
  id: uuid!
  type: String!
}

"""
aggregated selection of "atoms"
"""
type atoms_aggregate {
  aggregate: atoms_aggregate_fields
  nodes: [atoms!]!
}

"""
aggregate fields of "atoms"
"""
type atoms_aggregate_fields {
  count(columns: [atoms_select_column!], distinct: Boolean): Int!
  max: atoms_max_fields
  min: atoms_min_fields
}

"""
order by aggregate values of table "atoms"
"""
input atoms_aggregate_order_by {
  count: order_by
  max: atoms_max_order_by
  min: atoms_min_order_by
}

"""
input type for inserting array relation for remote table "atoms"
"""
input atoms_arr_rel_insert_input {
  data: [atoms_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: atoms_on_conflict
}

"""
Boolean expression to filter rows from the table "atoms". All fields are combined with a logical 'AND'.
"""
input atoms_bool_exp {
  _and: [atoms_bool_exp!]
  _not: atoms_bool_exp
  _or: [atoms_bool_exp!]
  atomType: atom_types_bool_exp
  component: components_bool_exp
  component_id: uuid_comparison_exp
  id: uuid_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "atoms"
"""
enum atoms_constraint {
  """
  unique or primary key constraint
  """
  vertices_pkey
}

"""
input type for inserting data into table "atoms"
"""
input atoms_insert_input {
  atomType: atom_types_obj_rel_insert_input
  component: components_obj_rel_insert_input
  component_id: uuid
  id: uuid
  type: String
}

"""
aggregate max on columns
"""
type atoms_max_fields {
  component_id: uuid
  id: uuid
  type: String
}

"""
order by max() on columns of table "atoms"
"""
input atoms_max_order_by {
  component_id: order_by
  id: order_by
  type: order_by
}

"""
aggregate min on columns
"""
type atoms_min_fields {
  component_id: uuid
  id: uuid
  type: String
}

"""
order by min() on columns of table "atoms"
"""
input atoms_min_order_by {
  component_id: order_by
  id: order_by
  type: order_by
}

"""
response of any mutation on the table "atoms"
"""
type atoms_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [atoms!]!
}

"""
input type for inserting object relation for remote table "atoms"
"""
input atoms_obj_rel_insert_input {
  data: atoms_insert_input!

  """
  on conflict condition
  """
  on_conflict: atoms_on_conflict
}

"""
on conflict condition type for table "atoms"
"""
input atoms_on_conflict {
  constraint: atoms_constraint!
  update_columns: [atoms_update_column!]!
  where: atoms_bool_exp
}

"""
Ordering options when selecting data from "atoms".
"""
input atoms_order_by {
  atomType: atom_types_order_by
  component: components_order_by
  component_id: order_by
  id: order_by
  type: order_by
}

"""
primary key columns input for table: atoms
"""
input atoms_pk_columns_input {
  id: uuid!
}

"""
select columns of table "atoms"
"""
enum atoms_select_column {
  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  type
}

"""
input type for updating data in table "atoms"
"""
input atoms_set_input {
  component_id: uuid
  id: uuid
  type: String
}

"""
update columns of table "atoms"
"""
enum atoms_update_column {
  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  type
}

"""
columns and relationships of "attributes"
"""
type attributes {
  """
  An object relationship
  """
  atom_type: atom_types!
  id: uuid!
  key: String!
  type: String!
}

"""
aggregated selection of "attributes"
"""
type attributes_aggregate {
  aggregate: attributes_aggregate_fields
  nodes: [attributes!]!
}

"""
aggregate fields of "attributes"
"""
type attributes_aggregate_fields {
  count(columns: [attributes_select_column!], distinct: Boolean): Int!
  max: attributes_max_fields
  min: attributes_min_fields
}

"""
Boolean expression to filter rows from the table "attributes". All fields are combined with a logical 'AND'.
"""
input attributes_bool_exp {
  _and: [attributes_bool_exp!]
  _not: attributes_bool_exp
  _or: [attributes_bool_exp!]
  atom_type: atom_types_bool_exp
  id: uuid_comparison_exp
  key: String_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "attributes"
"""
enum attributes_constraint {
  """
  unique or primary key constraint
  """
  attributes_pkey
}

"""
input type for inserting data into table "attributes"
"""
input attributes_insert_input {
  atom_type: atom_types_obj_rel_insert_input
  id: uuid
  key: String
  type: String
}

"""
aggregate max on columns
"""
type attributes_max_fields {
  id: uuid
  key: String
  type: String
}

"""
aggregate min on columns
"""
type attributes_min_fields {
  id: uuid
  key: String
  type: String
}

"""
response of any mutation on the table "attributes"
"""
type attributes_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [attributes!]!
}

"""
on conflict condition type for table "attributes"
"""
input attributes_on_conflict {
  constraint: attributes_constraint!
  update_columns: [attributes_update_column!]!
  where: attributes_bool_exp
}

"""
Ordering options when selecting data from "attributes".
"""
input attributes_order_by {
  atom_type: atom_types_order_by
  id: order_by
  key: order_by
  type: order_by
}

"""
primary key columns input for table: attributes
"""
input attributes_pk_columns_input {
  id: uuid!
}

"""
select columns of table "attributes"
"""
enum attributes_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  key

  """
  column name
  """
  type
}

"""
input type for updating data in table "attributes"
"""
input attributes_set_input {
  id: uuid
  key: String
  type: String
}

"""
update columns of table "attributes"
"""
enum attributes_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  key

  """
  column name
  """
  type
}

"""
columns and relationships of "categories"
"""
type categories {
  id: uuid!

  """
  An array relationship
  """
  tags(
    """
    distinct select on columns
    """
    distinct_on: [tags_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tags_order_by!]

    """
    filter the rows returned
    """
    where: tags_bool_exp
  ): [tags!]!

  """
  An aggregate relationship
  """
  tags_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tags_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tags_order_by!]

    """
    filter the rows returned
    """
    where: tags_bool_exp
  ): tags_aggregate!
}

"""
aggregated selection of "categories"
"""
type categories_aggregate {
  aggregate: categories_aggregate_fields
  nodes: [categories!]!
}

"""
aggregate fields of "categories"
"""
type categories_aggregate_fields {
  count(columns: [categories_select_column!], distinct: Boolean): Int!
  max: categories_max_fields
  min: categories_min_fields
}

"""
Boolean expression to filter rows from the table "categories". All fields are combined with a logical 'AND'.
"""
input categories_bool_exp {
  _and: [categories_bool_exp!]
  _not: categories_bool_exp
  _or: [categories_bool_exp!]
  id: uuid_comparison_exp
  tags: tags_bool_exp
}

"""
unique or primary key constraints on table "categories"
"""
enum categories_constraint {
  """
  unique or primary key constraint
  """
  categories_pkey
}

"""
input type for inserting data into table "categories"
"""
input categories_insert_input {
  id: uuid
  tags: tags_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type categories_max_fields {
  id: uuid
}

"""
aggregate min on columns
"""
type categories_min_fields {
  id: uuid
}

"""
response of any mutation on the table "categories"
"""
type categories_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [categories!]!
}

"""
input type for inserting object relation for remote table "categories"
"""
input categories_obj_rel_insert_input {
  data: categories_insert_input!

  """
  on conflict condition
  """
  on_conflict: categories_on_conflict
}

"""
on conflict condition type for table "categories"
"""
input categories_on_conflict {
  constraint: categories_constraint!
  update_columns: [categories_update_column!]!
  where: categories_bool_exp
}

"""
Ordering options when selecting data from "categories".
"""
input categories_order_by {
  id: order_by
  tags_aggregate: tags_aggregate_order_by
}

"""
primary key columns input for table: categories
"""
input categories_pk_columns_input {
  id: uuid!
}

"""
select columns of table "categories"
"""
enum categories_select_column {
  """
  column name
  """
  id
}

"""
input type for updating data in table "categories"
"""
input categories_set_input {
  id: uuid
}

"""
update columns of table "categories"
"""
enum categories_update_column {
  """
  column name
  """
  id
}

"""
columns and relationships of "component_elements"
"""
type component_elements {
  """
  An object relationship
  """
  atom: atoms!
  atom_id: uuid!

  """
  An object relationship
  """
  component: components!
  componentId: uuid!
  id: uuid!
  label: String!

  """
  An array relationship
  """
  sourceLinks(
    """
    distinct select on columns
    """
    distinct_on: [component_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_links_order_by!]

    """
    filter the rows returned
    """
    where: component_links_bool_exp
  ): [component_links!]!

  """
  An aggregate relationship
  """
  sourceLinks_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_links_order_by!]

    """
    filter the rows returned
    """
    where: component_links_bool_exp
  ): component_links_aggregate!

  """
  An array relationship
  """
  targetLinks(
    """
    distinct select on columns
    """
    distinct_on: [component_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_links_order_by!]

    """
    filter the rows returned
    """
    where: component_links_bool_exp
  ): [component_links!]!

  """
  An aggregate relationship
  """
  targetLinks_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_links_order_by!]

    """
    filter the rows returned
    """
    where: component_links_bool_exp
  ): component_links_aggregate!
}

"""
aggregated selection of "component_elements"
"""
type component_elements_aggregate {
  aggregate: component_elements_aggregate_fields
  nodes: [component_elements!]!
}

"""
aggregate fields of "component_elements"
"""
type component_elements_aggregate_fields {
  count(columns: [component_elements_select_column!], distinct: Boolean): Int!
  max: component_elements_max_fields
  min: component_elements_min_fields
}

"""
order by aggregate values of table "component_elements"
"""
input component_elements_aggregate_order_by {
  count: order_by
  max: component_elements_max_order_by
  min: component_elements_min_order_by
}

"""
input type for inserting array relation for remote table "component_elements"
"""
input component_elements_arr_rel_insert_input {
  data: [component_elements_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: component_elements_on_conflict
}

"""
Boolean expression to filter rows from the table "component_elements". All fields are combined with a logical 'AND'.
"""
input component_elements_bool_exp {
  _and: [component_elements_bool_exp!]
  _not: component_elements_bool_exp
  _or: [component_elements_bool_exp!]
  atom: atoms_bool_exp
  atom_id: uuid_comparison_exp
  component: components_bool_exp
  componentId: uuid_comparison_exp
  id: uuid_comparison_exp
  label: String_comparison_exp
  sourceLinks: component_links_bool_exp
  targetLinks: component_links_bool_exp
}

"""
unique or primary key constraints on table "component_elements"
"""
enum component_elements_constraint {
  """
  unique or primary key constraint
  """
  component_elements_pkey
}

"""
input type for inserting data into table "component_elements"
"""
input component_elements_insert_input {
  atom: atoms_obj_rel_insert_input
  atom_id: uuid
  component: components_obj_rel_insert_input
  componentId: uuid
  id: uuid
  label: String
  sourceLinks: component_links_arr_rel_insert_input
  targetLinks: component_links_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type component_elements_max_fields {
  atom_id: uuid
  componentId: uuid
  id: uuid
  label: String
}

"""
order by max() on columns of table "component_elements"
"""
input component_elements_max_order_by {
  atom_id: order_by
  componentId: order_by
  id: order_by
  label: order_by
}

"""
aggregate min on columns
"""
type component_elements_min_fields {
  atom_id: uuid
  componentId: uuid
  id: uuid
  label: String
}

"""
order by min() on columns of table "component_elements"
"""
input component_elements_min_order_by {
  atom_id: order_by
  componentId: order_by
  id: order_by
  label: order_by
}

"""
response of any mutation on the table "component_elements"
"""
type component_elements_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [component_elements!]!
}

"""
input type for inserting object relation for remote table "component_elements"
"""
input component_elements_obj_rel_insert_input {
  data: component_elements_insert_input!

  """
  on conflict condition
  """
  on_conflict: component_elements_on_conflict
}

"""
on conflict condition type for table "component_elements"
"""
input component_elements_on_conflict {
  constraint: component_elements_constraint!
  update_columns: [component_elements_update_column!]!
  where: component_elements_bool_exp
}

"""
Ordering options when selecting data from "component_elements".
"""
input component_elements_order_by {
  atom: atoms_order_by
  atom_id: order_by
  component: components_order_by
  componentId: order_by
  id: order_by
  label: order_by
  sourceLinks_aggregate: component_links_aggregate_order_by
  targetLinks_aggregate: component_links_aggregate_order_by
}

"""
primary key columns input for table: component_elements
"""
input component_elements_pk_columns_input {
  id: uuid!
}

"""
select columns of table "component_elements"
"""
enum component_elements_select_column {
  """
  column name
  """
  atom_id

  """
  column name
  """
  componentId

  """
  column name
  """
  id

  """
  column name
  """
  label
}

"""
input type for updating data in table "component_elements"
"""
input component_elements_set_input {
  atom_id: uuid
  componentId: uuid
  id: uuid
  label: String
}

"""
update columns of table "component_elements"
"""
enum component_elements_update_column {
  """
  column name
  """
  atom_id

  """
  column name
  """
  componentId

  """
  column name
  """
  id

  """
  column name
  """
  label
}

"""
columns and relationships of "component_links"
"""
type component_links {
  """
  An object relationship
  """
  category: categories
  category_id: uuid

  """
  An object relationship
  """
  component: components!
  component_id: uuid!
  id: uuid!
  order: Int
  props(
    """
    JSON select path
    """
    path: String
  ): jsonb

  """
  An object relationship
  """
  sourceElement: component_elements!
  sourceElementId: uuid!

  """
  An object relationship
  """
  targetElement: component_elements
  targetElementId: uuid
}

"""
aggregated selection of "component_links"
"""
type component_links_aggregate {
  aggregate: component_links_aggregate_fields
  nodes: [component_links!]!
}

"""
aggregate fields of "component_links"
"""
type component_links_aggregate_fields {
  avg: component_links_avg_fields
  count(columns: [component_links_select_column!], distinct: Boolean): Int!
  max: component_links_max_fields
  min: component_links_min_fields
  stddev: component_links_stddev_fields
  stddev_pop: component_links_stddev_pop_fields
  stddev_samp: component_links_stddev_samp_fields
  sum: component_links_sum_fields
  var_pop: component_links_var_pop_fields
  var_samp: component_links_var_samp_fields
  variance: component_links_variance_fields
}

"""
order by aggregate values of table "component_links"
"""
input component_links_aggregate_order_by {
  avg: component_links_avg_order_by
  count: order_by
  max: component_links_max_order_by
  min: component_links_min_order_by
  stddev: component_links_stddev_order_by
  stddev_pop: component_links_stddev_pop_order_by
  stddev_samp: component_links_stddev_samp_order_by
  sum: component_links_sum_order_by
  var_pop: component_links_var_pop_order_by
  var_samp: component_links_var_samp_order_by
  variance: component_links_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input component_links_append_input {
  props: jsonb
}

"""
input type for inserting array relation for remote table "component_links"
"""
input component_links_arr_rel_insert_input {
  data: [component_links_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: component_links_on_conflict
}

"""
aggregate avg on columns
"""
type component_links_avg_fields {
  order: Float
}

"""
order by avg() on columns of table "component_links"
"""
input component_links_avg_order_by {
  order: order_by
}

"""
Boolean expression to filter rows from the table "component_links". All fields are combined with a logical 'AND'.
"""
input component_links_bool_exp {
  _and: [component_links_bool_exp!]
  _not: component_links_bool_exp
  _or: [component_links_bool_exp!]
  category: categories_bool_exp
  category_id: uuid_comparison_exp
  component: components_bool_exp
  component_id: uuid_comparison_exp
  id: uuid_comparison_exp
  order: Int_comparison_exp
  props: jsonb_comparison_exp
  sourceElement: component_elements_bool_exp
  sourceElementId: uuid_comparison_exp
  targetElement: component_elements_bool_exp
  targetElementId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "component_links"
"""
enum component_links_constraint {
  """
  unique or primary key constraint
  """
  vertex_edge_type_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input component_links_delete_at_path_input {
  props: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input component_links_delete_elem_input {
  props: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input component_links_delete_key_input {
  props: String
}

"""
input type for incrementing numeric columns in table "component_links"
"""
input component_links_inc_input {
  order: Int
}

"""
input type for inserting data into table "component_links"
"""
input component_links_insert_input {
  category: categories_obj_rel_insert_input
  category_id: uuid
  component: components_obj_rel_insert_input
  component_id: uuid
  id: uuid
  order: Int
  props: jsonb
  sourceElement: component_elements_obj_rel_insert_input
  sourceElementId: uuid
  targetElement: component_elements_obj_rel_insert_input
  targetElementId: uuid
}

"""
aggregate max on columns
"""
type component_links_max_fields {
  category_id: uuid
  component_id: uuid
  id: uuid
  order: Int
  sourceElementId: uuid
  targetElementId: uuid
}

"""
order by max() on columns of table "component_links"
"""
input component_links_max_order_by {
  category_id: order_by
  component_id: order_by
  id: order_by
  order: order_by
  sourceElementId: order_by
  targetElementId: order_by
}

"""
aggregate min on columns
"""
type component_links_min_fields {
  category_id: uuid
  component_id: uuid
  id: uuid
  order: Int
  sourceElementId: uuid
  targetElementId: uuid
}

"""
order by min() on columns of table "component_links"
"""
input component_links_min_order_by {
  category_id: order_by
  component_id: order_by
  id: order_by
  order: order_by
  sourceElementId: order_by
  targetElementId: order_by
}

"""
response of any mutation on the table "component_links"
"""
type component_links_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [component_links!]!
}

"""
on conflict condition type for table "component_links"
"""
input component_links_on_conflict {
  constraint: component_links_constraint!
  update_columns: [component_links_update_column!]!
  where: component_links_bool_exp
}

"""
Ordering options when selecting data from "component_links".
"""
input component_links_order_by {
  category: categories_order_by
  category_id: order_by
  component: components_order_by
  component_id: order_by
  id: order_by
  order: order_by
  props: order_by
  sourceElement: component_elements_order_by
  sourceElementId: order_by
  targetElement: component_elements_order_by
  targetElementId: order_by
}

"""
primary key columns input for table: component_links
"""
input component_links_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input component_links_prepend_input {
  props: jsonb
}

"""
select columns of table "component_links"
"""
enum component_links_select_column {
  """
  column name
  """
  category_id

  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  order

  """
  column name
  """
  props

  """
  column name
  """
  sourceElementId

  """
  column name
  """
  targetElementId
}

"""
input type for updating data in table "component_links"
"""
input component_links_set_input {
  category_id: uuid
  component_id: uuid
  id: uuid
  order: Int
  props: jsonb
  sourceElementId: uuid
  targetElementId: uuid
}

"""
aggregate stddev on columns
"""
type component_links_stddev_fields {
  order: Float
}

"""
order by stddev() on columns of table "component_links"
"""
input component_links_stddev_order_by {
  order: order_by
}

"""
aggregate stddev_pop on columns
"""
type component_links_stddev_pop_fields {
  order: Float
}

"""
order by stddev_pop() on columns of table "component_links"
"""
input component_links_stddev_pop_order_by {
  order: order_by
}

"""
aggregate stddev_samp on columns
"""
type component_links_stddev_samp_fields {
  order: Float
}

"""
order by stddev_samp() on columns of table "component_links"
"""
input component_links_stddev_samp_order_by {
  order: order_by
}

"""
aggregate sum on columns
"""
type component_links_sum_fields {
  order: Int
}

"""
order by sum() on columns of table "component_links"
"""
input component_links_sum_order_by {
  order: order_by
}

"""
update columns of table "component_links"
"""
enum component_links_update_column {
  """
  column name
  """
  category_id

  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  order

  """
  column name
  """
  props

  """
  column name
  """
  sourceElementId

  """
  column name
  """
  targetElementId
}

"""
aggregate var_pop on columns
"""
type component_links_var_pop_fields {
  order: Float
}

"""
order by var_pop() on columns of table "component_links"
"""
input component_links_var_pop_order_by {
  order: order_by
}

"""
aggregate var_samp on columns
"""
type component_links_var_samp_fields {
  order: Float
}

"""
order by var_samp() on columns of table "component_links"
"""
input component_links_var_samp_order_by {
  order: order_by
}

"""
aggregate variance on columns
"""
type component_links_variance_fields {
  order: Float
}

"""
order by variance() on columns of table "component_links"
"""
input component_links_variance_order_by {
  order: order_by
}

"""
columns and relationships of "components"
"""
type components {
  """
  fetch data from the table: "component_elements"
  """
  component_elements(
    """
    distinct select on columns
    """
    distinct_on: [component_elements_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_elements_order_by!]

    """
    filter the rows returned
    """
    where: component_elements_bool_exp
  ): [component_elements!]!

  """
  An aggregate relationship
  """
  component_elements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_elements_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_elements_order_by!]

    """
    filter the rows returned
    """
    where: component_elements_bool_exp
  ): component_elements_aggregate!

  """
  An array relationship
  """
  component_links(
    """
    distinct select on columns
    """
    distinct_on: [component_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_links_order_by!]

    """
    filter the rows returned
    """
    where: component_links_bool_exp
  ): [component_links!]!

  """
  An aggregate relationship
  """
  component_links_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_links_order_by!]

    """
    filter the rows returned
    """
    where: component_links_bool_exp
  ): component_links_aggregate!
  id: uuid!
  label: String!

  """
  An object relationship
  """
  library: libraries!
  libraryId: uuid!

  """
  An array relationship
  """
  vertices(
    """
    distinct select on columns
    """
    distinct_on: [atoms_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atoms_order_by!]

    """
    filter the rows returned
    """
    where: atoms_bool_exp
  ): [atoms!]!

  """
  An aggregate relationship
  """
  vertices_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [atoms_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atoms_order_by!]

    """
    filter the rows returned
    """
    where: atoms_bool_exp
  ): atoms_aggregate!
}

"""
aggregated selection of "components"
"""
type components_aggregate {
  aggregate: components_aggregate_fields
  nodes: [components!]!
}

"""
aggregate fields of "components"
"""
type components_aggregate_fields {
  count(columns: [components_select_column!], distinct: Boolean): Int!
  max: components_max_fields
  min: components_min_fields
}

"""
order by aggregate values of table "components"
"""
input components_aggregate_order_by {
  count: order_by
  max: components_max_order_by
  min: components_min_order_by
}

"""
input type for inserting array relation for remote table "components"
"""
input components_arr_rel_insert_input {
  data: [components_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: components_on_conflict
}

"""
Boolean expression to filter rows from the table "components". All fields are combined with a logical 'AND'.
"""
input components_bool_exp {
  _and: [components_bool_exp!]
  _not: components_bool_exp
  _or: [components_bool_exp!]
  component_elements: component_elements_bool_exp
  component_links: component_links_bool_exp
  id: uuid_comparison_exp
  label: String_comparison_exp
  library: libraries_bool_exp
  libraryId: uuid_comparison_exp
  vertices: atoms_bool_exp
}

"""
unique or primary key constraints on table "components"
"""
enum components_constraint {
  """
  unique or primary key constraint
  """
  components_pkey
}

"""
input type for inserting data into table "components"
"""
input components_insert_input {
  component_elements: component_elements_arr_rel_insert_input
  component_links: component_links_arr_rel_insert_input
  id: uuid
  label: String
  library: libraries_obj_rel_insert_input
  libraryId: uuid
  vertices: atoms_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type components_max_fields {
  id: uuid
  label: String
  libraryId: uuid
}

"""
order by max() on columns of table "components"
"""
input components_max_order_by {
  id: order_by
  label: order_by
  libraryId: order_by
}

"""
aggregate min on columns
"""
type components_min_fields {
  id: uuid
  label: String
  libraryId: uuid
}

"""
order by min() on columns of table "components"
"""
input components_min_order_by {
  id: order_by
  label: order_by
  libraryId: order_by
}

"""
response of any mutation on the table "components"
"""
type components_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [components!]!
}

"""
input type for inserting object relation for remote table "components"
"""
input components_obj_rel_insert_input {
  data: components_insert_input!

  """
  on conflict condition
  """
  on_conflict: components_on_conflict
}

"""
on conflict condition type for table "components"
"""
input components_on_conflict {
  constraint: components_constraint!
  update_columns: [components_update_column!]!
  where: components_bool_exp
}

"""
Ordering options when selecting data from "components".
"""
input components_order_by {
  component_elements_aggregate: component_elements_aggregate_order_by
  component_links_aggregate: component_links_aggregate_order_by
  id: order_by
  label: order_by
  library: libraries_order_by
  libraryId: order_by
  vertices_aggregate: atoms_aggregate_order_by
}

"""
primary key columns input for table: components
"""
input components_pk_columns_input {
  id: uuid!
}

"""
select columns of table "components"
"""
enum components_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  label

  """
  column name
  """
  libraryId
}

"""
input type for updating data in table "components"
"""
input components_set_input {
  id: uuid
  label: String
  libraryId: uuid
}

"""
update columns of table "components"
"""
enum components_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  label

  """
  column name
  """
  libraryId
}

scalar jsonb

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  """
  is the column contained in the given json value
  """
  _contained_in: jsonb

  """
  does the column contain the given json value at the top level
  """
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """
  does the string exist as a top-level key in the column
  """
  _has_key: String

  """
  do all of these strings exist as top-level keys in the column
  """
  _has_keys_all: [String!]

  """
  do any of these strings exist as top-level keys in the column
  """
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "lambdas"
"""
type lambdas {
  body: String!
  id: uuid!

  """
  An object relationship
  """
  library: libraries!
  libraryId: uuid!
  name: String!

  """
  An array relationship
  """
  prop_values(
    """
    distinct select on columns
    """
    distinct_on: [prop_values_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_values_order_by!]

    """
    filter the rows returned
    """
    where: prop_values_bool_exp
  ): [prop_values!]!

  """
  An aggregate relationship
  """
  prop_values_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_values_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_values_order_by!]

    """
    filter the rows returned
    """
    where: prop_values_bool_exp
  ): prop_values_aggregate!
}

"""
aggregated selection of "lambdas"
"""
type lambdas_aggregate {
  aggregate: lambdas_aggregate_fields
  nodes: [lambdas!]!
}

"""
aggregate fields of "lambdas"
"""
type lambdas_aggregate_fields {
  count(columns: [lambdas_select_column!], distinct: Boolean): Int!
  max: lambdas_max_fields
  min: lambdas_min_fields
}

"""
order by aggregate values of table "lambdas"
"""
input lambdas_aggregate_order_by {
  count: order_by
  max: lambdas_max_order_by
  min: lambdas_min_order_by
}

"""
input type for inserting array relation for remote table "lambdas"
"""
input lambdas_arr_rel_insert_input {
  data: [lambdas_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: lambdas_on_conflict
}

"""
Boolean expression to filter rows from the table "lambdas". All fields are combined with a logical 'AND'.
"""
input lambdas_bool_exp {
  _and: [lambdas_bool_exp!]
  _not: lambdas_bool_exp
  _or: [lambdas_bool_exp!]
  body: String_comparison_exp
  id: uuid_comparison_exp
  library: libraries_bool_exp
  libraryId: uuid_comparison_exp
  name: String_comparison_exp
  prop_values: prop_values_bool_exp
}

"""
unique or primary key constraints on table "lambdas"
"""
enum lambdas_constraint {
  """
  unique or primary key constraint
  """
  lambdas_pkey
}

"""
input type for inserting data into table "lambdas"
"""
input lambdas_insert_input {
  body: String
  id: uuid
  library: libraries_obj_rel_insert_input
  libraryId: uuid
  name: String
  prop_values: prop_values_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type lambdas_max_fields {
  body: String
  id: uuid
  libraryId: uuid
  name: String
}

"""
order by max() on columns of table "lambdas"
"""
input lambdas_max_order_by {
  body: order_by
  id: order_by
  libraryId: order_by
  name: order_by
}

"""
aggregate min on columns
"""
type lambdas_min_fields {
  body: String
  id: uuid
  libraryId: uuid
  name: String
}

"""
order by min() on columns of table "lambdas"
"""
input lambdas_min_order_by {
  body: order_by
  id: order_by
  libraryId: order_by
  name: order_by
}

"""
response of any mutation on the table "lambdas"
"""
type lambdas_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [lambdas!]!
}

"""
input type for inserting object relation for remote table "lambdas"
"""
input lambdas_obj_rel_insert_input {
  data: lambdas_insert_input!

  """
  on conflict condition
  """
  on_conflict: lambdas_on_conflict
}

"""
on conflict condition type for table "lambdas"
"""
input lambdas_on_conflict {
  constraint: lambdas_constraint!
  update_columns: [lambdas_update_column!]!
  where: lambdas_bool_exp
}

"""
Ordering options when selecting data from "lambdas".
"""
input lambdas_order_by {
  body: order_by
  id: order_by
  library: libraries_order_by
  libraryId: order_by
  name: order_by
  prop_values_aggregate: prop_values_aggregate_order_by
}

"""
primary key columns input for table: lambdas
"""
input lambdas_pk_columns_input {
  id: uuid!
}

"""
select columns of table "lambdas"
"""
enum lambdas_select_column {
  """
  column name
  """
  body

  """
  column name
  """
  id

  """
  column name
  """
  libraryId

  """
  column name
  """
  name
}

"""
input type for updating data in table "lambdas"
"""
input lambdas_set_input {
  body: String
  id: uuid
  libraryId: uuid
  name: String
}

"""
update columns of table "lambdas"
"""
enum lambdas_update_column {
  """
  column name
  """
  body

  """
  column name
  """
  id

  """
  column name
  """
  libraryId

  """
  column name
  """
  name
}

"""
columns and relationships of "libraries"
"""
type libraries {
  """
  An array relationship
  """
  components(
    """
    distinct select on columns
    """
    distinct_on: [components_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [components_order_by!]

    """
    filter the rows returned
    """
    where: components_bool_exp
  ): [components!]!

  """
  An aggregate relationship
  """
  components_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [components_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [components_order_by!]

    """
    filter the rows returned
    """
    where: components_bool_exp
  ): components_aggregate!
  id: uuid!

  """
  An array relationship
  """
  lambdas(
    """
    distinct select on columns
    """
    distinct_on: [lambdas_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [lambdas_order_by!]

    """
    filter the rows returned
    """
    where: lambdas_bool_exp
  ): [lambdas!]!

  """
  An aggregate relationship
  """
  lambdas_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [lambdas_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [lambdas_order_by!]

    """
    filter the rows returned
    """
    where: lambdas_bool_exp
  ): lambdas_aggregate!
  name: String

  """
  An array relationship
  """
  props(
    """
    distinct select on columns
    """
    distinct_on: [props_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [props_order_by!]

    """
    filter the rows returned
    """
    where: props_bool_exp
  ): [props!]!

  """
  An aggregate relationship
  """
  props_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [props_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [props_order_by!]

    """
    filter the rows returned
    """
    where: props_bool_exp
  ): props_aggregate!

  """
  An array relationship
  """
  styles(
    """
    distinct select on columns
    """
    distinct_on: [styles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [styles_order_by!]

    """
    filter the rows returned
    """
    where: styles_bool_exp
  ): [styles!]!

  """
  An aggregate relationship
  """
  styles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [styles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [styles_order_by!]

    """
    filter the rows returned
    """
    where: styles_bool_exp
  ): styles_aggregate!

  """
  An object relationship
  """
  user: users!
  userId: String!
}

"""
aggregated selection of "libraries"
"""
type libraries_aggregate {
  aggregate: libraries_aggregate_fields
  nodes: [libraries!]!
}

"""
aggregate fields of "libraries"
"""
type libraries_aggregate_fields {
  count(columns: [libraries_select_column!], distinct: Boolean): Int!
  max: libraries_max_fields
  min: libraries_min_fields
}

"""
order by aggregate values of table "libraries"
"""
input libraries_aggregate_order_by {
  count: order_by
  max: libraries_max_order_by
  min: libraries_min_order_by
}

"""
input type for inserting array relation for remote table "libraries"
"""
input libraries_arr_rel_insert_input {
  data: [libraries_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: libraries_on_conflict
}

"""
Boolean expression to filter rows from the table "libraries". All fields are combined with a logical 'AND'.
"""
input libraries_bool_exp {
  _and: [libraries_bool_exp!]
  _not: libraries_bool_exp
  _or: [libraries_bool_exp!]
  components: components_bool_exp
  id: uuid_comparison_exp
  lambdas: lambdas_bool_exp
  name: String_comparison_exp
  props: props_bool_exp
  styles: styles_bool_exp
  user: users_bool_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "libraries"
"""
enum libraries_constraint {
  """
  unique or primary key constraint
  """
  libraries_pkey
}

"""
input type for inserting data into table "libraries"
"""
input libraries_insert_input {
  components: components_arr_rel_insert_input
  id: uuid
  lambdas: lambdas_arr_rel_insert_input
  name: String
  props: props_arr_rel_insert_input
  styles: styles_arr_rel_insert_input
  user: users_obj_rel_insert_input
  userId: String
}

"""
aggregate max on columns
"""
type libraries_max_fields {
  id: uuid
  name: String
  userId: String
}

"""
order by max() on columns of table "libraries"
"""
input libraries_max_order_by {
  id: order_by
  name: order_by
  userId: order_by
}

"""
aggregate min on columns
"""
type libraries_min_fields {
  id: uuid
  name: String
  userId: String
}

"""
order by min() on columns of table "libraries"
"""
input libraries_min_order_by {
  id: order_by
  name: order_by
  userId: order_by
}

"""
response of any mutation on the table "libraries"
"""
type libraries_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [libraries!]!
}

"""
input type for inserting object relation for remote table "libraries"
"""
input libraries_obj_rel_insert_input {
  data: libraries_insert_input!

  """
  on conflict condition
  """
  on_conflict: libraries_on_conflict
}

"""
on conflict condition type for table "libraries"
"""
input libraries_on_conflict {
  constraint: libraries_constraint!
  update_columns: [libraries_update_column!]!
  where: libraries_bool_exp
}

"""
Ordering options when selecting data from "libraries".
"""
input libraries_order_by {
  components_aggregate: components_aggregate_order_by
  id: order_by
  lambdas_aggregate: lambdas_aggregate_order_by
  name: order_by
  props_aggregate: props_aggregate_order_by
  styles_aggregate: styles_aggregate_order_by
  user: users_order_by
  userId: order_by
}

"""
primary key columns input for table: libraries
"""
input libraries_pk_columns_input {
  id: uuid!
}

"""
select columns of table "libraries"
"""
enum libraries_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  userId
}

"""
input type for updating data in table "libraries"
"""
input libraries_set_input {
  id: uuid
  name: String
  userId: String
}

"""
update columns of table "libraries"
"""
enum libraries_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  userId
}

"""
mutation root
"""
type mutation_root {
  """
  delete data from the table: "apps"
  """
  delete_apps(
    """
    filter the rows which have to be deleted
    """
    where: apps_bool_exp!
  ): apps_mutation_response

  """
  delete single row from the table: "apps"
  """
  delete_apps_by_pk(id: uuid!): apps

  """
  delete data from the table: "atom_types"
  """
  delete_atom_types(
    """
    filter the rows which have to be deleted
    """
    where: atom_types_bool_exp!
  ): atom_types_mutation_response

  """
  delete single row from the table: "atom_types"
  """
  delete_atom_types_by_pk(value: String!): atom_types

  """
  delete data from the table: "atoms"
  """
  delete_atoms(
    """
    filter the rows which have to be deleted
    """
    where: atoms_bool_exp!
  ): atoms_mutation_response

  """
  delete single row from the table: "atoms"
  """
  delete_atoms_by_pk(id: uuid!): atoms

  """
  delete data from the table: "attributes"
  """
  delete_attributes(
    """
    filter the rows which have to be deleted
    """
    where: attributes_bool_exp!
  ): attributes_mutation_response

  """
  delete single row from the table: "attributes"
  """
  delete_attributes_by_pk(id: uuid!): attributes

  """
  delete data from the table: "categories"
  """
  delete_categories(
    """
    filter the rows which have to be deleted
    """
    where: categories_bool_exp!
  ): categories_mutation_response

  """
  delete single row from the table: "categories"
  """
  delete_categories_by_pk(id: uuid!): categories

  """
  delete data from the table: "component_elements"
  """
  delete_component_elements(
    """
    filter the rows which have to be deleted
    """
    where: component_elements_bool_exp!
  ): component_elements_mutation_response

  """
  delete single row from the table: "component_elements"
  """
  delete_component_elements_by_pk(id: uuid!): component_elements

  """
  delete data from the table: "component_links"
  """
  delete_component_links(
    """
    filter the rows which have to be deleted
    """
    where: component_links_bool_exp!
  ): component_links_mutation_response

  """
  delete single row from the table: "component_links"
  """
  delete_component_links_by_pk(id: uuid!): component_links

  """
  delete data from the table: "components"
  """
  delete_components(
    """
    filter the rows which have to be deleted
    """
    where: components_bool_exp!
  ): components_mutation_response

  """
  delete single row from the table: "components"
  """
  delete_components_by_pk(id: uuid!): components

  """
  delete data from the table: "lambdas"
  """
  delete_lambdas(
    """
    filter the rows which have to be deleted
    """
    where: lambdas_bool_exp!
  ): lambdas_mutation_response

  """
  delete single row from the table: "lambdas"
  """
  delete_lambdas_by_pk(id: uuid!): lambdas

  """
  delete data from the table: "libraries"
  """
  delete_libraries(
    """
    filter the rows which have to be deleted
    """
    where: libraries_bool_exp!
  ): libraries_mutation_response

  """
  delete single row from the table: "libraries"
  """
  delete_libraries_by_pk(id: uuid!): libraries

  """
  delete data from the table: "page_elements"
  """
  delete_page_elements(
    """
    filter the rows which have to be deleted
    """
    where: page_elements_bool_exp!
  ): page_elements_mutation_response

  """
  delete single row from the table: "page_elements"
  """
  delete_page_elements_by_pk(id: uuid!): page_elements

  """
  delete data from the table: "page_links"
  """
  delete_page_links(
    """
    filter the rows which have to be deleted
    """
    where: page_links_bool_exp!
  ): page_links_mutation_response

  """
  delete single row from the table: "page_links"
  """
  delete_page_links_by_pk(id: uuid!): page_links

  """
  delete data from the table: "pages"
  """
  delete_pages(
    """
    filter the rows which have to be deleted
    """
    where: pages_bool_exp!
  ): pages_mutation_response

  """
  delete single row from the table: "pages"
  """
  delete_pages_by_pk(id: uuid!): pages

  """
  delete data from the table: "prop_element"
  """
  delete_prop_element(
    """
    filter the rows which have to be deleted
    """
    where: prop_element_bool_exp!
  ): prop_element_mutation_response

  """
  delete single row from the table: "prop_element"
  """
  delete_prop_element_by_pk(element_id: uuid!, prop_id: uuid!): prop_element

  """
  delete data from the table: "prop_value_tag"
  """
  delete_prop_value_tag(
    """
    filter the rows which have to be deleted
    """
    where: prop_value_tag_bool_exp!
  ): prop_value_tag_mutation_response

  """
  delete single row from the table: "prop_value_tag"
  """
  delete_prop_value_tag_by_pk(
    prop_value_id: uuid!
    tag_id: uuid!
  ): prop_value_tag

  """
  delete data from the table: "prop_value_types"
  """
  delete_prop_value_types(
    """
    filter the rows which have to be deleted
    """
    where: prop_value_types_bool_exp!
  ): prop_value_types_mutation_response

  """
  delete single row from the table: "prop_value_types"
  """
  delete_prop_value_types_by_pk(value: String!): prop_value_types

  """
  delete data from the table: "prop_values"
  """
  delete_prop_values(
    """
    filter the rows which have to be deleted
    """
    where: prop_values_bool_exp!
  ): prop_values_mutation_response

  """
  delete single row from the table: "prop_values"
  """
  delete_prop_values_by_pk(id: uuid!): prop_values

  """
  delete data from the table: "props"
  """
  delete_props(
    """
    filter the rows which have to be deleted
    """
    where: props_bool_exp!
  ): props_mutation_response

  """
  delete single row from the table: "props"
  """
  delete_props_by_pk(id: uuid!): props

  """
  delete data from the table: "styles"
  """
  delete_styles(
    """
    filter the rows which have to be deleted
    """
    where: styles_bool_exp!
  ): styles_mutation_response

  """
  delete single row from the table: "styles"
  """
  delete_styles_by_pk(id: uuid!): styles

  """
  delete data from the table: "tags"
  """
  delete_tags(
    """
    filter the rows which have to be deleted
    """
    where: tags_bool_exp!
  ): tags_mutation_response

  """
  delete single row from the table: "tags"
  """
  delete_tags_by_pk(id: uuid!): tags

  """
  delete data from the table: "users"
  """
  delete_users(
    """
    filter the rows which have to be deleted
    """
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: String!): users

  """
  insert data into the table: "apps"
  """
  insert_apps(
    """
    the rows to be inserted
    """
    objects: [apps_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: apps_on_conflict
  ): apps_mutation_response

  """
  insert a single row into the table: "apps"
  """
  insert_apps_one(
    """
    the row to be inserted
    """
    object: apps_insert_input!

    """
    on conflict condition
    """
    on_conflict: apps_on_conflict
  ): apps

  """
  insert data into the table: "atom_types"
  """
  insert_atom_types(
    """
    the rows to be inserted
    """
    objects: [atom_types_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: atom_types_on_conflict
  ): atom_types_mutation_response

  """
  insert a single row into the table: "atom_types"
  """
  insert_atom_types_one(
    """
    the row to be inserted
    """
    object: atom_types_insert_input!

    """
    on conflict condition
    """
    on_conflict: atom_types_on_conflict
  ): atom_types

  """
  insert data into the table: "atoms"
  """
  insert_atoms(
    """
    the rows to be inserted
    """
    objects: [atoms_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: atoms_on_conflict
  ): atoms_mutation_response

  """
  insert a single row into the table: "atoms"
  """
  insert_atoms_one(
    """
    the row to be inserted
    """
    object: atoms_insert_input!

    """
    on conflict condition
    """
    on_conflict: atoms_on_conflict
  ): atoms

  """
  insert data into the table: "attributes"
  """
  insert_attributes(
    """
    the rows to be inserted
    """
    objects: [attributes_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: attributes_on_conflict
  ): attributes_mutation_response

  """
  insert a single row into the table: "attributes"
  """
  insert_attributes_one(
    """
    the row to be inserted
    """
    object: attributes_insert_input!

    """
    on conflict condition
    """
    on_conflict: attributes_on_conflict
  ): attributes

  """
  insert data into the table: "categories"
  """
  insert_categories(
    """
    the rows to be inserted
    """
    objects: [categories_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: categories_on_conflict
  ): categories_mutation_response

  """
  insert a single row into the table: "categories"
  """
  insert_categories_one(
    """
    the row to be inserted
    """
    object: categories_insert_input!

    """
    on conflict condition
    """
    on_conflict: categories_on_conflict
  ): categories

  """
  insert data into the table: "component_elements"
  """
  insert_component_elements(
    """
    the rows to be inserted
    """
    objects: [component_elements_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: component_elements_on_conflict
  ): component_elements_mutation_response

  """
  insert a single row into the table: "component_elements"
  """
  insert_component_elements_one(
    """
    the row to be inserted
    """
    object: component_elements_insert_input!

    """
    on conflict condition
    """
    on_conflict: component_elements_on_conflict
  ): component_elements

  """
  insert data into the table: "component_links"
  """
  insert_component_links(
    """
    the rows to be inserted
    """
    objects: [component_links_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: component_links_on_conflict
  ): component_links_mutation_response

  """
  insert a single row into the table: "component_links"
  """
  insert_component_links_one(
    """
    the row to be inserted
    """
    object: component_links_insert_input!

    """
    on conflict condition
    """
    on_conflict: component_links_on_conflict
  ): component_links

  """
  insert data into the table: "components"
  """
  insert_components(
    """
    the rows to be inserted
    """
    objects: [components_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: components_on_conflict
  ): components_mutation_response

  """
  insert a single row into the table: "components"
  """
  insert_components_one(
    """
    the row to be inserted
    """
    object: components_insert_input!

    """
    on conflict condition
    """
    on_conflict: components_on_conflict
  ): components

  """
  insert data into the table: "lambdas"
  """
  insert_lambdas(
    """
    the rows to be inserted
    """
    objects: [lambdas_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: lambdas_on_conflict
  ): lambdas_mutation_response

  """
  insert a single row into the table: "lambdas"
  """
  insert_lambdas_one(
    """
    the row to be inserted
    """
    object: lambdas_insert_input!

    """
    on conflict condition
    """
    on_conflict: lambdas_on_conflict
  ): lambdas

  """
  insert data into the table: "libraries"
  """
  insert_libraries(
    """
    the rows to be inserted
    """
    objects: [libraries_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: libraries_on_conflict
  ): libraries_mutation_response

  """
  insert a single row into the table: "libraries"
  """
  insert_libraries_one(
    """
    the row to be inserted
    """
    object: libraries_insert_input!

    """
    on conflict condition
    """
    on_conflict: libraries_on_conflict
  ): libraries

  """
  insert data into the table: "page_elements"
  """
  insert_page_elements(
    """
    the rows to be inserted
    """
    objects: [page_elements_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: page_elements_on_conflict
  ): page_elements_mutation_response

  """
  insert a single row into the table: "page_elements"
  """
  insert_page_elements_one(
    """
    the row to be inserted
    """
    object: page_elements_insert_input!

    """
    on conflict condition
    """
    on_conflict: page_elements_on_conflict
  ): page_elements

  """
  insert data into the table: "page_links"
  """
  insert_page_links(
    """
    the rows to be inserted
    """
    objects: [page_links_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: page_links_on_conflict
  ): page_links_mutation_response

  """
  insert a single row into the table: "page_links"
  """
  insert_page_links_one(
    """
    the row to be inserted
    """
    object: page_links_insert_input!

    """
    on conflict condition
    """
    on_conflict: page_links_on_conflict
  ): page_links

  """
  insert data into the table: "pages"
  """
  insert_pages(
    """
    the rows to be inserted
    """
    objects: [pages_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: pages_on_conflict
  ): pages_mutation_response

  """
  insert a single row into the table: "pages"
  """
  insert_pages_one(
    """
    the row to be inserted
    """
    object: pages_insert_input!

    """
    on conflict condition
    """
    on_conflict: pages_on_conflict
  ): pages

  """
  insert data into the table: "prop_element"
  """
  insert_prop_element(
    """
    the rows to be inserted
    """
    objects: [prop_element_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: prop_element_on_conflict
  ): prop_element_mutation_response

  """
  insert a single row into the table: "prop_element"
  """
  insert_prop_element_one(
    """
    the row to be inserted
    """
    object: prop_element_insert_input!

    """
    on conflict condition
    """
    on_conflict: prop_element_on_conflict
  ): prop_element

  """
  insert data into the table: "prop_value_tag"
  """
  insert_prop_value_tag(
    """
    the rows to be inserted
    """
    objects: [prop_value_tag_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: prop_value_tag_on_conflict
  ): prop_value_tag_mutation_response

  """
  insert a single row into the table: "prop_value_tag"
  """
  insert_prop_value_tag_one(
    """
    the row to be inserted
    """
    object: prop_value_tag_insert_input!

    """
    on conflict condition
    """
    on_conflict: prop_value_tag_on_conflict
  ): prop_value_tag

  """
  insert data into the table: "prop_value_types"
  """
  insert_prop_value_types(
    """
    the rows to be inserted
    """
    objects: [prop_value_types_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: prop_value_types_on_conflict
  ): prop_value_types_mutation_response

  """
  insert a single row into the table: "prop_value_types"
  """
  insert_prop_value_types_one(
    """
    the row to be inserted
    """
    object: prop_value_types_insert_input!

    """
    on conflict condition
    """
    on_conflict: prop_value_types_on_conflict
  ): prop_value_types

  """
  insert data into the table: "prop_values"
  """
  insert_prop_values(
    """
    the rows to be inserted
    """
    objects: [prop_values_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: prop_values_on_conflict
  ): prop_values_mutation_response

  """
  insert a single row into the table: "prop_values"
  """
  insert_prop_values_one(
    """
    the row to be inserted
    """
    object: prop_values_insert_input!

    """
    on conflict condition
    """
    on_conflict: prop_values_on_conflict
  ): prop_values

  """
  insert data into the table: "props"
  """
  insert_props(
    """
    the rows to be inserted
    """
    objects: [props_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: props_on_conflict
  ): props_mutation_response

  """
  insert a single row into the table: "props"
  """
  insert_props_one(
    """
    the row to be inserted
    """
    object: props_insert_input!

    """
    on conflict condition
    """
    on_conflict: props_on_conflict
  ): props

  """
  insert data into the table: "styles"
  """
  insert_styles(
    """
    the rows to be inserted
    """
    objects: [styles_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: styles_on_conflict
  ): styles_mutation_response

  """
  insert a single row into the table: "styles"
  """
  insert_styles_one(
    """
    the row to be inserted
    """
    object: styles_insert_input!

    """
    on conflict condition
    """
    on_conflict: styles_on_conflict
  ): styles

  """
  insert data into the table: "tags"
  """
  insert_tags(
    """
    the rows to be inserted
    """
    objects: [tags_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: tags_on_conflict
  ): tags_mutation_response

  """
  insert a single row into the table: "tags"
  """
  insert_tags_one(
    """
    the row to be inserted
    """
    object: tags_insert_input!

    """
    on conflict condition
    """
    on_conflict: tags_on_conflict
  ): tags

  """
  insert data into the table: "users"
  """
  insert_users(
    """
    the rows to be inserted
    """
    objects: [users_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """
    the row to be inserted
    """
    object: users_insert_input!

    """
    on conflict condition
    """
    on_conflict: users_on_conflict
  ): users

  """
  update data of the table: "apps"
  """
  update_apps(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: apps_set_input

    """
    filter the rows which have to be updated
    """
    where: apps_bool_exp!
  ): apps_mutation_response

  """
  update single row of the table: "apps"
  """
  update_apps_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: apps_set_input
    pk_columns: apps_pk_columns_input!
  ): apps

  """
  update data of the table: "atom_types"
  """
  update_atom_types(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: atom_types_set_input

    """
    filter the rows which have to be updated
    """
    where: atom_types_bool_exp!
  ): atom_types_mutation_response

  """
  update single row of the table: "atom_types"
  """
  update_atom_types_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: atom_types_set_input
    pk_columns: atom_types_pk_columns_input!
  ): atom_types

  """
  update data of the table: "atoms"
  """
  update_atoms(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: atoms_set_input

    """
    filter the rows which have to be updated
    """
    where: atoms_bool_exp!
  ): atoms_mutation_response

  """
  update single row of the table: "atoms"
  """
  update_atoms_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: atoms_set_input
    pk_columns: atoms_pk_columns_input!
  ): atoms

  """
  update data of the table: "attributes"
  """
  update_attributes(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: attributes_set_input

    """
    filter the rows which have to be updated
    """
    where: attributes_bool_exp!
  ): attributes_mutation_response

  """
  update single row of the table: "attributes"
  """
  update_attributes_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: attributes_set_input
    pk_columns: attributes_pk_columns_input!
  ): attributes

  """
  update data of the table: "categories"
  """
  update_categories(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: categories_set_input

    """
    filter the rows which have to be updated
    """
    where: categories_bool_exp!
  ): categories_mutation_response

  """
  update single row of the table: "categories"
  """
  update_categories_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: categories_set_input
    pk_columns: categories_pk_columns_input!
  ): categories

  """
  update data of the table: "component_elements"
  """
  update_component_elements(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: component_elements_set_input

    """
    filter the rows which have to be updated
    """
    where: component_elements_bool_exp!
  ): component_elements_mutation_response

  """
  update single row of the table: "component_elements"
  """
  update_component_elements_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: component_elements_set_input
    pk_columns: component_elements_pk_columns_input!
  ): component_elements

  """
  update data of the table: "component_links"
  """
  update_component_links(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: component_links_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: component_links_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: component_links_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: component_links_delete_key_input

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: component_links_inc_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: component_links_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: component_links_set_input

    """
    filter the rows which have to be updated
    """
    where: component_links_bool_exp!
  ): component_links_mutation_response

  """
  update single row of the table: "component_links"
  """
  update_component_links_by_pk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: component_links_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: component_links_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: component_links_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: component_links_delete_key_input

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: component_links_inc_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: component_links_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: component_links_set_input
    pk_columns: component_links_pk_columns_input!
  ): component_links

  """
  update data of the table: "components"
  """
  update_components(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: components_set_input

    """
    filter the rows which have to be updated
    """
    where: components_bool_exp!
  ): components_mutation_response

  """
  update single row of the table: "components"
  """
  update_components_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: components_set_input
    pk_columns: components_pk_columns_input!
  ): components

  """
  update data of the table: "lambdas"
  """
  update_lambdas(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: lambdas_set_input

    """
    filter the rows which have to be updated
    """
    where: lambdas_bool_exp!
  ): lambdas_mutation_response

  """
  update single row of the table: "lambdas"
  """
  update_lambdas_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: lambdas_set_input
    pk_columns: lambdas_pk_columns_input!
  ): lambdas

  """
  update data of the table: "libraries"
  """
  update_libraries(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: libraries_set_input

    """
    filter the rows which have to be updated
    """
    where: libraries_bool_exp!
  ): libraries_mutation_response

  """
  update single row of the table: "libraries"
  """
  update_libraries_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: libraries_set_input
    pk_columns: libraries_pk_columns_input!
  ): libraries

  """
  update data of the table: "page_elements"
  """
  update_page_elements(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_elements_set_input

    """
    filter the rows which have to be updated
    """
    where: page_elements_bool_exp!
  ): page_elements_mutation_response

  """
  update single row of the table: "page_elements"
  """
  update_page_elements_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_elements_set_input
    pk_columns: page_elements_pk_columns_input!
  ): page_elements

  """
  update data of the table: "page_links"
  """
  update_page_links(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: page_links_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: page_links_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: page_links_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: page_links_delete_key_input

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: page_links_inc_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: page_links_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_links_set_input

    """
    filter the rows which have to be updated
    """
    where: page_links_bool_exp!
  ): page_links_mutation_response

  """
  update single row of the table: "page_links"
  """
  update_page_links_by_pk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: page_links_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: page_links_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: page_links_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: page_links_delete_key_input

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: page_links_inc_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: page_links_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_links_set_input
    pk_columns: page_links_pk_columns_input!
  ): page_links

  """
  update data of the table: "pages"
  """
  update_pages(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: pages_set_input

    """
    filter the rows which have to be updated
    """
    where: pages_bool_exp!
  ): pages_mutation_response

  """
  update single row of the table: "pages"
  """
  update_pages_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: pages_set_input
    pk_columns: pages_pk_columns_input!
  ): pages

  """
  update data of the table: "prop_element"
  """
  update_prop_element(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_element_set_input

    """
    filter the rows which have to be updated
    """
    where: prop_element_bool_exp!
  ): prop_element_mutation_response

  """
  update single row of the table: "prop_element"
  """
  update_prop_element_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_element_set_input
    pk_columns: prop_element_pk_columns_input!
  ): prop_element

  """
  update data of the table: "prop_value_tag"
  """
  update_prop_value_tag(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_value_tag_set_input

    """
    filter the rows which have to be updated
    """
    where: prop_value_tag_bool_exp!
  ): prop_value_tag_mutation_response

  """
  update single row of the table: "prop_value_tag"
  """
  update_prop_value_tag_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_value_tag_set_input
    pk_columns: prop_value_tag_pk_columns_input!
  ): prop_value_tag

  """
  update data of the table: "prop_value_types"
  """
  update_prop_value_types(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_value_types_set_input

    """
    filter the rows which have to be updated
    """
    where: prop_value_types_bool_exp!
  ): prop_value_types_mutation_response

  """
  update single row of the table: "prop_value_types"
  """
  update_prop_value_types_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_value_types_set_input
    pk_columns: prop_value_types_pk_columns_input!
  ): prop_value_types

  """
  update data of the table: "prop_values"
  """
  update_prop_values(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_values_set_input

    """
    filter the rows which have to be updated
    """
    where: prop_values_bool_exp!
  ): prop_values_mutation_response

  """
  update single row of the table: "prop_values"
  """
  update_prop_values_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_values_set_input
    pk_columns: prop_values_pk_columns_input!
  ): prop_values

  """
  update data of the table: "props"
  """
  update_props(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: props_set_input

    """
    filter the rows which have to be updated
    """
    where: props_bool_exp!
  ): props_mutation_response

  """
  update single row of the table: "props"
  """
  update_props_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: props_set_input
    pk_columns: props_pk_columns_input!
  ): props

  """
  update data of the table: "styles"
  """
  update_styles(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: styles_set_input

    """
    filter the rows which have to be updated
    """
    where: styles_bool_exp!
  ): styles_mutation_response

  """
  update single row of the table: "styles"
  """
  update_styles_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: styles_set_input
    pk_columns: styles_pk_columns_input!
  ): styles

  """
  update data of the table: "tags"
  """
  update_tags(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tags_set_input

    """
    filter the rows which have to be updated
    """
    where: tags_bool_exp!
  ): tags_mutation_response

  """
  update single row of the table: "tags"
  """
  update_tags_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tags_set_input
    pk_columns: tags_pk_columns_input!
  ): tags

  """
  update data of the table: "users"
  """
  update_users(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: users_set_input

    """
    filter the rows which have to be updated
    """
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc

  """
  in ascending order, nulls first
  """
  asc_nulls_first

  """
  in ascending order, nulls last
  """
  asc_nulls_last

  """
  in descending order, nulls first
  """
  desc

  """
  in descending order, nulls first
  """
  desc_nulls_first

  """
  in descending order, nulls last
  """
  desc_nulls_last
}

"""
columns and relationships of "page_elements"
"""
type page_elements {
  """
  An object relationship
  """
  component: components!
  componentId: uuid!
  id: uuid!
  name: String

  """
  An object relationship
  """
  page: pages!
  pageId: uuid!

  """
  An array relationship
  """
  props(
    """
    distinct select on columns
    """
    distinct_on: [prop_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_element_order_by!]

    """
    filter the rows returned
    """
    where: prop_element_bool_exp
  ): [prop_element!]!

  """
  An aggregate relationship
  """
  props_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_element_order_by!]

    """
    filter the rows returned
    """
    where: prop_element_bool_exp
  ): prop_element_aggregate!
}

"""
aggregated selection of "page_elements"
"""
type page_elements_aggregate {
  aggregate: page_elements_aggregate_fields
  nodes: [page_elements!]!
}

"""
aggregate fields of "page_elements"
"""
type page_elements_aggregate_fields {
  count(columns: [page_elements_select_column!], distinct: Boolean): Int!
  max: page_elements_max_fields
  min: page_elements_min_fields
}

"""
order by aggregate values of table "page_elements"
"""
input page_elements_aggregate_order_by {
  count: order_by
  max: page_elements_max_order_by
  min: page_elements_min_order_by
}

"""
input type for inserting array relation for remote table "page_elements"
"""
input page_elements_arr_rel_insert_input {
  data: [page_elements_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: page_elements_on_conflict
}

"""
Boolean expression to filter rows from the table "page_elements". All fields are combined with a logical 'AND'.
"""
input page_elements_bool_exp {
  _and: [page_elements_bool_exp!]
  _not: page_elements_bool_exp
  _or: [page_elements_bool_exp!]
  component: components_bool_exp
  componentId: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  page: pages_bool_exp
  pageId: uuid_comparison_exp
  props: prop_element_bool_exp
}

"""
unique or primary key constraints on table "page_elements"
"""
enum page_elements_constraint {
  """
  unique or primary key constraint
  """
  elements_pkey
}

"""
input type for inserting data into table "page_elements"
"""
input page_elements_insert_input {
  component: components_obj_rel_insert_input
  componentId: uuid
  id: uuid
  name: String
  page: pages_obj_rel_insert_input
  pageId: uuid
  props: prop_element_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type page_elements_max_fields {
  componentId: uuid
  id: uuid
  name: String
  pageId: uuid
}

"""
order by max() on columns of table "page_elements"
"""
input page_elements_max_order_by {
  componentId: order_by
  id: order_by
  name: order_by
  pageId: order_by
}

"""
aggregate min on columns
"""
type page_elements_min_fields {
  componentId: uuid
  id: uuid
  name: String
  pageId: uuid
}

"""
order by min() on columns of table "page_elements"
"""
input page_elements_min_order_by {
  componentId: order_by
  id: order_by
  name: order_by
  pageId: order_by
}

"""
response of any mutation on the table "page_elements"
"""
type page_elements_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [page_elements!]!
}

"""
input type for inserting object relation for remote table "page_elements"
"""
input page_elements_obj_rel_insert_input {
  data: page_elements_insert_input!

  """
  on conflict condition
  """
  on_conflict: page_elements_on_conflict
}

"""
on conflict condition type for table "page_elements"
"""
input page_elements_on_conflict {
  constraint: page_elements_constraint!
  update_columns: [page_elements_update_column!]!
  where: page_elements_bool_exp
}

"""
Ordering options when selecting data from "page_elements".
"""
input page_elements_order_by {
  component: components_order_by
  componentId: order_by
  id: order_by
  name: order_by
  page: pages_order_by
  pageId: order_by
  props_aggregate: prop_element_aggregate_order_by
}

"""
primary key columns input for table: page_elements
"""
input page_elements_pk_columns_input {
  id: uuid!
}

"""
select columns of table "page_elements"
"""
enum page_elements_select_column {
  """
  column name
  """
  componentId

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  pageId
}

"""
input type for updating data in table "page_elements"
"""
input page_elements_set_input {
  componentId: uuid
  id: uuid
  name: String
  pageId: uuid
}

"""
update columns of table "page_elements"
"""
enum page_elements_update_column {
  """
  column name
  """
  componentId

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  pageId
}

"""
columns and relationships of "page_links"
"""
type page_links {
  id: uuid!
  order: Int

  """
  An object relationship
  """
  page: pages!
  pageId: uuid!
  props(
    """
    JSON select path
    """
    path: String
  ): jsonb

  """
  An object relationship
  """
  sourceElement: page_elements!
  source_element_id: uuid!

  """
  An object relationship
  """
  targetElement: page_elements!
  target_element_id: uuid!
}

"""
aggregated selection of "page_links"
"""
type page_links_aggregate {
  aggregate: page_links_aggregate_fields
  nodes: [page_links!]!
}

"""
aggregate fields of "page_links"
"""
type page_links_aggregate_fields {
  avg: page_links_avg_fields
  count(columns: [page_links_select_column!], distinct: Boolean): Int!
  max: page_links_max_fields
  min: page_links_min_fields
  stddev: page_links_stddev_fields
  stddev_pop: page_links_stddev_pop_fields
  stddev_samp: page_links_stddev_samp_fields
  sum: page_links_sum_fields
  var_pop: page_links_var_pop_fields
  var_samp: page_links_var_samp_fields
  variance: page_links_variance_fields
}

"""
order by aggregate values of table "page_links"
"""
input page_links_aggregate_order_by {
  avg: page_links_avg_order_by
  count: order_by
  max: page_links_max_order_by
  min: page_links_min_order_by
  stddev: page_links_stddev_order_by
  stddev_pop: page_links_stddev_pop_order_by
  stddev_samp: page_links_stddev_samp_order_by
  sum: page_links_sum_order_by
  var_pop: page_links_var_pop_order_by
  var_samp: page_links_var_samp_order_by
  variance: page_links_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input page_links_append_input {
  props: jsonb
}

"""
input type for inserting array relation for remote table "page_links"
"""
input page_links_arr_rel_insert_input {
  data: [page_links_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: page_links_on_conflict
}

"""
aggregate avg on columns
"""
type page_links_avg_fields {
  order: Float
}

"""
order by avg() on columns of table "page_links"
"""
input page_links_avg_order_by {
  order: order_by
}

"""
Boolean expression to filter rows from the table "page_links". All fields are combined with a logical 'AND'.
"""
input page_links_bool_exp {
  _and: [page_links_bool_exp!]
  _not: page_links_bool_exp
  _or: [page_links_bool_exp!]
  id: uuid_comparison_exp
  order: Int_comparison_exp
  page: pages_bool_exp
  pageId: uuid_comparison_exp
  props: jsonb_comparison_exp
  sourceElement: page_elements_bool_exp
  source_element_id: uuid_comparison_exp
  targetElement: page_elements_bool_exp
  target_element_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "page_links"
"""
enum page_links_constraint {
  """
  unique or primary key constraint
  """
  page_links_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input page_links_delete_at_path_input {
  props: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input page_links_delete_elem_input {
  props: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input page_links_delete_key_input {
  props: String
}

"""
input type for incrementing numeric columns in table "page_links"
"""
input page_links_inc_input {
  order: Int
}

"""
input type for inserting data into table "page_links"
"""
input page_links_insert_input {
  id: uuid
  order: Int
  page: pages_obj_rel_insert_input
  pageId: uuid
  props: jsonb
  sourceElement: page_elements_obj_rel_insert_input
  source_element_id: uuid
  targetElement: page_elements_obj_rel_insert_input
  target_element_id: uuid
}

"""
aggregate max on columns
"""
type page_links_max_fields {
  id: uuid
  order: Int
  pageId: uuid
  source_element_id: uuid
  target_element_id: uuid
}

"""
order by max() on columns of table "page_links"
"""
input page_links_max_order_by {
  id: order_by
  order: order_by
  pageId: order_by
  source_element_id: order_by
  target_element_id: order_by
}

"""
aggregate min on columns
"""
type page_links_min_fields {
  id: uuid
  order: Int
  pageId: uuid
  source_element_id: uuid
  target_element_id: uuid
}

"""
order by min() on columns of table "page_links"
"""
input page_links_min_order_by {
  id: order_by
  order: order_by
  pageId: order_by
  source_element_id: order_by
  target_element_id: order_by
}

"""
response of any mutation on the table "page_links"
"""
type page_links_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [page_links!]!
}

"""
on conflict condition type for table "page_links"
"""
input page_links_on_conflict {
  constraint: page_links_constraint!
  update_columns: [page_links_update_column!]!
  where: page_links_bool_exp
}

"""
Ordering options when selecting data from "page_links".
"""
input page_links_order_by {
  id: order_by
  order: order_by
  page: pages_order_by
  pageId: order_by
  props: order_by
  sourceElement: page_elements_order_by
  source_element_id: order_by
  targetElement: page_elements_order_by
  target_element_id: order_by
}

"""
primary key columns input for table: page_links
"""
input page_links_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input page_links_prepend_input {
  props: jsonb
}

"""
select columns of table "page_links"
"""
enum page_links_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  order

  """
  column name
  """
  pageId

  """
  column name
  """
  props

  """
  column name
  """
  source_element_id

  """
  column name
  """
  target_element_id
}

"""
input type for updating data in table "page_links"
"""
input page_links_set_input {
  id: uuid
  order: Int
  pageId: uuid
  props: jsonb
  source_element_id: uuid
  target_element_id: uuid
}

"""
aggregate stddev on columns
"""
type page_links_stddev_fields {
  order: Float
}

"""
order by stddev() on columns of table "page_links"
"""
input page_links_stddev_order_by {
  order: order_by
}

"""
aggregate stddev_pop on columns
"""
type page_links_stddev_pop_fields {
  order: Float
}

"""
order by stddev_pop() on columns of table "page_links"
"""
input page_links_stddev_pop_order_by {
  order: order_by
}

"""
aggregate stddev_samp on columns
"""
type page_links_stddev_samp_fields {
  order: Float
}

"""
order by stddev_samp() on columns of table "page_links"
"""
input page_links_stddev_samp_order_by {
  order: order_by
}

"""
aggregate sum on columns
"""
type page_links_sum_fields {
  order: Int
}

"""
order by sum() on columns of table "page_links"
"""
input page_links_sum_order_by {
  order: order_by
}

"""
update columns of table "page_links"
"""
enum page_links_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  order

  """
  column name
  """
  pageId

  """
  column name
  """
  props

  """
  column name
  """
  source_element_id

  """
  column name
  """
  target_element_id
}

"""
aggregate var_pop on columns
"""
type page_links_var_pop_fields {
  order: Float
}

"""
order by var_pop() on columns of table "page_links"
"""
input page_links_var_pop_order_by {
  order: order_by
}

"""
aggregate var_samp on columns
"""
type page_links_var_samp_fields {
  order: Float
}

"""
order by var_samp() on columns of table "page_links"
"""
input page_links_var_samp_order_by {
  order: order_by
}

"""
aggregate variance on columns
"""
type page_links_variance_fields {
  order: Float
}

"""
order by variance() on columns of table "page_links"
"""
input page_links_variance_order_by {
  order: order_by
}

"""
columns and relationships of "pages"
"""
type pages {
  """
  An object relationship
  """
  app: apps!
  appId: uuid!

  """
  An array relationship
  """
  elements(
    """
    distinct select on columns
    """
    distinct_on: [page_elements_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_elements_order_by!]

    """
    filter the rows returned
    """
    where: page_elements_bool_exp
  ): [page_elements!]!

  """
  An aggregate relationship
  """
  elements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_elements_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_elements_order_by!]

    """
    filter the rows returned
    """
    where: page_elements_bool_exp
  ): page_elements_aggregate!
  id: uuid!
  name: String!

  """
  An object relationship
  """
  owner: users!
  ownerId: String!

  """
  An array relationship
  """
  page_links(
    """
    distinct select on columns
    """
    distinct_on: [page_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_links_order_by!]

    """
    filter the rows returned
    """
    where: page_links_bool_exp
  ): [page_links!]!

  """
  An aggregate relationship
  """
  page_links_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_links_order_by!]

    """
    filter the rows returned
    """
    where: page_links_bool_exp
  ): page_links_aggregate!
}

"""
aggregated selection of "pages"
"""
type pages_aggregate {
  aggregate: pages_aggregate_fields
  nodes: [pages!]!
}

"""
aggregate fields of "pages"
"""
type pages_aggregate_fields {
  count(columns: [pages_select_column!], distinct: Boolean): Int!
  max: pages_max_fields
  min: pages_min_fields
}

"""
order by aggregate values of table "pages"
"""
input pages_aggregate_order_by {
  count: order_by
  max: pages_max_order_by
  min: pages_min_order_by
}

"""
input type for inserting array relation for remote table "pages"
"""
input pages_arr_rel_insert_input {
  data: [pages_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: pages_on_conflict
}

"""
Boolean expression to filter rows from the table "pages". All fields are combined with a logical 'AND'.
"""
input pages_bool_exp {
  _and: [pages_bool_exp!]
  _not: pages_bool_exp
  _or: [pages_bool_exp!]
  app: apps_bool_exp
  appId: uuid_comparison_exp
  elements: page_elements_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  owner: users_bool_exp
  ownerId: String_comparison_exp
  page_links: page_links_bool_exp
}

"""
unique or primary key constraints on table "pages"
"""
enum pages_constraint {
  """
  unique or primary key constraint
  """
  pages_pkey
}

"""
input type for inserting data into table "pages"
"""
input pages_insert_input {
  app: apps_obj_rel_insert_input
  appId: uuid
  elements: page_elements_arr_rel_insert_input
  id: uuid
  name: String
  owner: users_obj_rel_insert_input
  ownerId: String
  page_links: page_links_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type pages_max_fields {
  appId: uuid
  id: uuid
  name: String
  ownerId: String
}

"""
order by max() on columns of table "pages"
"""
input pages_max_order_by {
  appId: order_by
  id: order_by
  name: order_by
  ownerId: order_by
}

"""
aggregate min on columns
"""
type pages_min_fields {
  appId: uuid
  id: uuid
  name: String
  ownerId: String
}

"""
order by min() on columns of table "pages"
"""
input pages_min_order_by {
  appId: order_by
  id: order_by
  name: order_by
  ownerId: order_by
}

"""
response of any mutation on the table "pages"
"""
type pages_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [pages!]!
}

"""
input type for inserting object relation for remote table "pages"
"""
input pages_obj_rel_insert_input {
  data: pages_insert_input!

  """
  on conflict condition
  """
  on_conflict: pages_on_conflict
}

"""
on conflict condition type for table "pages"
"""
input pages_on_conflict {
  constraint: pages_constraint!
  update_columns: [pages_update_column!]!
  where: pages_bool_exp
}

"""
Ordering options when selecting data from "pages".
"""
input pages_order_by {
  app: apps_order_by
  appId: order_by
  elements_aggregate: page_elements_aggregate_order_by
  id: order_by
  name: order_by
  owner: users_order_by
  ownerId: order_by
  page_links_aggregate: page_links_aggregate_order_by
}

"""
primary key columns input for table: pages
"""
input pages_pk_columns_input {
  id: uuid!
}

"""
select columns of table "pages"
"""
enum pages_select_column {
  """
  column name
  """
  appId

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  ownerId
}

"""
input type for updating data in table "pages"
"""
input pages_set_input {
  appId: uuid
  id: uuid
  name: String
  ownerId: String
}

"""
update columns of table "pages"
"""
enum pages_update_column {
  """
  column name
  """
  appId

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  ownerId
}

"""
columns and relationships of "prop_element"
"""
type prop_element {
  """
  An object relationship
  """
  element: page_elements!
  element_id: uuid!

  """
  An object relationship
  """
  prop: props!
  prop_id: uuid!
}

"""
aggregated selection of "prop_element"
"""
type prop_element_aggregate {
  aggregate: prop_element_aggregate_fields
  nodes: [prop_element!]!
}

"""
aggregate fields of "prop_element"
"""
type prop_element_aggregate_fields {
  count(columns: [prop_element_select_column!], distinct: Boolean): Int!
  max: prop_element_max_fields
  min: prop_element_min_fields
}

"""
order by aggregate values of table "prop_element"
"""
input prop_element_aggregate_order_by {
  count: order_by
  max: prop_element_max_order_by
  min: prop_element_min_order_by
}

"""
input type for inserting array relation for remote table "prop_element"
"""
input prop_element_arr_rel_insert_input {
  data: [prop_element_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: prop_element_on_conflict
}

"""
Boolean expression to filter rows from the table "prop_element". All fields are combined with a logical 'AND'.
"""
input prop_element_bool_exp {
  _and: [prop_element_bool_exp!]
  _not: prop_element_bool_exp
  _or: [prop_element_bool_exp!]
  element: page_elements_bool_exp
  element_id: uuid_comparison_exp
  prop: props_bool_exp
  prop_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "prop_element"
"""
enum prop_element_constraint {
  """
  unique or primary key constraint
  """
  prop_element_pkey
}

"""
input type for inserting data into table "prop_element"
"""
input prop_element_insert_input {
  element: page_elements_obj_rel_insert_input
  element_id: uuid
  prop: props_obj_rel_insert_input
  prop_id: uuid
}

"""
aggregate max on columns
"""
type prop_element_max_fields {
  element_id: uuid
  prop_id: uuid
}

"""
order by max() on columns of table "prop_element"
"""
input prop_element_max_order_by {
  element_id: order_by
  prop_id: order_by
}

"""
aggregate min on columns
"""
type prop_element_min_fields {
  element_id: uuid
  prop_id: uuid
}

"""
order by min() on columns of table "prop_element"
"""
input prop_element_min_order_by {
  element_id: order_by
  prop_id: order_by
}

"""
response of any mutation on the table "prop_element"
"""
type prop_element_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [prop_element!]!
}

"""
on conflict condition type for table "prop_element"
"""
input prop_element_on_conflict {
  constraint: prop_element_constraint!
  update_columns: [prop_element_update_column!]!
  where: prop_element_bool_exp
}

"""
Ordering options when selecting data from "prop_element".
"""
input prop_element_order_by {
  element: page_elements_order_by
  element_id: order_by
  prop: props_order_by
  prop_id: order_by
}

"""
primary key columns input for table: prop_element
"""
input prop_element_pk_columns_input {
  element_id: uuid!
  prop_id: uuid!
}

"""
select columns of table "prop_element"
"""
enum prop_element_select_column {
  """
  column name
  """
  element_id

  """
  column name
  """
  prop_id
}

"""
input type for updating data in table "prop_element"
"""
input prop_element_set_input {
  element_id: uuid
  prop_id: uuid
}

"""
update columns of table "prop_element"
"""
enum prop_element_update_column {
  """
  column name
  """
  element_id

  """
  column name
  """
  prop_id
}

"""
columns and relationships of "prop_value_tag"
"""
type prop_value_tag {
  """
  An object relationship
  """
  prop_value: prop_values!
  prop_value_id: uuid!

  """
  An object relationship
  """
  tag: tags!
  tag_id: uuid!
}

"""
aggregated selection of "prop_value_tag"
"""
type prop_value_tag_aggregate {
  aggregate: prop_value_tag_aggregate_fields
  nodes: [prop_value_tag!]!
}

"""
aggregate fields of "prop_value_tag"
"""
type prop_value_tag_aggregate_fields {
  count(columns: [prop_value_tag_select_column!], distinct: Boolean): Int!
  max: prop_value_tag_max_fields
  min: prop_value_tag_min_fields
}

"""
order by aggregate values of table "prop_value_tag"
"""
input prop_value_tag_aggregate_order_by {
  count: order_by
  max: prop_value_tag_max_order_by
  min: prop_value_tag_min_order_by
}

"""
input type for inserting array relation for remote table "prop_value_tag"
"""
input prop_value_tag_arr_rel_insert_input {
  data: [prop_value_tag_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: prop_value_tag_on_conflict
}

"""
Boolean expression to filter rows from the table "prop_value_tag". All fields are combined with a logical 'AND'.
"""
input prop_value_tag_bool_exp {
  _and: [prop_value_tag_bool_exp!]
  _not: prop_value_tag_bool_exp
  _or: [prop_value_tag_bool_exp!]
  prop_value: prop_values_bool_exp
  prop_value_id: uuid_comparison_exp
  tag: tags_bool_exp
  tag_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "prop_value_tag"
"""
enum prop_value_tag_constraint {
  """
  unique or primary key constraint
  """
  prop_value_tag_pkey
}

"""
input type for inserting data into table "prop_value_tag"
"""
input prop_value_tag_insert_input {
  prop_value: prop_values_obj_rel_insert_input
  prop_value_id: uuid
  tag: tags_obj_rel_insert_input
  tag_id: uuid
}

"""
aggregate max on columns
"""
type prop_value_tag_max_fields {
  prop_value_id: uuid
  tag_id: uuid
}

"""
order by max() on columns of table "prop_value_tag"
"""
input prop_value_tag_max_order_by {
  prop_value_id: order_by
  tag_id: order_by
}

"""
aggregate min on columns
"""
type prop_value_tag_min_fields {
  prop_value_id: uuid
  tag_id: uuid
}

"""
order by min() on columns of table "prop_value_tag"
"""
input prop_value_tag_min_order_by {
  prop_value_id: order_by
  tag_id: order_by
}

"""
response of any mutation on the table "prop_value_tag"
"""
type prop_value_tag_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [prop_value_tag!]!
}

"""
on conflict condition type for table "prop_value_tag"
"""
input prop_value_tag_on_conflict {
  constraint: prop_value_tag_constraint!
  update_columns: [prop_value_tag_update_column!]!
  where: prop_value_tag_bool_exp
}

"""
Ordering options when selecting data from "prop_value_tag".
"""
input prop_value_tag_order_by {
  prop_value: prop_values_order_by
  prop_value_id: order_by
  tag: tags_order_by
  tag_id: order_by
}

"""
primary key columns input for table: prop_value_tag
"""
input prop_value_tag_pk_columns_input {
  prop_value_id: uuid!
  tag_id: uuid!
}

"""
select columns of table "prop_value_tag"
"""
enum prop_value_tag_select_column {
  """
  column name
  """
  prop_value_id

  """
  column name
  """
  tag_id
}

"""
input type for updating data in table "prop_value_tag"
"""
input prop_value_tag_set_input {
  prop_value_id: uuid
  tag_id: uuid
}

"""
update columns of table "prop_value_tag"
"""
enum prop_value_tag_update_column {
  """
  column name
  """
  prop_value_id

  """
  column name
  """
  tag_id
}

"""
columns and relationships of "prop_value_types"
"""
type prop_value_types {
  description: String

  """
  An array relationship
  """
  prop_values(
    """
    distinct select on columns
    """
    distinct_on: [prop_values_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_values_order_by!]

    """
    filter the rows returned
    """
    where: prop_values_bool_exp
  ): [prop_values!]!

  """
  An aggregate relationship
  """
  prop_values_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_values_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_values_order_by!]

    """
    filter the rows returned
    """
    where: prop_values_bool_exp
  ): prop_values_aggregate!
  value: String!
}

"""
aggregated selection of "prop_value_types"
"""
type prop_value_types_aggregate {
  aggregate: prop_value_types_aggregate_fields
  nodes: [prop_value_types!]!
}

"""
aggregate fields of "prop_value_types"
"""
type prop_value_types_aggregate_fields {
  count(columns: [prop_value_types_select_column!], distinct: Boolean): Int!
  max: prop_value_types_max_fields
  min: prop_value_types_min_fields
}

"""
Boolean expression to filter rows from the table "prop_value_types". All fields are combined with a logical 'AND'.
"""
input prop_value_types_bool_exp {
  _and: [prop_value_types_bool_exp!]
  _not: prop_value_types_bool_exp
  _or: [prop_value_types_bool_exp!]
  description: String_comparison_exp
  prop_values: prop_values_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "prop_value_types"
"""
enum prop_value_types_constraint {
  """
  unique or primary key constraint
  """
  prop_value_types_pkey
}

"""
input type for inserting data into table "prop_value_types"
"""
input prop_value_types_insert_input {
  description: String
  prop_values: prop_values_arr_rel_insert_input
  value: String
}

"""
aggregate max on columns
"""
type prop_value_types_max_fields {
  description: String
  value: String
}

"""
aggregate min on columns
"""
type prop_value_types_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "prop_value_types"
"""
type prop_value_types_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [prop_value_types!]!
}

"""
input type for inserting object relation for remote table "prop_value_types"
"""
input prop_value_types_obj_rel_insert_input {
  data: prop_value_types_insert_input!

  """
  on conflict condition
  """
  on_conflict: prop_value_types_on_conflict
}

"""
on conflict condition type for table "prop_value_types"
"""
input prop_value_types_on_conflict {
  constraint: prop_value_types_constraint!
  update_columns: [prop_value_types_update_column!]!
  where: prop_value_types_bool_exp
}

"""
Ordering options when selecting data from "prop_value_types".
"""
input prop_value_types_order_by {
  description: order_by
  prop_values_aggregate: prop_values_aggregate_order_by
  value: order_by
}

"""
primary key columns input for table: prop_value_types
"""
input prop_value_types_pk_columns_input {
  value: String!
}

"""
select columns of table "prop_value_types"
"""
enum prop_value_types_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

"""
input type for updating data in table "prop_value_types"
"""
input prop_value_types_set_input {
  description: String
  value: String
}

"""
update columns of table "prop_value_types"
"""
enum prop_value_types_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

"""
columns and relationships of "prop_values"
"""
type prop_values {
  id: uuid!

  """
  An object relationship
  """
  lambda: lambdas

  """
  This is used as a value
  """
  lambdaId: uuid
  name: String!

  """
  This is the prop that owns this value
  """
  parentPropId: uuid!

  """
  An object relationship
  """
  prop: props!

  """
  An object relationship
  """
  propByValuePropId: props

  """
  An array relationship
  """
  prop_value_tags(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_tag_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_tag_bool_exp
  ): [prop_value_tag!]!

  """
  An aggregate relationship
  """
  prop_value_tags_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_tag_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_tag_bool_exp
  ): prop_value_tag_aggregate!

  """
  An object relationship
  """
  prop_value_type: prop_value_types!
  type: String!
  value: String

  """
  This is the prop that is used as a value
  """
  valuePropId: uuid
}

"""
aggregated selection of "prop_values"
"""
type prop_values_aggregate {
  aggregate: prop_values_aggregate_fields
  nodes: [prop_values!]!
}

"""
aggregate fields of "prop_values"
"""
type prop_values_aggregate_fields {
  count(columns: [prop_values_select_column!], distinct: Boolean): Int!
  max: prop_values_max_fields
  min: prop_values_min_fields
}

"""
order by aggregate values of table "prop_values"
"""
input prop_values_aggregate_order_by {
  count: order_by
  max: prop_values_max_order_by
  min: prop_values_min_order_by
}

"""
input type for inserting array relation for remote table "prop_values"
"""
input prop_values_arr_rel_insert_input {
  data: [prop_values_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: prop_values_on_conflict
}

"""
Boolean expression to filter rows from the table "prop_values". All fields are combined with a logical 'AND'.
"""
input prop_values_bool_exp {
  _and: [prop_values_bool_exp!]
  _not: prop_values_bool_exp
  _or: [prop_values_bool_exp!]
  id: uuid_comparison_exp
  lambda: lambdas_bool_exp
  lambdaId: uuid_comparison_exp
  name: String_comparison_exp
  parentPropId: uuid_comparison_exp
  prop: props_bool_exp
  propByValuePropId: props_bool_exp
  prop_value_tags: prop_value_tag_bool_exp
  prop_value_type: prop_value_types_bool_exp
  type: String_comparison_exp
  value: String_comparison_exp
  valuePropId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "prop_values"
"""
enum prop_values_constraint {
  """
  unique or primary key constraint
  """
  prop_values_pkey
}

"""
input type for inserting data into table "prop_values"
"""
input prop_values_insert_input {
  id: uuid
  lambda: lambdas_obj_rel_insert_input

  """
  This is used as a value
  """
  lambdaId: uuid
  name: String

  """
  This is the prop that owns this value
  """
  parentPropId: uuid
  prop: props_obj_rel_insert_input
  propByValuePropId: props_obj_rel_insert_input
  prop_value_tags: prop_value_tag_arr_rel_insert_input
  prop_value_type: prop_value_types_obj_rel_insert_input
  type: String
  value: String

  """
  This is the prop that is used as a value
  """
  valuePropId: uuid
}

"""
aggregate max on columns
"""
type prop_values_max_fields {
  id: uuid

  """
  This is used as a value
  """
  lambdaId: uuid
  name: String

  """
  This is the prop that owns this value
  """
  parentPropId: uuid
  type: String
  value: String

  """
  This is the prop that is used as a value
  """
  valuePropId: uuid
}

"""
order by max() on columns of table "prop_values"
"""
input prop_values_max_order_by {
  id: order_by

  """
  This is used as a value
  """
  lambdaId: order_by
  name: order_by

  """
  This is the prop that owns this value
  """
  parentPropId: order_by
  type: order_by
  value: order_by

  """
  This is the prop that is used as a value
  """
  valuePropId: order_by
}

"""
aggregate min on columns
"""
type prop_values_min_fields {
  id: uuid

  """
  This is used as a value
  """
  lambdaId: uuid
  name: String

  """
  This is the prop that owns this value
  """
  parentPropId: uuid
  type: String
  value: String

  """
  This is the prop that is used as a value
  """
  valuePropId: uuid
}

"""
order by min() on columns of table "prop_values"
"""
input prop_values_min_order_by {
  id: order_by

  """
  This is used as a value
  """
  lambdaId: order_by
  name: order_by

  """
  This is the prop that owns this value
  """
  parentPropId: order_by
  type: order_by
  value: order_by

  """
  This is the prop that is used as a value
  """
  valuePropId: order_by
}

"""
response of any mutation on the table "prop_values"
"""
type prop_values_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [prop_values!]!
}

"""
input type for inserting object relation for remote table "prop_values"
"""
input prop_values_obj_rel_insert_input {
  data: prop_values_insert_input!

  """
  on conflict condition
  """
  on_conflict: prop_values_on_conflict
}

"""
on conflict condition type for table "prop_values"
"""
input prop_values_on_conflict {
  constraint: prop_values_constraint!
  update_columns: [prop_values_update_column!]!
  where: prop_values_bool_exp
}

"""
Ordering options when selecting data from "prop_values".
"""
input prop_values_order_by {
  id: order_by
  lambda: lambdas_order_by
  lambdaId: order_by
  name: order_by
  parentPropId: order_by
  prop: props_order_by
  propByValuePropId: props_order_by
  prop_value_tags_aggregate: prop_value_tag_aggregate_order_by
  prop_value_type: prop_value_types_order_by
  type: order_by
  value: order_by
  valuePropId: order_by
}

"""
primary key columns input for table: prop_values
"""
input prop_values_pk_columns_input {
  id: uuid!
}

"""
select columns of table "prop_values"
"""
enum prop_values_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  lambdaId

  """
  column name
  """
  name

  """
  column name
  """
  parentPropId

  """
  column name
  """
  type

  """
  column name
  """
  value

  """
  column name
  """
  valuePropId
}

"""
input type for updating data in table "prop_values"
"""
input prop_values_set_input {
  id: uuid

  """
  This is used as a value
  """
  lambdaId: uuid
  name: String

  """
  This is the prop that owns this value
  """
  parentPropId: uuid
  type: String
  value: String

  """
  This is the prop that is used as a value
  """
  valuePropId: uuid
}

"""
update columns of table "prop_values"
"""
enum prop_values_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  lambdaId

  """
  column name
  """
  name

  """
  column name
  """
  parentPropId

  """
  column name
  """
  type

  """
  column name
  """
  value

  """
  column name
  """
  valuePropId
}

"""
columns and relationships of "props"
"""
type props {
  id: uuid!

  """
  An object relationship
  """
  library: libraries!
  libraryId: uuid!

  """
  An array relationship
  """
  propValuesByValuePropId(
    """
    distinct select on columns
    """
    distinct_on: [prop_values_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_values_order_by!]

    """
    filter the rows returned
    """
    where: prop_values_bool_exp
  ): [prop_values!]!

  """
  An aggregate relationship
  """
  propValuesByValuePropId_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_values_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_values_order_by!]

    """
    filter the rows returned
    """
    where: prop_values_bool_exp
  ): prop_values_aggregate!

  """
  An array relationship
  """
  prop_elements(
    """
    distinct select on columns
    """
    distinct_on: [prop_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_element_order_by!]

    """
    filter the rows returned
    """
    where: prop_element_bool_exp
  ): [prop_element!]!

  """
  An aggregate relationship
  """
  prop_elements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_element_order_by!]

    """
    filter the rows returned
    """
    where: prop_element_bool_exp
  ): prop_element_aggregate!

  """
  An array relationship
  """
  prop_values(
    """
    distinct select on columns
    """
    distinct_on: [prop_values_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_values_order_by!]

    """
    filter the rows returned
    """
    where: prop_values_bool_exp
  ): [prop_values!]!

  """
  An aggregate relationship
  """
  prop_values_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_values_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_values_order_by!]

    """
    filter the rows returned
    """
    where: prop_values_bool_exp
  ): prop_values_aggregate!
}

"""
aggregated selection of "props"
"""
type props_aggregate {
  aggregate: props_aggregate_fields
  nodes: [props!]!
}

"""
aggregate fields of "props"
"""
type props_aggregate_fields {
  count(columns: [props_select_column!], distinct: Boolean): Int!
  max: props_max_fields
  min: props_min_fields
}

"""
order by aggregate values of table "props"
"""
input props_aggregate_order_by {
  count: order_by
  max: props_max_order_by
  min: props_min_order_by
}

"""
input type for inserting array relation for remote table "props"
"""
input props_arr_rel_insert_input {
  data: [props_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: props_on_conflict
}

"""
Boolean expression to filter rows from the table "props". All fields are combined with a logical 'AND'.
"""
input props_bool_exp {
  _and: [props_bool_exp!]
  _not: props_bool_exp
  _or: [props_bool_exp!]
  id: uuid_comparison_exp
  library: libraries_bool_exp
  libraryId: uuid_comparison_exp
  propValuesByValuePropId: prop_values_bool_exp
  prop_elements: prop_element_bool_exp
  prop_values: prop_values_bool_exp
}

"""
unique or primary key constraints on table "props"
"""
enum props_constraint {
  """
  unique or primary key constraint
  """
  props_pkey
}

"""
input type for inserting data into table "props"
"""
input props_insert_input {
  id: uuid
  library: libraries_obj_rel_insert_input
  libraryId: uuid
  propValuesByValuePropId: prop_values_arr_rel_insert_input
  prop_elements: prop_element_arr_rel_insert_input
  prop_values: prop_values_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type props_max_fields {
  id: uuid
  libraryId: uuid
}

"""
order by max() on columns of table "props"
"""
input props_max_order_by {
  id: order_by
  libraryId: order_by
}

"""
aggregate min on columns
"""
type props_min_fields {
  id: uuid
  libraryId: uuid
}

"""
order by min() on columns of table "props"
"""
input props_min_order_by {
  id: order_by
  libraryId: order_by
}

"""
response of any mutation on the table "props"
"""
type props_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [props!]!
}

"""
input type for inserting object relation for remote table "props"
"""
input props_obj_rel_insert_input {
  data: props_insert_input!

  """
  on conflict condition
  """
  on_conflict: props_on_conflict
}

"""
on conflict condition type for table "props"
"""
input props_on_conflict {
  constraint: props_constraint!
  update_columns: [props_update_column!]!
  where: props_bool_exp
}

"""
Ordering options when selecting data from "props".
"""
input props_order_by {
  id: order_by
  library: libraries_order_by
  libraryId: order_by
  propValuesByValuePropId_aggregate: prop_values_aggregate_order_by
  prop_elements_aggregate: prop_element_aggregate_order_by
  prop_values_aggregate: prop_values_aggregate_order_by
}

"""
primary key columns input for table: props
"""
input props_pk_columns_input {
  id: uuid!
}

"""
select columns of table "props"
"""
enum props_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  libraryId
}

"""
input type for updating data in table "props"
"""
input props_set_input {
  id: uuid
  libraryId: uuid
}

"""
update columns of table "props"
"""
enum props_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  libraryId
}

type query_root {
  """
  An array relationship
  """
  apps(
    """
    distinct select on columns
    """
    distinct_on: [apps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [apps_order_by!]

    """
    filter the rows returned
    """
    where: apps_bool_exp
  ): [apps!]!

  """
  An aggregate relationship
  """
  apps_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [apps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [apps_order_by!]

    """
    filter the rows returned
    """
    where: apps_bool_exp
  ): apps_aggregate!

  """
  fetch data from the table: "apps" using primary key columns
  """
  apps_by_pk(id: uuid!): apps

  """
  fetch data from the table: "atom_types"
  """
  atom_types(
    """
    distinct select on columns
    """
    distinct_on: [atom_types_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_types_order_by!]

    """
    filter the rows returned
    """
    where: atom_types_bool_exp
  ): [atom_types!]!

  """
  fetch aggregated fields from the table: "atom_types"
  """
  atom_types_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [atom_types_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_types_order_by!]

    """
    filter the rows returned
    """
    where: atom_types_bool_exp
  ): atom_types_aggregate!

  """
  fetch data from the table: "atom_types" using primary key columns
  """
  atom_types_by_pk(value: String!): atom_types

  """
  fetch data from the table: "atoms"
  """
  atoms(
    """
    distinct select on columns
    """
    distinct_on: [atoms_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atoms_order_by!]

    """
    filter the rows returned
    """
    where: atoms_bool_exp
  ): [atoms!]!

  """
  fetch aggregated fields from the table: "atoms"
  """
  atoms_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [atoms_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atoms_order_by!]

    """
    filter the rows returned
    """
    where: atoms_bool_exp
  ): atoms_aggregate!

  """
  fetch data from the table: "atoms" using primary key columns
  """
  atoms_by_pk(id: uuid!): atoms

  """
  fetch data from the table: "attributes"
  """
  attributes(
    """
    distinct select on columns
    """
    distinct_on: [attributes_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [attributes_order_by!]

    """
    filter the rows returned
    """
    where: attributes_bool_exp
  ): [attributes!]!

  """
  fetch aggregated fields from the table: "attributes"
  """
  attributes_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [attributes_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [attributes_order_by!]

    """
    filter the rows returned
    """
    where: attributes_bool_exp
  ): attributes_aggregate!

  """
  fetch data from the table: "attributes" using primary key columns
  """
  attributes_by_pk(id: uuid!): attributes

  """
  fetch data from the table: "categories"
  """
  categories(
    """
    distinct select on columns
    """
    distinct_on: [categories_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [categories_order_by!]

    """
    filter the rows returned
    """
    where: categories_bool_exp
  ): [categories!]!

  """
  fetch aggregated fields from the table: "categories"
  """
  categories_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [categories_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [categories_order_by!]

    """
    filter the rows returned
    """
    where: categories_bool_exp
  ): categories_aggregate!

  """
  fetch data from the table: "categories" using primary key columns
  """
  categories_by_pk(id: uuid!): categories

  """
  fetch data from the table: "component_elements"
  """
  component_elements(
    """
    distinct select on columns
    """
    distinct_on: [component_elements_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_elements_order_by!]

    """
    filter the rows returned
    """
    where: component_elements_bool_exp
  ): [component_elements!]!

  """
  An aggregate relationship
  """
  component_elements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_elements_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_elements_order_by!]

    """
    filter the rows returned
    """
    where: component_elements_bool_exp
  ): component_elements_aggregate!

  """
  fetch data from the table: "component_elements" using primary key columns
  """
  component_elements_by_pk(id: uuid!): component_elements

  """
  An array relationship
  """
  component_links(
    """
    distinct select on columns
    """
    distinct_on: [component_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_links_order_by!]

    """
    filter the rows returned
    """
    where: component_links_bool_exp
  ): [component_links!]!

  """
  An aggregate relationship
  """
  component_links_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_links_order_by!]

    """
    filter the rows returned
    """
    where: component_links_bool_exp
  ): component_links_aggregate!

  """
  fetch data from the table: "component_links" using primary key columns
  """
  component_links_by_pk(id: uuid!): component_links

  """
  An array relationship
  """
  components(
    """
    distinct select on columns
    """
    distinct_on: [components_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [components_order_by!]

    """
    filter the rows returned
    """
    where: components_bool_exp
  ): [components!]!

  """
  An aggregate relationship
  """
  components_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [components_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [components_order_by!]

    """
    filter the rows returned
    """
    where: components_bool_exp
  ): components_aggregate!

  """
  fetch data from the table: "components" using primary key columns
  """
  components_by_pk(id: uuid!): components

  """
  An array relationship
  """
  lambdas(
    """
    distinct select on columns
    """
    distinct_on: [lambdas_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [lambdas_order_by!]

    """
    filter the rows returned
    """
    where: lambdas_bool_exp
  ): [lambdas!]!

  """
  An aggregate relationship
  """
  lambdas_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [lambdas_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [lambdas_order_by!]

    """
    filter the rows returned
    """
    where: lambdas_bool_exp
  ): lambdas_aggregate!

  """
  fetch data from the table: "lambdas" using primary key columns
  """
  lambdas_by_pk(id: uuid!): lambdas

  """
  An array relationship
  """
  libraries(
    """
    distinct select on columns
    """
    distinct_on: [libraries_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [libraries_order_by!]

    """
    filter the rows returned
    """
    where: libraries_bool_exp
  ): [libraries!]!

  """
  An aggregate relationship
  """
  libraries_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [libraries_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [libraries_order_by!]

    """
    filter the rows returned
    """
    where: libraries_bool_exp
  ): libraries_aggregate!

  """
  fetch data from the table: "libraries" using primary key columns
  """
  libraries_by_pk(id: uuid!): libraries

  """
  fetch data from the table: "page_elements"
  """
  page_elements(
    """
    distinct select on columns
    """
    distinct_on: [page_elements_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_elements_order_by!]

    """
    filter the rows returned
    """
    where: page_elements_bool_exp
  ): [page_elements!]!

  """
  fetch aggregated fields from the table: "page_elements"
  """
  page_elements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_elements_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_elements_order_by!]

    """
    filter the rows returned
    """
    where: page_elements_bool_exp
  ): page_elements_aggregate!

  """
  fetch data from the table: "page_elements" using primary key columns
  """
  page_elements_by_pk(id: uuid!): page_elements

  """
  An array relationship
  """
  page_links(
    """
    distinct select on columns
    """
    distinct_on: [page_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_links_order_by!]

    """
    filter the rows returned
    """
    where: page_links_bool_exp
  ): [page_links!]!

  """
  An aggregate relationship
  """
  page_links_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_links_order_by!]

    """
    filter the rows returned
    """
    where: page_links_bool_exp
  ): page_links_aggregate!

  """
  fetch data from the table: "page_links" using primary key columns
  """
  page_links_by_pk(id: uuid!): page_links

  """
  An array relationship
  """
  pages(
    """
    distinct select on columns
    """
    distinct_on: [pages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [pages_order_by!]

    """
    filter the rows returned
    """
    where: pages_bool_exp
  ): [pages!]!

  """
  An aggregate relationship
  """
  pages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [pages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [pages_order_by!]

    """
    filter the rows returned
    """
    where: pages_bool_exp
  ): pages_aggregate!

  """
  fetch data from the table: "pages" using primary key columns
  """
  pages_by_pk(id: uuid!): pages

  """
  fetch data from the table: "prop_element"
  """
  prop_element(
    """
    distinct select on columns
    """
    distinct_on: [prop_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_element_order_by!]

    """
    filter the rows returned
    """
    where: prop_element_bool_exp
  ): [prop_element!]!

  """
  fetch aggregated fields from the table: "prop_element"
  """
  prop_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_element_order_by!]

    """
    filter the rows returned
    """
    where: prop_element_bool_exp
  ): prop_element_aggregate!

  """
  fetch data from the table: "prop_element" using primary key columns
  """
  prop_element_by_pk(element_id: uuid!, prop_id: uuid!): prop_element

  """
  fetch data from the table: "prop_value_tag"
  """
  prop_value_tag(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_tag_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_tag_bool_exp
  ): [prop_value_tag!]!

  """
  fetch aggregated fields from the table: "prop_value_tag"
  """
  prop_value_tag_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_tag_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_tag_bool_exp
  ): prop_value_tag_aggregate!

  """
  fetch data from the table: "prop_value_tag" using primary key columns
  """
  prop_value_tag_by_pk(prop_value_id: uuid!, tag_id: uuid!): prop_value_tag

  """
  fetch data from the table: "prop_value_types"
  """
  prop_value_types(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_types_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_types_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_types_bool_exp
  ): [prop_value_types!]!

  """
  fetch aggregated fields from the table: "prop_value_types"
  """
  prop_value_types_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_types_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_types_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_types_bool_exp
  ): prop_value_types_aggregate!

  """
  fetch data from the table: "prop_value_types" using primary key columns
  """
  prop_value_types_by_pk(value: String!): prop_value_types

  """
  An array relationship
  """
  prop_values(
    """
    distinct select on columns
    """
    distinct_on: [prop_values_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_values_order_by!]

    """
    filter the rows returned
    """
    where: prop_values_bool_exp
  ): [prop_values!]!

  """
  An aggregate relationship
  """
  prop_values_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_values_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_values_order_by!]

    """
    filter the rows returned
    """
    where: prop_values_bool_exp
  ): prop_values_aggregate!

  """
  fetch data from the table: "prop_values" using primary key columns
  """
  prop_values_by_pk(id: uuid!): prop_values

  """
  An array relationship
  """
  props(
    """
    distinct select on columns
    """
    distinct_on: [props_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [props_order_by!]

    """
    filter the rows returned
    """
    where: props_bool_exp
  ): [props!]!

  """
  An aggregate relationship
  """
  props_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [props_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [props_order_by!]

    """
    filter the rows returned
    """
    where: props_bool_exp
  ): props_aggregate!

  """
  fetch data from the table: "props" using primary key columns
  """
  props_by_pk(id: uuid!): props

  """
  An array relationship
  """
  styles(
    """
    distinct select on columns
    """
    distinct_on: [styles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [styles_order_by!]

    """
    filter the rows returned
    """
    where: styles_bool_exp
  ): [styles!]!

  """
  An aggregate relationship
  """
  styles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [styles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [styles_order_by!]

    """
    filter the rows returned
    """
    where: styles_bool_exp
  ): styles_aggregate!

  """
  fetch data from the table: "styles" using primary key columns
  """
  styles_by_pk(id: uuid!): styles

  """
  An array relationship
  """
  tags(
    """
    distinct select on columns
    """
    distinct_on: [tags_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tags_order_by!]

    """
    filter the rows returned
    """
    where: tags_bool_exp
  ): [tags!]!

  """
  An aggregate relationship
  """
  tags_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tags_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tags_order_by!]

    """
    filter the rows returned
    """
    where: tags_bool_exp
  ): tags_aggregate!

  """
  fetch data from the table: "tags" using primary key columns
  """
  tags_by_pk(id: uuid!): tags

  """
  fetch data from the table: "users"
  """
  users(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]

    """
    filter the rows returned
    """
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]

    """
    filter the rows returned
    """
    where: users_bool_exp
  ): users_aggregate!

  """
  fetch data from the table: "users" using primary key columns
  """
  users_by_pk(id: String!): users
}

"""
columns and relationships of "styles"
"""
type styles {
  id: uuid!

  """
  An object relationship
  """
  library: libraries!
  libraryId: uuid!
  name: String!
}

"""
aggregated selection of "styles"
"""
type styles_aggregate {
  aggregate: styles_aggregate_fields
  nodes: [styles!]!
}

"""
aggregate fields of "styles"
"""
type styles_aggregate_fields {
  count(columns: [styles_select_column!], distinct: Boolean): Int!
  max: styles_max_fields
  min: styles_min_fields
}

"""
order by aggregate values of table "styles"
"""
input styles_aggregate_order_by {
  count: order_by
  max: styles_max_order_by
  min: styles_min_order_by
}

"""
input type for inserting array relation for remote table "styles"
"""
input styles_arr_rel_insert_input {
  data: [styles_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: styles_on_conflict
}

"""
Boolean expression to filter rows from the table "styles". All fields are combined with a logical 'AND'.
"""
input styles_bool_exp {
  _and: [styles_bool_exp!]
  _not: styles_bool_exp
  _or: [styles_bool_exp!]
  id: uuid_comparison_exp
  library: libraries_bool_exp
  libraryId: uuid_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "styles"
"""
enum styles_constraint {
  """
  unique or primary key constraint
  """
  styles_pkey
}

"""
input type for inserting data into table "styles"
"""
input styles_insert_input {
  id: uuid
  library: libraries_obj_rel_insert_input
  libraryId: uuid
  name: String
}

"""
aggregate max on columns
"""
type styles_max_fields {
  id: uuid
  libraryId: uuid
  name: String
}

"""
order by max() on columns of table "styles"
"""
input styles_max_order_by {
  id: order_by
  libraryId: order_by
  name: order_by
}

"""
aggregate min on columns
"""
type styles_min_fields {
  id: uuid
  libraryId: uuid
  name: String
}

"""
order by min() on columns of table "styles"
"""
input styles_min_order_by {
  id: order_by
  libraryId: order_by
  name: order_by
}

"""
response of any mutation on the table "styles"
"""
type styles_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [styles!]!
}

"""
on conflict condition type for table "styles"
"""
input styles_on_conflict {
  constraint: styles_constraint!
  update_columns: [styles_update_column!]!
  where: styles_bool_exp
}

"""
Ordering options when selecting data from "styles".
"""
input styles_order_by {
  id: order_by
  library: libraries_order_by
  libraryId: order_by
  name: order_by
}

"""
primary key columns input for table: styles
"""
input styles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "styles"
"""
enum styles_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  libraryId

  """
  column name
  """
  name
}

"""
input type for updating data in table "styles"
"""
input styles_set_input {
  id: uuid
  libraryId: uuid
  name: String
}

"""
update columns of table "styles"
"""
enum styles_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  libraryId

  """
  column name
  """
  name
}

type subscription_root {
  """
  An array relationship
  """
  apps(
    """
    distinct select on columns
    """
    distinct_on: [apps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [apps_order_by!]

    """
    filter the rows returned
    """
    where: apps_bool_exp
  ): [apps!]!

  """
  An aggregate relationship
  """
  apps_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [apps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [apps_order_by!]

    """
    filter the rows returned
    """
    where: apps_bool_exp
  ): apps_aggregate!

  """
  fetch data from the table: "apps" using primary key columns
  """
  apps_by_pk(id: uuid!): apps

  """
  fetch data from the table: "atom_types"
  """
  atom_types(
    """
    distinct select on columns
    """
    distinct_on: [atom_types_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_types_order_by!]

    """
    filter the rows returned
    """
    where: atom_types_bool_exp
  ): [atom_types!]!

  """
  fetch aggregated fields from the table: "atom_types"
  """
  atom_types_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [atom_types_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_types_order_by!]

    """
    filter the rows returned
    """
    where: atom_types_bool_exp
  ): atom_types_aggregate!

  """
  fetch data from the table: "atom_types" using primary key columns
  """
  atom_types_by_pk(value: String!): atom_types

  """
  fetch data from the table: "atoms"
  """
  atoms(
    """
    distinct select on columns
    """
    distinct_on: [atoms_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atoms_order_by!]

    """
    filter the rows returned
    """
    where: atoms_bool_exp
  ): [atoms!]!

  """
  fetch aggregated fields from the table: "atoms"
  """
  atoms_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [atoms_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atoms_order_by!]

    """
    filter the rows returned
    """
    where: atoms_bool_exp
  ): atoms_aggregate!

  """
  fetch data from the table: "atoms" using primary key columns
  """
  atoms_by_pk(id: uuid!): atoms

  """
  fetch data from the table: "attributes"
  """
  attributes(
    """
    distinct select on columns
    """
    distinct_on: [attributes_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [attributes_order_by!]

    """
    filter the rows returned
    """
    where: attributes_bool_exp
  ): [attributes!]!

  """
  fetch aggregated fields from the table: "attributes"
  """
  attributes_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [attributes_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [attributes_order_by!]

    """
    filter the rows returned
    """
    where: attributes_bool_exp
  ): attributes_aggregate!

  """
  fetch data from the table: "attributes" using primary key columns
  """
  attributes_by_pk(id: uuid!): attributes

  """
  fetch data from the table: "categories"
  """
  categories(
    """
    distinct select on columns
    """
    distinct_on: [categories_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [categories_order_by!]

    """
    filter the rows returned
    """
    where: categories_bool_exp
  ): [categories!]!

  """
  fetch aggregated fields from the table: "categories"
  """
  categories_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [categories_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [categories_order_by!]

    """
    filter the rows returned
    """
    where: categories_bool_exp
  ): categories_aggregate!

  """
  fetch data from the table: "categories" using primary key columns
  """
  categories_by_pk(id: uuid!): categories

  """
  fetch data from the table: "component_elements"
  """
  component_elements(
    """
    distinct select on columns
    """
    distinct_on: [component_elements_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_elements_order_by!]

    """
    filter the rows returned
    """
    where: component_elements_bool_exp
  ): [component_elements!]!

  """
  An aggregate relationship
  """
  component_elements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_elements_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_elements_order_by!]

    """
    filter the rows returned
    """
    where: component_elements_bool_exp
  ): component_elements_aggregate!

  """
  fetch data from the table: "component_elements" using primary key columns
  """
  component_elements_by_pk(id: uuid!): component_elements

  """
  An array relationship
  """
  component_links(
    """
    distinct select on columns
    """
    distinct_on: [component_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_links_order_by!]

    """
    filter the rows returned
    """
    where: component_links_bool_exp
  ): [component_links!]!

  """
  An aggregate relationship
  """
  component_links_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_links_order_by!]

    """
    filter the rows returned
    """
    where: component_links_bool_exp
  ): component_links_aggregate!

  """
  fetch data from the table: "component_links" using primary key columns
  """
  component_links_by_pk(id: uuid!): component_links

  """
  An array relationship
  """
  components(
    """
    distinct select on columns
    """
    distinct_on: [components_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [components_order_by!]

    """
    filter the rows returned
    """
    where: components_bool_exp
  ): [components!]!

  """
  An aggregate relationship
  """
  components_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [components_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [components_order_by!]

    """
    filter the rows returned
    """
    where: components_bool_exp
  ): components_aggregate!

  """
  fetch data from the table: "components" using primary key columns
  """
  components_by_pk(id: uuid!): components

  """
  An array relationship
  """
  lambdas(
    """
    distinct select on columns
    """
    distinct_on: [lambdas_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [lambdas_order_by!]

    """
    filter the rows returned
    """
    where: lambdas_bool_exp
  ): [lambdas!]!

  """
  An aggregate relationship
  """
  lambdas_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [lambdas_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [lambdas_order_by!]

    """
    filter the rows returned
    """
    where: lambdas_bool_exp
  ): lambdas_aggregate!

  """
  fetch data from the table: "lambdas" using primary key columns
  """
  lambdas_by_pk(id: uuid!): lambdas

  """
  An array relationship
  """
  libraries(
    """
    distinct select on columns
    """
    distinct_on: [libraries_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [libraries_order_by!]

    """
    filter the rows returned
    """
    where: libraries_bool_exp
  ): [libraries!]!

  """
  An aggregate relationship
  """
  libraries_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [libraries_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [libraries_order_by!]

    """
    filter the rows returned
    """
    where: libraries_bool_exp
  ): libraries_aggregate!

  """
  fetch data from the table: "libraries" using primary key columns
  """
  libraries_by_pk(id: uuid!): libraries

  """
  fetch data from the table: "page_elements"
  """
  page_elements(
    """
    distinct select on columns
    """
    distinct_on: [page_elements_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_elements_order_by!]

    """
    filter the rows returned
    """
    where: page_elements_bool_exp
  ): [page_elements!]!

  """
  fetch aggregated fields from the table: "page_elements"
  """
  page_elements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_elements_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_elements_order_by!]

    """
    filter the rows returned
    """
    where: page_elements_bool_exp
  ): page_elements_aggregate!

  """
  fetch data from the table: "page_elements" using primary key columns
  """
  page_elements_by_pk(id: uuid!): page_elements

  """
  An array relationship
  """
  page_links(
    """
    distinct select on columns
    """
    distinct_on: [page_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_links_order_by!]

    """
    filter the rows returned
    """
    where: page_links_bool_exp
  ): [page_links!]!

  """
  An aggregate relationship
  """
  page_links_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_links_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_links_order_by!]

    """
    filter the rows returned
    """
    where: page_links_bool_exp
  ): page_links_aggregate!

  """
  fetch data from the table: "page_links" using primary key columns
  """
  page_links_by_pk(id: uuid!): page_links

  """
  An array relationship
  """
  pages(
    """
    distinct select on columns
    """
    distinct_on: [pages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [pages_order_by!]

    """
    filter the rows returned
    """
    where: pages_bool_exp
  ): [pages!]!

  """
  An aggregate relationship
  """
  pages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [pages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [pages_order_by!]

    """
    filter the rows returned
    """
    where: pages_bool_exp
  ): pages_aggregate!

  """
  fetch data from the table: "pages" using primary key columns
  """
  pages_by_pk(id: uuid!): pages

  """
  fetch data from the table: "prop_element"
  """
  prop_element(
    """
    distinct select on columns
    """
    distinct_on: [prop_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_element_order_by!]

    """
    filter the rows returned
    """
    where: prop_element_bool_exp
  ): [prop_element!]!

  """
  fetch aggregated fields from the table: "prop_element"
  """
  prop_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_element_order_by!]

    """
    filter the rows returned
    """
    where: prop_element_bool_exp
  ): prop_element_aggregate!

  """
  fetch data from the table: "prop_element" using primary key columns
  """
  prop_element_by_pk(element_id: uuid!, prop_id: uuid!): prop_element

  """
  fetch data from the table: "prop_value_tag"
  """
  prop_value_tag(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_tag_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_tag_bool_exp
  ): [prop_value_tag!]!

  """
  fetch aggregated fields from the table: "prop_value_tag"
  """
  prop_value_tag_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_tag_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_tag_bool_exp
  ): prop_value_tag_aggregate!

  """
  fetch data from the table: "prop_value_tag" using primary key columns
  """
  prop_value_tag_by_pk(prop_value_id: uuid!, tag_id: uuid!): prop_value_tag

  """
  fetch data from the table: "prop_value_types"
  """
  prop_value_types(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_types_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_types_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_types_bool_exp
  ): [prop_value_types!]!

  """
  fetch aggregated fields from the table: "prop_value_types"
  """
  prop_value_types_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_types_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_types_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_types_bool_exp
  ): prop_value_types_aggregate!

  """
  fetch data from the table: "prop_value_types" using primary key columns
  """
  prop_value_types_by_pk(value: String!): prop_value_types

  """
  An array relationship
  """
  prop_values(
    """
    distinct select on columns
    """
    distinct_on: [prop_values_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_values_order_by!]

    """
    filter the rows returned
    """
    where: prop_values_bool_exp
  ): [prop_values!]!

  """
  An aggregate relationship
  """
  prop_values_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_values_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_values_order_by!]

    """
    filter the rows returned
    """
    where: prop_values_bool_exp
  ): prop_values_aggregate!

  """
  fetch data from the table: "prop_values" using primary key columns
  """
  prop_values_by_pk(id: uuid!): prop_values

  """
  An array relationship
  """
  props(
    """
    distinct select on columns
    """
    distinct_on: [props_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [props_order_by!]

    """
    filter the rows returned
    """
    where: props_bool_exp
  ): [props!]!

  """
  An aggregate relationship
  """
  props_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [props_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [props_order_by!]

    """
    filter the rows returned
    """
    where: props_bool_exp
  ): props_aggregate!

  """
  fetch data from the table: "props" using primary key columns
  """
  props_by_pk(id: uuid!): props

  """
  An array relationship
  """
  styles(
    """
    distinct select on columns
    """
    distinct_on: [styles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [styles_order_by!]

    """
    filter the rows returned
    """
    where: styles_bool_exp
  ): [styles!]!

  """
  An aggregate relationship
  """
  styles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [styles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [styles_order_by!]

    """
    filter the rows returned
    """
    where: styles_bool_exp
  ): styles_aggregate!

  """
  fetch data from the table: "styles" using primary key columns
  """
  styles_by_pk(id: uuid!): styles

  """
  An array relationship
  """
  tags(
    """
    distinct select on columns
    """
    distinct_on: [tags_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tags_order_by!]

    """
    filter the rows returned
    """
    where: tags_bool_exp
  ): [tags!]!

  """
  An aggregate relationship
  """
  tags_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tags_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tags_order_by!]

    """
    filter the rows returned
    """
    where: tags_bool_exp
  ): tags_aggregate!

  """
  fetch data from the table: "tags" using primary key columns
  """
  tags_by_pk(id: uuid!): tags

  """
  fetch data from the table: "users"
  """
  users(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]

    """
    filter the rows returned
    """
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]

    """
    filter the rows returned
    """
    where: users_bool_exp
  ): users_aggregate!

  """
  fetch data from the table: "users" using primary key columns
  """
  users_by_pk(id: String!): users
}

"""
columns and relationships of "tags"
"""
type tags {
  """
  An object relationship
  """
  category: categories
  category_id: uuid
  id: uuid!
  label: String!

  """
  An array relationship
  """
  prop_value_tags(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_tag_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_tag_bool_exp
  ): [prop_value_tag!]!

  """
  An aggregate relationship
  """
  prop_value_tags_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_tag_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_tag_bool_exp
  ): prop_value_tag_aggregate!
}

"""
aggregated selection of "tags"
"""
type tags_aggregate {
  aggregate: tags_aggregate_fields
  nodes: [tags!]!
}

"""
aggregate fields of "tags"
"""
type tags_aggregate_fields {
  count(columns: [tags_select_column!], distinct: Boolean): Int!
  max: tags_max_fields
  min: tags_min_fields
}

"""
order by aggregate values of table "tags"
"""
input tags_aggregate_order_by {
  count: order_by
  max: tags_max_order_by
  min: tags_min_order_by
}

"""
input type for inserting array relation for remote table "tags"
"""
input tags_arr_rel_insert_input {
  data: [tags_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: tags_on_conflict
}

"""
Boolean expression to filter rows from the table "tags". All fields are combined with a logical 'AND'.
"""
input tags_bool_exp {
  _and: [tags_bool_exp!]
  _not: tags_bool_exp
  _or: [tags_bool_exp!]
  category: categories_bool_exp
  category_id: uuid_comparison_exp
  id: uuid_comparison_exp
  label: String_comparison_exp
  prop_value_tags: prop_value_tag_bool_exp
}

"""
unique or primary key constraints on table "tags"
"""
enum tags_constraint {
  """
  unique or primary key constraint
  """
  tags_pkey
}

"""
input type for inserting data into table "tags"
"""
input tags_insert_input {
  category: categories_obj_rel_insert_input
  category_id: uuid
  id: uuid
  label: String
  prop_value_tags: prop_value_tag_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type tags_max_fields {
  category_id: uuid
  id: uuid
  label: String
}

"""
order by max() on columns of table "tags"
"""
input tags_max_order_by {
  category_id: order_by
  id: order_by
  label: order_by
}

"""
aggregate min on columns
"""
type tags_min_fields {
  category_id: uuid
  id: uuid
  label: String
}

"""
order by min() on columns of table "tags"
"""
input tags_min_order_by {
  category_id: order_by
  id: order_by
  label: order_by
}

"""
response of any mutation on the table "tags"
"""
type tags_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [tags!]!
}

"""
input type for inserting object relation for remote table "tags"
"""
input tags_obj_rel_insert_input {
  data: tags_insert_input!

  """
  on conflict condition
  """
  on_conflict: tags_on_conflict
}

"""
on conflict condition type for table "tags"
"""
input tags_on_conflict {
  constraint: tags_constraint!
  update_columns: [tags_update_column!]!
  where: tags_bool_exp
}

"""
Ordering options when selecting data from "tags".
"""
input tags_order_by {
  category: categories_order_by
  category_id: order_by
  id: order_by
  label: order_by
  prop_value_tags_aggregate: prop_value_tag_aggregate_order_by
}

"""
primary key columns input for table: tags
"""
input tags_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tags"
"""
enum tags_select_column {
  """
  column name
  """
  category_id

  """
  column name
  """
  id

  """
  column name
  """
  label
}

"""
input type for updating data in table "tags"
"""
input tags_set_input {
  category_id: uuid
  id: uuid
  label: String
}

"""
update columns of table "tags"
"""
enum tags_update_column {
  """
  column name
  """
  category_id

  """
  column name
  """
  id

  """
  column name
  """
  label
}

"""
columns and relationships of "users"
"""
type users {
  """
  An array relationship
  """
  apps(
    """
    distinct select on columns
    """
    distinct_on: [apps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [apps_order_by!]

    """
    filter the rows returned
    """
    where: apps_bool_exp
  ): [apps!]!

  """
  An aggregate relationship
  """
  apps_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [apps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [apps_order_by!]

    """
    filter the rows returned
    """
    where: apps_bool_exp
  ): apps_aggregate!
  id: String!

  """
  An array relationship
  """
  libraries(
    """
    distinct select on columns
    """
    distinct_on: [libraries_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [libraries_order_by!]

    """
    filter the rows returned
    """
    where: libraries_bool_exp
  ): [libraries!]!

  """
  An aggregate relationship
  """
  libraries_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [libraries_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [libraries_order_by!]

    """
    filter the rows returned
    """
    where: libraries_bool_exp
  ): libraries_aggregate!
  name: String
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  apps: apps_bool_exp
  id: String_comparison_exp
  libraries: libraries_bool_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """
  unique or primary key constraint
  """
  users_pkey
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  apps: apps_arr_rel_insert_input
  id: String
  libraries: libraries_arr_rel_insert_input
  name: String
}

"""
aggregate max on columns
"""
type users_max_fields {
  id: String
  name: String
}

"""
aggregate min on columns
"""
type users_min_fields {
  id: String
  name: String
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """
  on conflict condition
  """
  on_conflict: users_on_conflict
}

"""
on conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]!
  where: users_bool_exp
}

"""
Ordering options when selecting data from "users".
"""
input users_order_by {
  apps_aggregate: apps_aggregate_order_by
  id: order_by
  libraries_aggregate: libraries_aggregate_order_by
  name: order_by
}

"""
primary key columns input for table: users
"""
input users_pk_columns_input {
  id: String!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  name
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  id: String
  name: String
}

"""
update columns of table "users"
"""
enum users_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  name
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}
