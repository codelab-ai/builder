schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input LambdaInput {
  body: String
  id: String!
  library_id: String
  name: String
}

type LambdaOutput {
  payload: String!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

"""
columns and relationships of "app"
"""
type app {
  id: uuid!
  name: String!

  """
  An array relationship
  """
  pages(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): [page!]!

  """
  An aggregate relationship
  """
  pages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): page_aggregate!

  """
  An object relationship
  """
  user: user!
  user_id: String!
}

"""
aggregated selection of "app"
"""
type app_aggregate {
  aggregate: app_aggregate_fields
  nodes: [app!]!
}

"""
aggregate fields of "app"
"""
type app_aggregate_fields {
  count(columns: [app_select_column!], distinct: Boolean): Int!
  max: app_max_fields
  min: app_min_fields
}

"""
order by aggregate values of table "app"
"""
input app_aggregate_order_by {
  count: order_by
  max: app_max_order_by
  min: app_min_order_by
}

"""
input type for inserting array relation for remote table "app"
"""
input app_arr_rel_insert_input {
  data: [app_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: app_on_conflict
}

"""
Boolean expression to filter rows from the table "app". All fields are combined with a logical 'AND'.
"""
input app_bool_exp {
  _and: [app_bool_exp!]
  _not: app_bool_exp
  _or: [app_bool_exp!]
  id: uuid_comparison_exp
  name: String_comparison_exp
  pages: page_bool_exp
  user: user_bool_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "app"
"""
enum app_constraint {
  """
  unique or primary key constraint
  """
  apps_pkey
}

"""
input type for inserting data into table "app"
"""
input app_insert_input {
  id: uuid
  name: String
  pages: page_arr_rel_insert_input
  user: user_obj_rel_insert_input
  user_id: String
}

"""
aggregate max on columns
"""
type app_max_fields {
  id: uuid
  name: String
  user_id: String
}

"""
order by max() on columns of table "app"
"""
input app_max_order_by {
  id: order_by
  name: order_by
  user_id: order_by
}

"""
aggregate min on columns
"""
type app_min_fields {
  id: uuid
  name: String
  user_id: String
}

"""
order by min() on columns of table "app"
"""
input app_min_order_by {
  id: order_by
  name: order_by
  user_id: order_by
}

"""
response of any mutation on the table "app"
"""
type app_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [app!]!
}

"""
input type for inserting object relation for remote table "app"
"""
input app_obj_rel_insert_input {
  data: app_insert_input!

  """
  on conflict condition
  """
  on_conflict: app_on_conflict
}

"""
on conflict condition type for table "app"
"""
input app_on_conflict {
  constraint: app_constraint!
  update_columns: [app_update_column!]!
  where: app_bool_exp
}

"""
Ordering options when selecting data from "app".
"""
input app_order_by {
  id: order_by
  name: order_by
  pages_aggregate: page_aggregate_order_by
  user: user_order_by
  user_id: order_by
}

"""
primary key columns input for table: app
"""
input app_pk_columns_input {
  id: uuid!
}

"""
select columns of table "app"
"""
enum app_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  user_id
}

"""
input type for updating data in table "app"
"""
input app_set_input {
  id: uuid
  name: String
  user_id: String
}

"""
update columns of table "app"
"""
enum app_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  user_id
}

"""
columns and relationships of "atom"
"""
type atom {
  _atom_type: atom_type_enum
  id: uuid!
  library_id: uuid
  owner_id: String

  """
  An object relationship
  """
  propTypes: prop_type_c
  prop_type_c_id: uuid

  """
  An array relationship
  """
  styles(
    """
    distinct select on columns
    """
    distinct_on: [style_atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_atom_order_by!]

    """
    filter the rows returned
    """
    where: style_atom_bool_exp
  ): [style_atom!]!

  """
  An aggregate relationship
  """
  styles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [style_atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_atom_order_by!]

    """
    filter the rows returned
    """
    where: style_atom_bool_exp
  ): style_atom_aggregate!

  """
  An array relationship
  """
  tags(
    """
    distinct select on columns
    """
    distinct_on: [tag_atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_atom_order_by!]

    """
    filter the rows returned
    """
    where: tag_atom_bool_exp
  ): [tag_atom!]!

  """
  An aggregate relationship
  """
  tags_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_atom_order_by!]

    """
    filter the rows returned
    """
    where: tag_atom_bool_exp
  ): tag_atom_aggregate!
  type: String!
}

"""
aggregated selection of "atom"
"""
type atom_aggregate {
  aggregate: atom_aggregate_fields
  nodes: [atom!]!
}

"""
aggregate fields of "atom"
"""
type atom_aggregate_fields {
  count(columns: [atom_select_column!], distinct: Boolean): Int!
  max: atom_max_fields
  min: atom_min_fields
}

"""
order by aggregate values of table "atom"
"""
input atom_aggregate_order_by {
  count: order_by
  max: atom_max_order_by
  min: atom_min_order_by
}

"""
input type for inserting array relation for remote table "atom"
"""
input atom_arr_rel_insert_input {
  data: [atom_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: atom_on_conflict
}

"""
Boolean expression to filter rows from the table "atom". All fields are combined with a logical 'AND'.
"""
input atom_bool_exp {
  _and: [atom_bool_exp!]
  _atom_type: atom_type_enum_comparison_exp
  _not: atom_bool_exp
  _or: [atom_bool_exp!]
  id: uuid_comparison_exp
  library_id: uuid_comparison_exp
  owner_id: String_comparison_exp
  propTypes: prop_type_c_bool_exp
  prop_type_c_id: uuid_comparison_exp
  styles: style_atom_bool_exp
  tags: tag_atom_bool_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "atom"
"""
enum atom_constraint {
  """
  unique or primary key constraint
  """
  vertices_pkey
}

"""
input type for inserting data into table "atom"
"""
input atom_insert_input {
  _atom_type: atom_type_enum
  id: uuid
  library_id: uuid
  owner_id: String
  propTypes: prop_type_c_obj_rel_insert_input
  prop_type_c_id: uuid
  styles: style_atom_arr_rel_insert_input
  tags: tag_atom_arr_rel_insert_input
  type: String
}

"""
aggregate max on columns
"""
type atom_max_fields {
  id: uuid
  library_id: uuid
  owner_id: String
  prop_type_c_id: uuid
  type: String
}

"""
order by max() on columns of table "atom"
"""
input atom_max_order_by {
  id: order_by
  library_id: order_by
  owner_id: order_by
  prop_type_c_id: order_by
  type: order_by
}

"""
aggregate min on columns
"""
type atom_min_fields {
  id: uuid
  library_id: uuid
  owner_id: String
  prop_type_c_id: uuid
  type: String
}

"""
order by min() on columns of table "atom"
"""
input atom_min_order_by {
  id: order_by
  library_id: order_by
  owner_id: order_by
  prop_type_c_id: order_by
  type: order_by
}

"""
response of any mutation on the table "atom"
"""
type atom_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [atom!]!
}

"""
input type for inserting object relation for remote table "atom"
"""
input atom_obj_rel_insert_input {
  data: atom_insert_input!

  """
  on conflict condition
  """
  on_conflict: atom_on_conflict
}

"""
on conflict condition type for table "atom"
"""
input atom_on_conflict {
  constraint: atom_constraint!
  update_columns: [atom_update_column!]!
  where: atom_bool_exp
}

"""
Ordering options when selecting data from "atom".
"""
input atom_order_by {
  _atom_type: order_by
  id: order_by
  library_id: order_by
  owner_id: order_by
  propTypes: prop_type_c_order_by
  prop_type_c_id: order_by
  styles_aggregate: style_atom_aggregate_order_by
  tags_aggregate: tag_atom_aggregate_order_by
  type: order_by
}

"""
primary key columns input for table: atom
"""
input atom_pk_columns_input {
  id: uuid!
}

"""
select columns of table "atom"
"""
enum atom_select_column {
  """
  column name
  """
  _atom_type

  """
  column name
  """
  id

  """
  column name
  """
  library_id

  """
  column name
  """
  owner_id

  """
  column name
  """
  prop_type_c_id

  """
  column name
  """
  type
}

"""
input type for updating data in table "atom"
"""
input atom_set_input {
  _atom_type: atom_type_enum
  id: uuid
  library_id: uuid
  owner_id: String
  prop_type_c_id: uuid
  type: String
}

"""
columns and relationships of "atom_type"
"""
type atom_type {
  description: String
  value: String!
}

"""
aggregated selection of "atom_type"
"""
type atom_type_aggregate {
  aggregate: atom_type_aggregate_fields
  nodes: [atom_type!]!
}

"""
aggregate fields of "atom_type"
"""
type atom_type_aggregate_fields {
  count(columns: [atom_type_select_column!], distinct: Boolean): Int!
  max: atom_type_max_fields
  min: atom_type_min_fields
}

"""
Boolean expression to filter rows from the table "atom_type". All fields are combined with a logical 'AND'.
"""
input atom_type_bool_exp {
  _and: [atom_type_bool_exp!]
  _not: atom_type_bool_exp
  _or: [atom_type_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "atom_type"
"""
enum atom_type_constraint {
  """
  unique or primary key constraint
  """
  vertexType_pkey
}

enum atom_type_enum {
  React_Affix
  React_Alert
  React_Anchor
  React_Anchor_Link
  React_AutoComplete
  React_Avatar
  React_BackTop
  React_Badge
  React_Breadcrumb
  React_Breadcrumb_Item
  React_Button
  React_Calendar
  React_Card
  React_Card_Grid
  React_Card_Meta
  React_Carousel
  React_Cascader
  React_Checkbox
  React_Collapse
  React_Collapse_Panel
  React_Comment
  React_ConfigProvider
  React_DatePicker
  React_Descriptions
  React_Descriptions_Item
  React_Divider
  React_Drawer
  React_Dropdown
  React_Empty
  React_Form
  React_Form_Item
  React_Form_ItemHook
  React_Form_List
  React_Fragment
  React_Grid_Col
  React_Grid_Row
  React_Html_A
  React_Html_Div
  React_Html_P
  React_Html_Span
  React_Icon
  React_Input
  React_InputNumber
  React_Layout
  React_Layout_Content
  React_Layout_Footer
  React_Layout_Header
  React_Layout_Sider
  React_List
  React_List_Item
  React_List_Item_Meta
  React_Mapper
  React_Mentions
  React_Mentions_Option
  React_Menu
  React_Menu_Item
  React_Menu_ItemGroup
  React_Menu_SubMenu
  React_Modal
  React_PageHeader
  React_Page_Container
  React_Pagination
  React_Popconfirm
  React_Popover
  React_Progress
  React_Provider
  React_RGL_Container
  React_RGL_Item
  React_RGL_ResponsiveContainer
  React_Radio
  React_Radio_Group
  React_Rate
  React_RenderComponent
  React_RenderContainer
  React_Result
  React_Select
  React_Select_Option
  React_Skeleton
  React_Slider
  React_Space
  React_Spin
  React_Statistic
  React_Steps
  React_Steps_Step
  React_Switch
  React_Table
  React_Tabs
  React_Tabs_TabPane
  React_Tag
  React_Text
  React_TimePicker
  React_Timeline
  React_Timeline_Item
  React_Tooltip
  React_Transfer
  React_Tree
  React_TreeNode
  React_TreeSelect
  React_Typography
  React_Typography_Paragraph
  React_Typography_Text
  React_Typography_Title
  React_Upload
}

"""
Boolean expression to compare columns of type "atom_type_enum". All fields are combined with logical 'AND'.
"""
input atom_type_enum_comparison_exp {
  _eq: atom_type_enum
  _in: [atom_type_enum!]
  _is_null: Boolean
  _neq: atom_type_enum
  _nin: [atom_type_enum!]
}

"""
input type for inserting data into table "atom_type"
"""
input atom_type_insert_input {
  description: String
  value: String
}

"""
aggregate max on columns
"""
type atom_type_max_fields {
  description: String
  value: String
}

"""
aggregate min on columns
"""
type atom_type_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "atom_type"
"""
type atom_type_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [atom_type!]!
}

"""
on conflict condition type for table "atom_type"
"""
input atom_type_on_conflict {
  constraint: atom_type_constraint!
  update_columns: [atom_type_update_column!]!
  where: atom_type_bool_exp
}

"""
Ordering options when selecting data from "atom_type".
"""
input atom_type_order_by {
  description: order_by
  value: order_by
}

"""
primary key columns input for table: atom_type
"""
input atom_type_pk_columns_input {
  value: String!
}

"""
select columns of table "atom_type"
"""
enum atom_type_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

"""
input type for updating data in table "atom_type"
"""
input atom_type_set_input {
  description: String
  value: String
}

"""
update columns of table "atom_type"
"""
enum atom_type_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

"""
update columns of table "atom"
"""
enum atom_update_column {
  """
  column name
  """
  _atom_type

  """
  column name
  """
  id

  """
  column name
  """
  library_id

  """
  column name
  """
  owner_id

  """
  column name
  """
  prop_type_c_id

  """
  column name
  """
  type
}

"""
columns and relationships of "category"
"""
type category {
  """
  An array relationship
  """
  componentLinks(
    """
    distinct select on columns
    """
    distinct_on: [component_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_link_order_by!]

    """
    filter the rows returned
    """
    where: component_link_bool_exp
  ): [component_link!]!

  """
  An aggregate relationship
  """
  componentLinks_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_link_order_by!]

    """
    filter the rows returned
    """
    where: component_link_bool_exp
  ): component_link_aggregate!
  id: uuid!

  """
  An object relationship
  """
  library: library!
  library_id: uuid!
  name: String

  """
  An array relationship
  """
  tags(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): [tag!]!

  """
  An aggregate relationship
  """
  tags_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): tag_aggregate!
}

"""
aggregated selection of "category"
"""
type category_aggregate {
  aggregate: category_aggregate_fields
  nodes: [category!]!
}

"""
aggregate fields of "category"
"""
type category_aggregate_fields {
  count(columns: [category_select_column!], distinct: Boolean): Int!
  max: category_max_fields
  min: category_min_fields
}

"""
order by aggregate values of table "category"
"""
input category_aggregate_order_by {
  count: order_by
  max: category_max_order_by
  min: category_min_order_by
}

"""
input type for inserting array relation for remote table "category"
"""
input category_arr_rel_insert_input {
  data: [category_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: category_on_conflict
}

"""
Boolean expression to filter rows from the table "category". All fields are combined with a logical 'AND'.
"""
input category_bool_exp {
  _and: [category_bool_exp!]
  _not: category_bool_exp
  _or: [category_bool_exp!]
  componentLinks: component_link_bool_exp
  id: uuid_comparison_exp
  library: library_bool_exp
  library_id: uuid_comparison_exp
  name: String_comparison_exp
  tags: tag_bool_exp
}

"""
unique or primary key constraints on table "category"
"""
enum category_constraint {
  """
  unique or primary key constraint
  """
  categories_pkey
}

"""
input type for inserting data into table "category"
"""
input category_insert_input {
  componentLinks: component_link_arr_rel_insert_input
  id: uuid
  library: library_obj_rel_insert_input
  library_id: uuid
  name: String
  tags: tag_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type category_max_fields {
  id: uuid
  library_id: uuid
  name: String
}

"""
order by max() on columns of table "category"
"""
input category_max_order_by {
  id: order_by
  library_id: order_by
  name: order_by
}

"""
aggregate min on columns
"""
type category_min_fields {
  id: uuid
  library_id: uuid
  name: String
}

"""
order by min() on columns of table "category"
"""
input category_min_order_by {
  id: order_by
  library_id: order_by
  name: order_by
}

"""
response of any mutation on the table "category"
"""
type category_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [category!]!
}

"""
input type for inserting object relation for remote table "category"
"""
input category_obj_rel_insert_input {
  data: category_insert_input!

  """
  on conflict condition
  """
  on_conflict: category_on_conflict
}

"""
on conflict condition type for table "category"
"""
input category_on_conflict {
  constraint: category_constraint!
  update_columns: [category_update_column!]!
  where: category_bool_exp
}

"""
Ordering options when selecting data from "category".
"""
input category_order_by {
  componentLinks_aggregate: component_link_aggregate_order_by
  id: order_by
  library: library_order_by
  library_id: order_by
  name: order_by
  tags_aggregate: tag_aggregate_order_by
}

"""
primary key columns input for table: category
"""
input category_pk_columns_input {
  id: uuid!
}

"""
select columns of table "category"
"""
enum category_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  library_id

  """
  column name
  """
  name
}

"""
input type for updating data in table "category"
"""
input category_set_input {
  id: uuid
  library_id: uuid
  name: String
}

"""
update columns of table "category"
"""
enum category_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  library_id

  """
  column name
  """
  name
}

"""
columns and relationships of "component"
"""
type component {
  """
  An array relationship
  """
  elements(
    """
    distinct select on columns
    """
    distinct_on: [component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_element_order_by!]

    """
    filter the rows returned
    """
    where: component_element_bool_exp
  ): [component_element!]!

  """
  An aggregate relationship
  """
  elements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_element_order_by!]

    """
    filter the rows returned
    """
    where: component_element_bool_exp
  ): component_element_aggregate!
  id: uuid!
  label: String!

  """
  An object relationship
  """
  library: library!
  library_id: uuid!

  """
  An array relationship
  """
  links(
    """
    distinct select on columns
    """
    distinct_on: [component_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_link_order_by!]

    """
    filter the rows returned
    """
    where: component_link_bool_exp
  ): [component_link!]!

  """
  An aggregate relationship
  """
  links_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_link_order_by!]

    """
    filter the rows returned
    """
    where: component_link_bool_exp
  ): component_link_aggregate!

  """
  An array relationship
  """
  tags(
    """
    distinct select on columns
    """
    distinct_on: [tag_component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_component_order_by!]

    """
    filter the rows returned
    """
    where: tag_component_bool_exp
  ): [tag_component!]!

  """
  An aggregate relationship
  """
  tags_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_component_order_by!]

    """
    filter the rows returned
    """
    where: tag_component_bool_exp
  ): tag_component_aggregate!
}

"""
aggregated selection of "component"
"""
type component_aggregate {
  aggregate: component_aggregate_fields
  nodes: [component!]!
}

"""
aggregate fields of "component"
"""
type component_aggregate_fields {
  count(columns: [component_select_column!], distinct: Boolean): Int!
  max: component_max_fields
  min: component_min_fields
}

"""
order by aggregate values of table "component"
"""
input component_aggregate_order_by {
  count: order_by
  max: component_max_order_by
  min: component_min_order_by
}

"""
input type for inserting array relation for remote table "component"
"""
input component_arr_rel_insert_input {
  data: [component_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: component_on_conflict
}

"""
Boolean expression to filter rows from the table "component". All fields are combined with a logical 'AND'.
"""
input component_bool_exp {
  _and: [component_bool_exp!]
  _not: component_bool_exp
  _or: [component_bool_exp!]
  elements: component_element_bool_exp
  id: uuid_comparison_exp
  label: String_comparison_exp
  library: library_bool_exp
  library_id: uuid_comparison_exp
  links: component_link_bool_exp
  tags: tag_component_bool_exp
}

"""
unique or primary key constraints on table "component"
"""
enum component_constraint {
  """
  unique or primary key constraint
  """
  components_pkey
}

"""
columns and relationships of "component_element"
"""
type component_element {
  """
  An object relationship
  """
  atom: atom
  atom_id: uuid

  """
  An object relationship
  """
  component: component!
  component_id: uuid!

  """
  An array relationship
  """
  hocs(
    """
    distinct select on columns
    """
    distinct_on: [hoc_component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [hoc_component_element_order_by!]

    """
    filter the rows returned
    """
    where: hoc_component_element_bool_exp
  ): [hoc_component_element!]!

  """
  An aggregate relationship
  """
  hocs_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [hoc_component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [hoc_component_element_order_by!]

    """
    filter the rows returned
    """
    where: hoc_component_element_bool_exp
  ): hoc_component_element_aggregate!
  id: uuid!
  label: String

  """
  An object relationship
  """
  props: prop_c
  props_c_id: uuid

  """
  An array relationship
  """
  styles(
    """
    distinct select on columns
    """
    distinct_on: [style_component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_component_element_order_by!]

    """
    filter the rows returned
    """
    where: style_component_element_bool_exp
  ): [style_component_element!]!

  """
  An aggregate relationship
  """
  styles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [style_component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_component_element_order_by!]

    """
    filter the rows returned
    """
    where: style_component_element_bool_exp
  ): style_component_element_aggregate!
}

"""
aggregated selection of "component_element"
"""
type component_element_aggregate {
  aggregate: component_element_aggregate_fields
  nodes: [component_element!]!
}

"""
aggregate fields of "component_element"
"""
type component_element_aggregate_fields {
  count(columns: [component_element_select_column!], distinct: Boolean): Int!
  max: component_element_max_fields
  min: component_element_min_fields
}

"""
order by aggregate values of table "component_element"
"""
input component_element_aggregate_order_by {
  count: order_by
  max: component_element_max_order_by
  min: component_element_min_order_by
}

"""
input type for inserting array relation for remote table "component_element"
"""
input component_element_arr_rel_insert_input {
  data: [component_element_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: component_element_on_conflict
}

"""
Boolean expression to filter rows from the table "component_element". All fields are combined with a logical 'AND'.
"""
input component_element_bool_exp {
  _and: [component_element_bool_exp!]
  _not: component_element_bool_exp
  _or: [component_element_bool_exp!]
  atom: atom_bool_exp
  atom_id: uuid_comparison_exp
  component: component_bool_exp
  component_id: uuid_comparison_exp
  hocs: hoc_component_element_bool_exp
  id: uuid_comparison_exp
  label: String_comparison_exp
  props: prop_c_bool_exp
  props_c_id: uuid_comparison_exp
  styles: style_component_element_bool_exp
}

"""
unique or primary key constraints on table "component_element"
"""
enum component_element_constraint {
  """
  unique or primary key constraint
  """
  component_elements_pkey
}

"""
input type for inserting data into table "component_element"
"""
input component_element_insert_input {
  atom: atom_obj_rel_insert_input
  atom_id: uuid
  component: component_obj_rel_insert_input
  component_id: uuid
  hocs: hoc_component_element_arr_rel_insert_input
  id: uuid
  label: String
  props: prop_c_obj_rel_insert_input
  props_c_id: uuid
  styles: style_component_element_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type component_element_max_fields {
  atom_id: uuid
  component_id: uuid
  id: uuid
  label: String
  props_c_id: uuid
}

"""
order by max() on columns of table "component_element"
"""
input component_element_max_order_by {
  atom_id: order_by
  component_id: order_by
  id: order_by
  label: order_by
  props_c_id: order_by
}

"""
aggregate min on columns
"""
type component_element_min_fields {
  atom_id: uuid
  component_id: uuid
  id: uuid
  label: String
  props_c_id: uuid
}

"""
order by min() on columns of table "component_element"
"""
input component_element_min_order_by {
  atom_id: order_by
  component_id: order_by
  id: order_by
  label: order_by
  props_c_id: order_by
}

"""
response of any mutation on the table "component_element"
"""
type component_element_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [component_element!]!
}

"""
input type for inserting object relation for remote table "component_element"
"""
input component_element_obj_rel_insert_input {
  data: component_element_insert_input!

  """
  on conflict condition
  """
  on_conflict: component_element_on_conflict
}

"""
on conflict condition type for table "component_element"
"""
input component_element_on_conflict {
  constraint: component_element_constraint!
  update_columns: [component_element_update_column!]!
  where: component_element_bool_exp
}

"""
Ordering options when selecting data from "component_element".
"""
input component_element_order_by {
  atom: atom_order_by
  atom_id: order_by
  component: component_order_by
  component_id: order_by
  hocs_aggregate: hoc_component_element_aggregate_order_by
  id: order_by
  label: order_by
  props: prop_c_order_by
  props_c_id: order_by
  styles_aggregate: style_component_element_aggregate_order_by
}

"""
primary key columns input for table: component_element
"""
input component_element_pk_columns_input {
  id: uuid!
}

"""
select columns of table "component_element"
"""
enum component_element_select_column {
  """
  column name
  """
  atom_id

  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  label

  """
  column name
  """
  props_c_id
}

"""
input type for updating data in table "component_element"
"""
input component_element_set_input {
  atom_id: uuid
  component_id: uuid
  id: uuid
  label: String
  props_c_id: uuid
}

"""
update columns of table "component_element"
"""
enum component_element_update_column {
  """
  column name
  """
  atom_id

  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  label

  """
  column name
  """
  props_c_id
}

"""
input type for inserting data into table "component"
"""
input component_insert_input {
  elements: component_element_arr_rel_insert_input
  id: uuid
  label: String
  library: library_obj_rel_insert_input
  library_id: uuid
  links: component_link_arr_rel_insert_input
  tags: tag_component_arr_rel_insert_input
}

"""
columns and relationships of "component_link"
"""
type component_link {
  """
  An object relationship
  """
  category: category
  category_id: uuid

  """
  An object relationship
  """
  component: component!
  component_id: uuid!
  id: uuid!
  order: Int
  props(
    """
    JSON select path
    """
    path: String
  ): jsonb

  """
  An object relationship
  """
  sourceElement: component_element!
  source_element_id: uuid!

  """
  An object relationship
  """
  targetElement: component_element!
  target_element_id: uuid!
}

"""
aggregated selection of "component_link"
"""
type component_link_aggregate {
  aggregate: component_link_aggregate_fields
  nodes: [component_link!]!
}

"""
aggregate fields of "component_link"
"""
type component_link_aggregate_fields {
  avg: component_link_avg_fields
  count(columns: [component_link_select_column!], distinct: Boolean): Int!
  max: component_link_max_fields
  min: component_link_min_fields
  stddev: component_link_stddev_fields
  stddev_pop: component_link_stddev_pop_fields
  stddev_samp: component_link_stddev_samp_fields
  sum: component_link_sum_fields
  var_pop: component_link_var_pop_fields
  var_samp: component_link_var_samp_fields
  variance: component_link_variance_fields
}

"""
order by aggregate values of table "component_link"
"""
input component_link_aggregate_order_by {
  avg: component_link_avg_order_by
  count: order_by
  max: component_link_max_order_by
  min: component_link_min_order_by
  stddev: component_link_stddev_order_by
  stddev_pop: component_link_stddev_pop_order_by
  stddev_samp: component_link_stddev_samp_order_by
  sum: component_link_sum_order_by
  var_pop: component_link_var_pop_order_by
  var_samp: component_link_var_samp_order_by
  variance: component_link_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input component_link_append_input {
  props: jsonb
}

"""
input type for inserting array relation for remote table "component_link"
"""
input component_link_arr_rel_insert_input {
  data: [component_link_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: component_link_on_conflict
}

"""
aggregate avg on columns
"""
type component_link_avg_fields {
  order: Float
}

"""
order by avg() on columns of table "component_link"
"""
input component_link_avg_order_by {
  order: order_by
}

"""
Boolean expression to filter rows from the table "component_link". All fields are combined with a logical 'AND'.
"""
input component_link_bool_exp {
  _and: [component_link_bool_exp!]
  _not: component_link_bool_exp
  _or: [component_link_bool_exp!]
  category: category_bool_exp
  category_id: uuid_comparison_exp
  component: component_bool_exp
  component_id: uuid_comparison_exp
  id: uuid_comparison_exp
  order: Int_comparison_exp
  props: jsonb_comparison_exp
  sourceElement: component_element_bool_exp
  source_element_id: uuid_comparison_exp
  targetElement: component_element_bool_exp
  target_element_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "component_link"
"""
enum component_link_constraint {
  """
  unique or primary key constraint
  """
  vertex_edge_type_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input component_link_delete_at_path_input {
  props: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input component_link_delete_elem_input {
  props: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input component_link_delete_key_input {
  props: String
}

"""
input type for incrementing numeric columns in table "component_link"
"""
input component_link_inc_input {
  order: Int
}

"""
input type for inserting data into table "component_link"
"""
input component_link_insert_input {
  category: category_obj_rel_insert_input
  category_id: uuid
  component: component_obj_rel_insert_input
  component_id: uuid
  id: uuid
  order: Int
  props: jsonb
  sourceElement: component_element_obj_rel_insert_input
  source_element_id: uuid
  targetElement: component_element_obj_rel_insert_input
  target_element_id: uuid
}

"""
aggregate max on columns
"""
type component_link_max_fields {
  category_id: uuid
  component_id: uuid
  id: uuid
  order: Int
  source_element_id: uuid
  target_element_id: uuid
}

"""
order by max() on columns of table "component_link"
"""
input component_link_max_order_by {
  category_id: order_by
  component_id: order_by
  id: order_by
  order: order_by
  source_element_id: order_by
  target_element_id: order_by
}

"""
aggregate min on columns
"""
type component_link_min_fields {
  category_id: uuid
  component_id: uuid
  id: uuid
  order: Int
  source_element_id: uuid
  target_element_id: uuid
}

"""
order by min() on columns of table "component_link"
"""
input component_link_min_order_by {
  category_id: order_by
  component_id: order_by
  id: order_by
  order: order_by
  source_element_id: order_by
  target_element_id: order_by
}

"""
response of any mutation on the table "component_link"
"""
type component_link_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [component_link!]!
}

"""
on conflict condition type for table "component_link"
"""
input component_link_on_conflict {
  constraint: component_link_constraint!
  update_columns: [component_link_update_column!]!
  where: component_link_bool_exp
}

"""
Ordering options when selecting data from "component_link".
"""
input component_link_order_by {
  category: category_order_by
  category_id: order_by
  component: component_order_by
  component_id: order_by
  id: order_by
  order: order_by
  props: order_by
  sourceElement: component_element_order_by
  source_element_id: order_by
  targetElement: component_element_order_by
  target_element_id: order_by
}

"""
primary key columns input for table: component_link
"""
input component_link_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input component_link_prepend_input {
  props: jsonb
}

"""
select columns of table "component_link"
"""
enum component_link_select_column {
  """
  column name
  """
  category_id

  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  order

  """
  column name
  """
  props

  """
  column name
  """
  source_element_id

  """
  column name
  """
  target_element_id
}

"""
input type for updating data in table "component_link"
"""
input component_link_set_input {
  category_id: uuid
  component_id: uuid
  id: uuid
  order: Int
  props: jsonb
  source_element_id: uuid
  target_element_id: uuid
}

"""
aggregate stddev on columns
"""
type component_link_stddev_fields {
  order: Float
}

"""
order by stddev() on columns of table "component_link"
"""
input component_link_stddev_order_by {
  order: order_by
}

"""
aggregate stddev_pop on columns
"""
type component_link_stddev_pop_fields {
  order: Float
}

"""
order by stddev_pop() on columns of table "component_link"
"""
input component_link_stddev_pop_order_by {
  order: order_by
}

"""
aggregate stddev_samp on columns
"""
type component_link_stddev_samp_fields {
  order: Float
}

"""
order by stddev_samp() on columns of table "component_link"
"""
input component_link_stddev_samp_order_by {
  order: order_by
}

"""
aggregate sum on columns
"""
type component_link_sum_fields {
  order: Int
}

"""
order by sum() on columns of table "component_link"
"""
input component_link_sum_order_by {
  order: order_by
}

"""
update columns of table "component_link"
"""
enum component_link_update_column {
  """
  column name
  """
  category_id

  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  order

  """
  column name
  """
  props

  """
  column name
  """
  source_element_id

  """
  column name
  """
  target_element_id
}

"""
aggregate var_pop on columns
"""
type component_link_var_pop_fields {
  order: Float
}

"""
order by var_pop() on columns of table "component_link"
"""
input component_link_var_pop_order_by {
  order: order_by
}

"""
aggregate var_samp on columns
"""
type component_link_var_samp_fields {
  order: Float
}

"""
order by var_samp() on columns of table "component_link"
"""
input component_link_var_samp_order_by {
  order: order_by
}

"""
aggregate variance on columns
"""
type component_link_variance_fields {
  order: Float
}

"""
order by variance() on columns of table "component_link"
"""
input component_link_variance_order_by {
  order: order_by
}

"""
aggregate max on columns
"""
type component_max_fields {
  id: uuid
  label: String
  library_id: uuid
}

"""
order by max() on columns of table "component"
"""
input component_max_order_by {
  id: order_by
  label: order_by
  library_id: order_by
}

"""
aggregate min on columns
"""
type component_min_fields {
  id: uuid
  label: String
  library_id: uuid
}

"""
order by min() on columns of table "component"
"""
input component_min_order_by {
  id: order_by
  label: order_by
  library_id: order_by
}

"""
response of any mutation on the table "component"
"""
type component_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [component!]!
}

"""
input type for inserting object relation for remote table "component"
"""
input component_obj_rel_insert_input {
  data: component_insert_input!

  """
  on conflict condition
  """
  on_conflict: component_on_conflict
}

"""
on conflict condition type for table "component"
"""
input component_on_conflict {
  constraint: component_constraint!
  update_columns: [component_update_column!]!
  where: component_bool_exp
}

"""
Ordering options when selecting data from "component".
"""
input component_order_by {
  elements_aggregate: component_element_aggregate_order_by
  id: order_by
  label: order_by
  library: library_order_by
  library_id: order_by
  links_aggregate: component_link_aggregate_order_by
  tags_aggregate: tag_component_aggregate_order_by
}

"""
primary key columns input for table: component
"""
input component_pk_columns_input {
  id: uuid!
}

"""
select columns of table "component"
"""
enum component_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  label

  """
  column name
  """
  library_id
}

"""
input type for updating data in table "component"
"""
input component_set_input {
  id: uuid
  label: String
  library_id: uuid
}

"""
update columns of table "component"
"""
enum component_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  label

  """
  column name
  """
  library_id
}

input get_current_user_args {
  hasura_session: json
}

"""
columns and relationships of "hoc"
"""
type hoc {
  id: uuid!

  """
  An object relationship
  """
  library: library!
  library_id: uuid!

  """
  An array relationship
  """
  tags(
    """
    distinct select on columns
    """
    distinct_on: [tag_hoc_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_hoc_order_by!]

    """
    filter the rows returned
    """
    where: tag_hoc_bool_exp
  ): [tag_hoc!]!

  """
  An aggregate relationship
  """
  tags_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_hoc_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_hoc_order_by!]

    """
    filter the rows returned
    """
    where: tag_hoc_bool_exp
  ): tag_hoc_aggregate!
}

"""
aggregated selection of "hoc"
"""
type hoc_aggregate {
  aggregate: hoc_aggregate_fields
  nodes: [hoc!]!
}

"""
aggregate fields of "hoc"
"""
type hoc_aggregate_fields {
  count(columns: [hoc_select_column!], distinct: Boolean): Int!
  max: hoc_max_fields
  min: hoc_min_fields
}

"""
Boolean expression to filter rows from the table "hoc". All fields are combined with a logical 'AND'.
"""
input hoc_bool_exp {
  _and: [hoc_bool_exp!]
  _not: hoc_bool_exp
  _or: [hoc_bool_exp!]
  id: uuid_comparison_exp
  library: library_bool_exp
  library_id: uuid_comparison_exp
  tags: tag_hoc_bool_exp
}

"""
columns and relationships of "hoc_component_element"
"""
type hoc_component_element {
  """
  An object relationship
  """
  componentElement: component_element!
  component_element_id: uuid!

  """
  An object relationship
  """
  hoc: hoc!
  hoc_id: uuid!
}

"""
aggregated selection of "hoc_component_element"
"""
type hoc_component_element_aggregate {
  aggregate: hoc_component_element_aggregate_fields
  nodes: [hoc_component_element!]!
}

"""
aggregate fields of "hoc_component_element"
"""
type hoc_component_element_aggregate_fields {
  count(
    columns: [hoc_component_element_select_column!]
    distinct: Boolean
  ): Int!
  max: hoc_component_element_max_fields
  min: hoc_component_element_min_fields
}

"""
order by aggregate values of table "hoc_component_element"
"""
input hoc_component_element_aggregate_order_by {
  count: order_by
  max: hoc_component_element_max_order_by
  min: hoc_component_element_min_order_by
}

"""
input type for inserting array relation for remote table "hoc_component_element"
"""
input hoc_component_element_arr_rel_insert_input {
  data: [hoc_component_element_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: hoc_component_element_on_conflict
}

"""
Boolean expression to filter rows from the table "hoc_component_element". All fields are combined with a logical 'AND'.
"""
input hoc_component_element_bool_exp {
  _and: [hoc_component_element_bool_exp!]
  _not: hoc_component_element_bool_exp
  _or: [hoc_component_element_bool_exp!]
  componentElement: component_element_bool_exp
  component_element_id: uuid_comparison_exp
  hoc: hoc_bool_exp
  hoc_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "hoc_component_element"
"""
enum hoc_component_element_constraint {
  """
  unique or primary key constraint
  """
  hoc_component_element_pkey
}

"""
input type for inserting data into table "hoc_component_element"
"""
input hoc_component_element_insert_input {
  componentElement: component_element_obj_rel_insert_input
  component_element_id: uuid
  hoc: hoc_obj_rel_insert_input
  hoc_id: uuid
}

"""
aggregate max on columns
"""
type hoc_component_element_max_fields {
  component_element_id: uuid
  hoc_id: uuid
}

"""
order by max() on columns of table "hoc_component_element"
"""
input hoc_component_element_max_order_by {
  component_element_id: order_by
  hoc_id: order_by
}

"""
aggregate min on columns
"""
type hoc_component_element_min_fields {
  component_element_id: uuid
  hoc_id: uuid
}

"""
order by min() on columns of table "hoc_component_element"
"""
input hoc_component_element_min_order_by {
  component_element_id: order_by
  hoc_id: order_by
}

"""
response of any mutation on the table "hoc_component_element"
"""
type hoc_component_element_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [hoc_component_element!]!
}

"""
on conflict condition type for table "hoc_component_element"
"""
input hoc_component_element_on_conflict {
  constraint: hoc_component_element_constraint!
  update_columns: [hoc_component_element_update_column!]!
  where: hoc_component_element_bool_exp
}

"""
Ordering options when selecting data from "hoc_component_element".
"""
input hoc_component_element_order_by {
  componentElement: component_element_order_by
  component_element_id: order_by
  hoc: hoc_order_by
  hoc_id: order_by
}

"""
primary key columns input for table: hoc_component_element
"""
input hoc_component_element_pk_columns_input {
  component_element_id: uuid!
  hoc_id: uuid!
}

"""
select columns of table "hoc_component_element"
"""
enum hoc_component_element_select_column {
  """
  column name
  """
  component_element_id

  """
  column name
  """
  hoc_id
}

"""
input type for updating data in table "hoc_component_element"
"""
input hoc_component_element_set_input {
  component_element_id: uuid
  hoc_id: uuid
}

"""
update columns of table "hoc_component_element"
"""
enum hoc_component_element_update_column {
  """
  column name
  """
  component_element_id

  """
  column name
  """
  hoc_id
}

"""
unique or primary key constraints on table "hoc"
"""
enum hoc_constraint {
  """
  unique or primary key constraint
  """
  hoc_pkey
}

"""
input type for inserting data into table "hoc"
"""
input hoc_insert_input {
  id: uuid
  library: library_obj_rel_insert_input
  library_id: uuid
  tags: tag_hoc_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type hoc_max_fields {
  id: uuid
  library_id: uuid
}

"""
aggregate min on columns
"""
type hoc_min_fields {
  id: uuid
  library_id: uuid
}

"""
response of any mutation on the table "hoc"
"""
type hoc_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [hoc!]!
}

"""
input type for inserting object relation for remote table "hoc"
"""
input hoc_obj_rel_insert_input {
  data: hoc_insert_input!

  """
  on conflict condition
  """
  on_conflict: hoc_on_conflict
}

"""
on conflict condition type for table "hoc"
"""
input hoc_on_conflict {
  constraint: hoc_constraint!
  update_columns: [hoc_update_column!]!
  where: hoc_bool_exp
}

"""
Ordering options when selecting data from "hoc".
"""
input hoc_order_by {
  id: order_by
  library: library_order_by
  library_id: order_by
  tags_aggregate: tag_hoc_aggregate_order_by
}

"""
primary key columns input for table: hoc
"""
input hoc_pk_columns_input {
  id: uuid!
}

"""
select columns of table "hoc"
"""
enum hoc_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  library_id
}

"""
input type for updating data in table "hoc"
"""
input hoc_set_input {
  id: uuid
  library_id: uuid
}

"""
update columns of table "hoc"
"""
enum hoc_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  library_id
}

scalar json

scalar jsonb

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  """
  is the column contained in the given json value
  """
  _contained_in: jsonb

  """
  does the column contain the given json value at the top level
  """
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """
  does the string exist as a top-level key in the column
  """
  _has_key: String

  """
  do all of these strings exist as top-level keys in the column
  """
  _has_keys_all: [String!]

  """
  do any of these strings exist as top-level keys in the column
  """
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "lambda"
"""
type lambda {
  body: String!
  id: uuid!

  """
  An object relationship
  """
  library: library!
  libraryId: uuid!
  name: String!
}

"""
aggregated selection of "lambda"
"""
type lambda_aggregate {
  aggregate: lambda_aggregate_fields
  nodes: [lambda!]!
}

"""
aggregate fields of "lambda"
"""
type lambda_aggregate_fields {
  count(columns: [lambda_select_column!], distinct: Boolean): Int!
  max: lambda_max_fields
  min: lambda_min_fields
}

"""
order by aggregate values of table "lambda"
"""
input lambda_aggregate_order_by {
  count: order_by
  max: lambda_max_order_by
  min: lambda_min_order_by
}

"""
input type for inserting array relation for remote table "lambda"
"""
input lambda_arr_rel_insert_input {
  data: [lambda_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: lambda_on_conflict
}

"""
Boolean expression to filter rows from the table "lambda". All fields are combined with a logical 'AND'.
"""
input lambda_bool_exp {
  _and: [lambda_bool_exp!]
  _not: lambda_bool_exp
  _or: [lambda_bool_exp!]
  body: String_comparison_exp
  id: uuid_comparison_exp
  library: library_bool_exp
  libraryId: uuid_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "lambda"
"""
enum lambda_constraint {
  """
  unique or primary key constraint
  """
  lambdas_pkey
}

"""
input type for inserting data into table "lambda"
"""
input lambda_insert_input {
  body: String
  id: uuid
  library: library_obj_rel_insert_input
  libraryId: uuid
  name: String
}

"""
aggregate max on columns
"""
type lambda_max_fields {
  body: String
  id: uuid
  libraryId: uuid
  name: String
}

"""
order by max() on columns of table "lambda"
"""
input lambda_max_order_by {
  body: order_by
  id: order_by
  libraryId: order_by
  name: order_by
}

"""
aggregate min on columns
"""
type lambda_min_fields {
  body: String
  id: uuid
  libraryId: uuid
  name: String
}

"""
order by min() on columns of table "lambda"
"""
input lambda_min_order_by {
  body: order_by
  id: order_by
  libraryId: order_by
  name: order_by
}

"""
response of any mutation on the table "lambda"
"""
type lambda_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [lambda!]!
}

"""
on conflict condition type for table "lambda"
"""
input lambda_on_conflict {
  constraint: lambda_constraint!
  update_columns: [lambda_update_column!]!
  where: lambda_bool_exp
}

"""
Ordering options when selecting data from "lambda".
"""
input lambda_order_by {
  body: order_by
  id: order_by
  library: library_order_by
  libraryId: order_by
  name: order_by
}

"""
primary key columns input for table: lambda
"""
input lambda_pk_columns_input {
  id: uuid!
}

"""
select columns of table "lambda"
"""
enum lambda_select_column {
  """
  column name
  """
  body

  """
  column name
  """
  id

  """
  column name
  """
  libraryId

  """
  column name
  """
  name
}

"""
input type for updating data in table "lambda"
"""
input lambda_set_input {
  body: String
  id: uuid
  libraryId: uuid
  name: String
}

"""
update columns of table "lambda"
"""
enum lambda_update_column {
  """
  column name
  """
  body

  """
  column name
  """
  id

  """
  column name
  """
  libraryId

  """
  column name
  """
  name
}

"""
columns and relationships of "library"
"""
type library {
  """
  An array relationship
  """
  atoms(
    """
    distinct select on columns
    """
    distinct_on: [atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_order_by!]

    """
    filter the rows returned
    """
    where: atom_bool_exp
  ): [atom!]!

  """
  An aggregate relationship
  """
  atoms_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_order_by!]

    """
    filter the rows returned
    """
    where: atom_bool_exp
  ): atom_aggregate!

  """
  An array relationship
  """
  categories(
    """
    distinct select on columns
    """
    distinct_on: [category_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [category_order_by!]

    """
    filter the rows returned
    """
    where: category_bool_exp
  ): [category!]!

  """
  An aggregate relationship
  """
  categories_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [category_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [category_order_by!]

    """
    filter the rows returned
    """
    where: category_bool_exp
  ): category_aggregate!

  """
  An array relationship
  """
  components(
    """
    distinct select on columns
    """
    distinct_on: [component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_order_by!]

    """
    filter the rows returned
    """
    where: component_bool_exp
  ): [component!]!

  """
  An aggregate relationship
  """
  components_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_order_by!]

    """
    filter the rows returned
    """
    where: component_bool_exp
  ): component_aggregate!
  id: uuid!

  """
  An array relationship
  """
  lambdas(
    """
    distinct select on columns
    """
    distinct_on: [lambda_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [lambda_order_by!]

    """
    filter the rows returned
    """
    where: lambda_bool_exp
  ): [lambda!]!

  """
  An aggregate relationship
  """
  lambdas_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [lambda_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [lambda_order_by!]

    """
    filter the rows returned
    """
    where: lambda_bool_exp
  ): lambda_aggregate!
  name: String

  """
  An array relationship
  """
  propTypes(
    """
    distinct select on columns
    """
    distinct_on: [prop_type_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_type_c_order_by!]

    """
    filter the rows returned
    """
    where: prop_type_c_bool_exp
  ): [prop_type_c!]!

  """
  An aggregate relationship
  """
  propTypes_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_type_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_type_c_order_by!]

    """
    filter the rows returned
    """
    where: prop_type_c_bool_exp
  ): prop_type_c_aggregate!

  """
  An array relationship
  """
  props(
    """
    distinct select on columns
    """
    distinct_on: [prop_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_c_order_by!]

    """
    filter the rows returned
    """
    where: prop_c_bool_exp
  ): [prop_c!]!

  """
  An aggregate relationship
  """
  props_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_c_order_by!]

    """
    filter the rows returned
    """
    where: prop_c_bool_exp
  ): prop_c_aggregate!

  """
  An array relationship
  """
  styles(
    """
    distinct select on columns
    """
    distinct_on: [style_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_order_by!]

    """
    filter the rows returned
    """
    where: style_bool_exp
  ): [style!]!

  """
  An aggregate relationship
  """
  styles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [style_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_order_by!]

    """
    filter the rows returned
    """
    where: style_bool_exp
  ): style_aggregate!

  """
  An array relationship
  """
  tags(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): [tag!]!

  """
  An aggregate relationship
  """
  tags_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): tag_aggregate!

  """
  An object relationship
  """
  user: user!
  user_id: String!
}

"""
aggregated selection of "library"
"""
type library_aggregate {
  aggregate: library_aggregate_fields
  nodes: [library!]!
}

"""
aggregate fields of "library"
"""
type library_aggregate_fields {
  count(columns: [library_select_column!], distinct: Boolean): Int!
  max: library_max_fields
  min: library_min_fields
}

"""
order by aggregate values of table "library"
"""
input library_aggregate_order_by {
  count: order_by
  max: library_max_order_by
  min: library_min_order_by
}

"""
input type for inserting array relation for remote table "library"
"""
input library_arr_rel_insert_input {
  data: [library_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: library_on_conflict
}

"""
Boolean expression to filter rows from the table "library". All fields are combined with a logical 'AND'.
"""
input library_bool_exp {
  _and: [library_bool_exp!]
  _not: library_bool_exp
  _or: [library_bool_exp!]
  atoms: atom_bool_exp
  categories: category_bool_exp
  components: component_bool_exp
  id: uuid_comparison_exp
  lambdas: lambda_bool_exp
  name: String_comparison_exp
  propTypes: prop_type_c_bool_exp
  props: prop_c_bool_exp
  styles: style_bool_exp
  tags: tag_bool_exp
  user: user_bool_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "library"
"""
enum library_constraint {
  """
  unique or primary key constraint
  """
  libraries_pkey
}

"""
input type for inserting data into table "library"
"""
input library_insert_input {
  atoms: atom_arr_rel_insert_input
  categories: category_arr_rel_insert_input
  components: component_arr_rel_insert_input
  id: uuid
  lambdas: lambda_arr_rel_insert_input
  name: String
  propTypes: prop_type_c_arr_rel_insert_input
  props: prop_c_arr_rel_insert_input
  styles: style_arr_rel_insert_input
  tags: tag_arr_rel_insert_input
  user: user_obj_rel_insert_input
  user_id: String
}

"""
aggregate max on columns
"""
type library_max_fields {
  id: uuid
  name: String
  user_id: String
}

"""
order by max() on columns of table "library"
"""
input library_max_order_by {
  id: order_by
  name: order_by
  user_id: order_by
}

"""
aggregate min on columns
"""
type library_min_fields {
  id: uuid
  name: String
  user_id: String
}

"""
order by min() on columns of table "library"
"""
input library_min_order_by {
  id: order_by
  name: order_by
  user_id: order_by
}

"""
response of any mutation on the table "library"
"""
type library_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [library!]!
}

"""
input type for inserting object relation for remote table "library"
"""
input library_obj_rel_insert_input {
  data: library_insert_input!

  """
  on conflict condition
  """
  on_conflict: library_on_conflict
}

"""
on conflict condition type for table "library"
"""
input library_on_conflict {
  constraint: library_constraint!
  update_columns: [library_update_column!]!
  where: library_bool_exp
}

"""
Ordering options when selecting data from "library".
"""
input library_order_by {
  atoms_aggregate: atom_aggregate_order_by
  categories_aggregate: category_aggregate_order_by
  components_aggregate: component_aggregate_order_by
  id: order_by
  lambdas_aggregate: lambda_aggregate_order_by
  name: order_by
  propTypes_aggregate: prop_type_c_aggregate_order_by
  props_aggregate: prop_c_aggregate_order_by
  styles_aggregate: style_aggregate_order_by
  tags_aggregate: tag_aggregate_order_by
  user: user_order_by
  user_id: order_by
}

"""
primary key columns input for table: library
"""
input library_pk_columns_input {
  id: uuid!
}

"""
select columns of table "library"
"""
enum library_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  user_id
}

"""
input type for updating data in table "library"
"""
input library_set_input {
  id: uuid
  name: String
  user_id: String
}

"""
update columns of table "library"
"""
enum library_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  user_id
}

"""
mutation root
"""
type mutation_root {
  """
  delete data from the table: "app"
  """
  delete_app(
    """
    filter the rows which have to be deleted
    """
    where: app_bool_exp!
  ): app_mutation_response

  """
  delete single row from the table: "app"
  """
  delete_app_by_pk(id: uuid!): app

  """
  delete data from the table: "atom"
  """
  delete_atom(
    """
    filter the rows which have to be deleted
    """
    where: atom_bool_exp!
  ): atom_mutation_response

  """
  delete single row from the table: "atom"
  """
  delete_atom_by_pk(id: uuid!): atom

  """
  delete data from the table: "atom_type"
  """
  delete_atom_type(
    """
    filter the rows which have to be deleted
    """
    where: atom_type_bool_exp!
  ): atom_type_mutation_response

  """
  delete single row from the table: "atom_type"
  """
  delete_atom_type_by_pk(value: String!): atom_type

  """
  delete data from the table: "category"
  """
  delete_category(
    """
    filter the rows which have to be deleted
    """
    where: category_bool_exp!
  ): category_mutation_response

  """
  delete single row from the table: "category"
  """
  delete_category_by_pk(id: uuid!): category

  """
  delete data from the table: "component"
  """
  delete_component(
    """
    filter the rows which have to be deleted
    """
    where: component_bool_exp!
  ): component_mutation_response

  """
  delete single row from the table: "component"
  """
  delete_component_by_pk(id: uuid!): component

  """
  delete data from the table: "component_element"
  """
  delete_component_element(
    """
    filter the rows which have to be deleted
    """
    where: component_element_bool_exp!
  ): component_element_mutation_response

  """
  delete single row from the table: "component_element"
  """
  delete_component_element_by_pk(id: uuid!): component_element

  """
  delete data from the table: "component_link"
  """
  delete_component_link(
    """
    filter the rows which have to be deleted
    """
    where: component_link_bool_exp!
  ): component_link_mutation_response

  """
  delete single row from the table: "component_link"
  """
  delete_component_link_by_pk(id: uuid!): component_link

  """
  delete data from the table: "hoc"
  """
  delete_hoc(
    """
    filter the rows which have to be deleted
    """
    where: hoc_bool_exp!
  ): hoc_mutation_response

  """
  delete single row from the table: "hoc"
  """
  delete_hoc_by_pk(id: uuid!): hoc

  """
  delete data from the table: "hoc_component_element"
  """
  delete_hoc_component_element(
    """
    filter the rows which have to be deleted
    """
    where: hoc_component_element_bool_exp!
  ): hoc_component_element_mutation_response

  """
  delete single row from the table: "hoc_component_element"
  """
  delete_hoc_component_element_by_pk(
    component_element_id: uuid!
    hoc_id: uuid!
  ): hoc_component_element

  """
  delete data from the table: "lambda"
  """
  delete_lambda(
    """
    filter the rows which have to be deleted
    """
    where: lambda_bool_exp!
  ): lambda_mutation_response

  """
  delete single row from the table: "lambda"
  """
  delete_lambda_by_pk(id: uuid!): lambda

  """
  delete data from the table: "library"
  """
  delete_library(
    """
    filter the rows which have to be deleted
    """
    where: library_bool_exp!
  ): library_mutation_response

  """
  delete single row from the table: "library"
  """
  delete_library_by_pk(id: uuid!): library

  """
  delete data from the table: "page"
  """
  delete_page(
    """
    filter the rows which have to be deleted
    """
    where: page_bool_exp!
  ): page_mutation_response

  """
  delete single row from the table: "page"
  """
  delete_page_by_pk(id: uuid!): page

  """
  delete data from the table: "page_element"
  """
  delete_page_element(
    """
    filter the rows which have to be deleted
    """
    where: page_element_bool_exp!
  ): page_element_mutation_response

  """
  delete single row from the table: "page_element"
  """
  delete_page_element_by_pk(id: uuid!): page_element

  """
  delete data from the table: "page_link"
  """
  delete_page_link(
    """
    filter the rows which have to be deleted
    """
    where: page_link_bool_exp!
  ): page_link_mutation_response

  """
  delete single row from the table: "page_link"
  """
  delete_page_link_by_pk(id: uuid!): page_link

  """
  delete data from the table: "prop"
  """
  delete_prop(
    """
    filter the rows which have to be deleted
    """
    where: prop_bool_exp!
  ): prop_mutation_response

  """
  delete single row from the table: "prop"
  """
  delete_prop_by_pk(id: uuid!): prop

  """
  delete data from the table: "prop_c"
  """
  delete_prop_c(
    """
    filter the rows which have to be deleted
    """
    where: prop_c_bool_exp!
  ): prop_c_mutation_response

  """
  delete single row from the table: "prop_c"
  """
  delete_prop_c_by_pk(id: uuid!): prop_c

  """
  delete data from the table: "prop_type"
  """
  delete_prop_type(
    """
    filter the rows which have to be deleted
    """
    where: prop_type_bool_exp!
  ): prop_type_mutation_response

  """
  delete single row from the table: "prop_type"
  """
  delete_prop_type_by_pk(id: uuid!): prop_type

  """
  delete data from the table: "prop_type_c"
  """
  delete_prop_type_c(
    """
    filter the rows which have to be deleted
    """
    where: prop_type_c_bool_exp!
  ): prop_type_c_mutation_response

  """
  delete single row from the table: "prop_type_c"
  """
  delete_prop_type_c_by_pk(id: uuid!): prop_type_c

  """
  delete data from the table: "prop_value"
  """
  delete_prop_value(
    """
    filter the rows which have to be deleted
    """
    where: prop_value_bool_exp!
  ): prop_value_mutation_response

  """
  delete single row from the table: "prop_value"
  """
  delete_prop_value_by_pk(id: uuid!): prop_value

  """
  delete data from the table: "style"
  """
  delete_style(
    """
    filter the rows which have to be deleted
    """
    where: style_bool_exp!
  ): style_mutation_response

  """
  delete data from the table: "style_atom"
  """
  delete_style_atom(
    """
    filter the rows which have to be deleted
    """
    where: style_atom_bool_exp!
  ): style_atom_mutation_response

  """
  delete single row from the table: "style_atom"
  """
  delete_style_atom_by_pk(atom_id: uuid!, style_id: uuid!): style_atom

  """
  delete single row from the table: "style"
  """
  delete_style_by_pk(id: uuid!): style

  """
  delete data from the table: "style_component_element"
  """
  delete_style_component_element(
    """
    filter the rows which have to be deleted
    """
    where: style_component_element_bool_exp!
  ): style_component_element_mutation_response

  """
  delete single row from the table: "style_component_element"
  """
  delete_style_component_element_by_pk(
    component_element_id: uuid!
    style_id: uuid!
  ): style_component_element

  """
  delete data from the table: "style_page_element"
  """
  delete_style_page_element(
    """
    filter the rows which have to be deleted
    """
    where: style_page_element_bool_exp!
  ): style_page_element_mutation_response

  """
  delete single row from the table: "style_page_element"
  """
  delete_style_page_element_by_pk(
    page_element_id: uuid!
    style_id: uuid!
  ): style_page_element

  """
  delete data from the table: "tag"
  """
  delete_tag(
    """
    filter the rows which have to be deleted
    """
    where: tag_bool_exp!
  ): tag_mutation_response

  """
  delete data from the table: "tag_atom"
  """
  delete_tag_atom(
    """
    filter the rows which have to be deleted
    """
    where: tag_atom_bool_exp!
  ): tag_atom_mutation_response

  """
  delete single row from the table: "tag_atom"
  """
  delete_tag_atom_by_pk(atom_id: uuid!, tag_id: uuid!): tag_atom

  """
  delete single row from the table: "tag"
  """
  delete_tag_by_pk(id: uuid!): tag

  """
  delete data from the table: "tag_component"
  """
  delete_tag_component(
    """
    filter the rows which have to be deleted
    """
    where: tag_component_bool_exp!
  ): tag_component_mutation_response

  """
  delete single row from the table: "tag_component"
  """
  delete_tag_component_by_pk(component_id: uuid!, tag_id: uuid!): tag_component

  """
  delete data from the table: "tag_hoc"
  """
  delete_tag_hoc(
    """
    filter the rows which have to be deleted
    """
    where: tag_hoc_bool_exp!
  ): tag_hoc_mutation_response

  """
  delete single row from the table: "tag_hoc"
  """
  delete_tag_hoc_by_pk(hoc_id: uuid!, tag_id: uuid!): tag_hoc

  """
  delete data from the table: "tag_prop_c"
  """
  delete_tag_prop_c(
    """
    filter the rows which have to be deleted
    """
    where: tag_prop_c_bool_exp!
  ): tag_prop_c_mutation_response

  """
  delete single row from the table: "tag_prop_c"
  """
  delete_tag_prop_c_by_pk(prop_c_id: uuid!, tag_id: uuid!): tag_prop_c

  """
  delete data from the table: "tag_prop_type_c"
  """
  delete_tag_prop_type_c(
    """
    filter the rows which have to be deleted
    """
    where: tag_prop_type_c_bool_exp!
  ): tag_prop_type_c_mutation_response

  """
  delete single row from the table: "tag_prop_type_c"
  """
  delete_tag_prop_type_c_by_pk(
    prop_type_c_id: uuid!
    tag_id: uuid!
  ): tag_prop_type_c

  """
  delete data from the table: "tag_prop_value"
  """
  delete_tag_prop_value(
    """
    filter the rows which have to be deleted
    """
    where: tag_prop_value_bool_exp!
  ): tag_prop_value_mutation_response

  """
  delete single row from the table: "tag_prop_value"
  """
  delete_tag_prop_value_by_pk(
    prop_value_id: uuid!
    tag_id: uuid!
  ): tag_prop_value

  """
  delete data from the table: "tag_style"
  """
  delete_tag_style(
    """
    filter the rows which have to be deleted
    """
    where: tag_style_bool_exp!
  ): tag_style_mutation_response

  """
  delete single row from the table: "tag_style"
  """
  delete_tag_style_by_pk(style_id: uuid!, tag_id: uuid!): tag_style

  """
  delete data from the table: "user"
  """
  delete_user(
    """
    filter the rows which have to be deleted
    """
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(id: String!): user

  """
  delete data from the table: "value_type"
  """
  delete_value_type(
    """
    filter the rows which have to be deleted
    """
    where: value_type_bool_exp!
  ): value_type_mutation_response

  """
  delete single row from the table: "value_type"
  """
  delete_value_type_by_pk(value: String!): value_type
  executeLambda(lambda: LambdaInput!, payload: String!): LambdaOutput

  """
  insert data into the table: "app"
  """
  insert_app(
    """
    the rows to be inserted
    """
    objects: [app_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: app_on_conflict
  ): app_mutation_response

  """
  insert a single row into the table: "app"
  """
  insert_app_one(
    """
    the row to be inserted
    """
    object: app_insert_input!

    """
    on conflict condition
    """
    on_conflict: app_on_conflict
  ): app

  """
  insert data into the table: "atom"
  """
  insert_atom(
    """
    the rows to be inserted
    """
    objects: [atom_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: atom_on_conflict
  ): atom_mutation_response

  """
  insert a single row into the table: "atom"
  """
  insert_atom_one(
    """
    the row to be inserted
    """
    object: atom_insert_input!

    """
    on conflict condition
    """
    on_conflict: atom_on_conflict
  ): atom

  """
  insert data into the table: "atom_type"
  """
  insert_atom_type(
    """
    the rows to be inserted
    """
    objects: [atom_type_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: atom_type_on_conflict
  ): atom_type_mutation_response

  """
  insert a single row into the table: "atom_type"
  """
  insert_atom_type_one(
    """
    the row to be inserted
    """
    object: atom_type_insert_input!

    """
    on conflict condition
    """
    on_conflict: atom_type_on_conflict
  ): atom_type

  """
  insert data into the table: "category"
  """
  insert_category(
    """
    the rows to be inserted
    """
    objects: [category_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: category_on_conflict
  ): category_mutation_response

  """
  insert a single row into the table: "category"
  """
  insert_category_one(
    """
    the row to be inserted
    """
    object: category_insert_input!

    """
    on conflict condition
    """
    on_conflict: category_on_conflict
  ): category

  """
  insert data into the table: "component"
  """
  insert_component(
    """
    the rows to be inserted
    """
    objects: [component_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: component_on_conflict
  ): component_mutation_response

  """
  insert data into the table: "component_element"
  """
  insert_component_element(
    """
    the rows to be inserted
    """
    objects: [component_element_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: component_element_on_conflict
  ): component_element_mutation_response

  """
  insert a single row into the table: "component_element"
  """
  insert_component_element_one(
    """
    the row to be inserted
    """
    object: component_element_insert_input!

    """
    on conflict condition
    """
    on_conflict: component_element_on_conflict
  ): component_element

  """
  insert data into the table: "component_link"
  """
  insert_component_link(
    """
    the rows to be inserted
    """
    objects: [component_link_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: component_link_on_conflict
  ): component_link_mutation_response

  """
  insert a single row into the table: "component_link"
  """
  insert_component_link_one(
    """
    the row to be inserted
    """
    object: component_link_insert_input!

    """
    on conflict condition
    """
    on_conflict: component_link_on_conflict
  ): component_link

  """
  insert a single row into the table: "component"
  """
  insert_component_one(
    """
    the row to be inserted
    """
    object: component_insert_input!

    """
    on conflict condition
    """
    on_conflict: component_on_conflict
  ): component

  """
  insert data into the table: "hoc"
  """
  insert_hoc(
    """
    the rows to be inserted
    """
    objects: [hoc_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: hoc_on_conflict
  ): hoc_mutation_response

  """
  insert data into the table: "hoc_component_element"
  """
  insert_hoc_component_element(
    """
    the rows to be inserted
    """
    objects: [hoc_component_element_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: hoc_component_element_on_conflict
  ): hoc_component_element_mutation_response

  """
  insert a single row into the table: "hoc_component_element"
  """
  insert_hoc_component_element_one(
    """
    the row to be inserted
    """
    object: hoc_component_element_insert_input!

    """
    on conflict condition
    """
    on_conflict: hoc_component_element_on_conflict
  ): hoc_component_element

  """
  insert a single row into the table: "hoc"
  """
  insert_hoc_one(
    """
    the row to be inserted
    """
    object: hoc_insert_input!

    """
    on conflict condition
    """
    on_conflict: hoc_on_conflict
  ): hoc

  """
  insert data into the table: "lambda"
  """
  insert_lambda(
    """
    the rows to be inserted
    """
    objects: [lambda_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: lambda_on_conflict
  ): lambda_mutation_response

  """
  insert a single row into the table: "lambda"
  """
  insert_lambda_one(
    """
    the row to be inserted
    """
    object: lambda_insert_input!

    """
    on conflict condition
    """
    on_conflict: lambda_on_conflict
  ): lambda

  """
  insert data into the table: "library"
  """
  insert_library(
    """
    the rows to be inserted
    """
    objects: [library_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: library_on_conflict
  ): library_mutation_response

  """
  insert a single row into the table: "library"
  """
  insert_library_one(
    """
    the row to be inserted
    """
    object: library_insert_input!

    """
    on conflict condition
    """
    on_conflict: library_on_conflict
  ): library

  """
  insert data into the table: "page"
  """
  insert_page(
    """
    the rows to be inserted
    """
    objects: [page_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: page_on_conflict
  ): page_mutation_response

  """
  insert data into the table: "page_element"
  """
  insert_page_element(
    """
    the rows to be inserted
    """
    objects: [page_element_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: page_element_on_conflict
  ): page_element_mutation_response

  """
  insert a single row into the table: "page_element"
  """
  insert_page_element_one(
    """
    the row to be inserted
    """
    object: page_element_insert_input!

    """
    on conflict condition
    """
    on_conflict: page_element_on_conflict
  ): page_element

  """
  insert data into the table: "page_link"
  """
  insert_page_link(
    """
    the rows to be inserted
    """
    objects: [page_link_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: page_link_on_conflict
  ): page_link_mutation_response

  """
  insert a single row into the table: "page_link"
  """
  insert_page_link_one(
    """
    the row to be inserted
    """
    object: page_link_insert_input!

    """
    on conflict condition
    """
    on_conflict: page_link_on_conflict
  ): page_link

  """
  insert a single row into the table: "page"
  """
  insert_page_one(
    """
    the row to be inserted
    """
    object: page_insert_input!

    """
    on conflict condition
    """
    on_conflict: page_on_conflict
  ): page

  """
  insert data into the table: "prop"
  """
  insert_prop(
    """
    the rows to be inserted
    """
    objects: [prop_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: prop_on_conflict
  ): prop_mutation_response

  """
  insert data into the table: "prop_c"
  """
  insert_prop_c(
    """
    the rows to be inserted
    """
    objects: [prop_c_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: prop_c_on_conflict
  ): prop_c_mutation_response

  """
  insert a single row into the table: "prop_c"
  """
  insert_prop_c_one(
    """
    the row to be inserted
    """
    object: prop_c_insert_input!

    """
    on conflict condition
    """
    on_conflict: prop_c_on_conflict
  ): prop_c

  """
  insert a single row into the table: "prop"
  """
  insert_prop_one(
    """
    the row to be inserted
    """
    object: prop_insert_input!

    """
    on conflict condition
    """
    on_conflict: prop_on_conflict
  ): prop

  """
  insert data into the table: "prop_type"
  """
  insert_prop_type(
    """
    the rows to be inserted
    """
    objects: [prop_type_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: prop_type_on_conflict
  ): prop_type_mutation_response

  """
  insert data into the table: "prop_type_c"
  """
  insert_prop_type_c(
    """
    the rows to be inserted
    """
    objects: [prop_type_c_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: prop_type_c_on_conflict
  ): prop_type_c_mutation_response

  """
  insert a single row into the table: "prop_type_c"
  """
  insert_prop_type_c_one(
    """
    the row to be inserted
    """
    object: prop_type_c_insert_input!

    """
    on conflict condition
    """
    on_conflict: prop_type_c_on_conflict
  ): prop_type_c

  """
  insert a single row into the table: "prop_type"
  """
  insert_prop_type_one(
    """
    the row to be inserted
    """
    object: prop_type_insert_input!

    """
    on conflict condition
    """
    on_conflict: prop_type_on_conflict
  ): prop_type

  """
  insert data into the table: "prop_value"
  """
  insert_prop_value(
    """
    the rows to be inserted
    """
    objects: [prop_value_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: prop_value_on_conflict
  ): prop_value_mutation_response

  """
  insert a single row into the table: "prop_value"
  """
  insert_prop_value_one(
    """
    the row to be inserted
    """
    object: prop_value_insert_input!

    """
    on conflict condition
    """
    on_conflict: prop_value_on_conflict
  ): prop_value

  """
  insert data into the table: "style"
  """
  insert_style(
    """
    the rows to be inserted
    """
    objects: [style_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: style_on_conflict
  ): style_mutation_response

  """
  insert data into the table: "style_atom"
  """
  insert_style_atom(
    """
    the rows to be inserted
    """
    objects: [style_atom_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: style_atom_on_conflict
  ): style_atom_mutation_response

  """
  insert a single row into the table: "style_atom"
  """
  insert_style_atom_one(
    """
    the row to be inserted
    """
    object: style_atom_insert_input!

    """
    on conflict condition
    """
    on_conflict: style_atom_on_conflict
  ): style_atom

  """
  insert data into the table: "style_component_element"
  """
  insert_style_component_element(
    """
    the rows to be inserted
    """
    objects: [style_component_element_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: style_component_element_on_conflict
  ): style_component_element_mutation_response

  """
  insert a single row into the table: "style_component_element"
  """
  insert_style_component_element_one(
    """
    the row to be inserted
    """
    object: style_component_element_insert_input!

    """
    on conflict condition
    """
    on_conflict: style_component_element_on_conflict
  ): style_component_element

  """
  insert a single row into the table: "style"
  """
  insert_style_one(
    """
    the row to be inserted
    """
    object: style_insert_input!

    """
    on conflict condition
    """
    on_conflict: style_on_conflict
  ): style

  """
  insert data into the table: "style_page_element"
  """
  insert_style_page_element(
    """
    the rows to be inserted
    """
    objects: [style_page_element_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: style_page_element_on_conflict
  ): style_page_element_mutation_response

  """
  insert a single row into the table: "style_page_element"
  """
  insert_style_page_element_one(
    """
    the row to be inserted
    """
    object: style_page_element_insert_input!

    """
    on conflict condition
    """
    on_conflict: style_page_element_on_conflict
  ): style_page_element

  """
  insert data into the table: "tag"
  """
  insert_tag(
    """
    the rows to be inserted
    """
    objects: [tag_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: tag_on_conflict
  ): tag_mutation_response

  """
  insert data into the table: "tag_atom"
  """
  insert_tag_atom(
    """
    the rows to be inserted
    """
    objects: [tag_atom_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: tag_atom_on_conflict
  ): tag_atom_mutation_response

  """
  insert a single row into the table: "tag_atom"
  """
  insert_tag_atom_one(
    """
    the row to be inserted
    """
    object: tag_atom_insert_input!

    """
    on conflict condition
    """
    on_conflict: tag_atom_on_conflict
  ): tag_atom

  """
  insert data into the table: "tag_component"
  """
  insert_tag_component(
    """
    the rows to be inserted
    """
    objects: [tag_component_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: tag_component_on_conflict
  ): tag_component_mutation_response

  """
  insert a single row into the table: "tag_component"
  """
  insert_tag_component_one(
    """
    the row to be inserted
    """
    object: tag_component_insert_input!

    """
    on conflict condition
    """
    on_conflict: tag_component_on_conflict
  ): tag_component

  """
  insert data into the table: "tag_hoc"
  """
  insert_tag_hoc(
    """
    the rows to be inserted
    """
    objects: [tag_hoc_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: tag_hoc_on_conflict
  ): tag_hoc_mutation_response

  """
  insert a single row into the table: "tag_hoc"
  """
  insert_tag_hoc_one(
    """
    the row to be inserted
    """
    object: tag_hoc_insert_input!

    """
    on conflict condition
    """
    on_conflict: tag_hoc_on_conflict
  ): tag_hoc

  """
  insert a single row into the table: "tag"
  """
  insert_tag_one(
    """
    the row to be inserted
    """
    object: tag_insert_input!

    """
    on conflict condition
    """
    on_conflict: tag_on_conflict
  ): tag

  """
  insert data into the table: "tag_prop_c"
  """
  insert_tag_prop_c(
    """
    the rows to be inserted
    """
    objects: [tag_prop_c_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: tag_prop_c_on_conflict
  ): tag_prop_c_mutation_response

  """
  insert a single row into the table: "tag_prop_c"
  """
  insert_tag_prop_c_one(
    """
    the row to be inserted
    """
    object: tag_prop_c_insert_input!

    """
    on conflict condition
    """
    on_conflict: tag_prop_c_on_conflict
  ): tag_prop_c

  """
  insert data into the table: "tag_prop_type_c"
  """
  insert_tag_prop_type_c(
    """
    the rows to be inserted
    """
    objects: [tag_prop_type_c_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: tag_prop_type_c_on_conflict
  ): tag_prop_type_c_mutation_response

  """
  insert a single row into the table: "tag_prop_type_c"
  """
  insert_tag_prop_type_c_one(
    """
    the row to be inserted
    """
    object: tag_prop_type_c_insert_input!

    """
    on conflict condition
    """
    on_conflict: tag_prop_type_c_on_conflict
  ): tag_prop_type_c

  """
  insert data into the table: "tag_prop_value"
  """
  insert_tag_prop_value(
    """
    the rows to be inserted
    """
    objects: [tag_prop_value_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: tag_prop_value_on_conflict
  ): tag_prop_value_mutation_response

  """
  insert a single row into the table: "tag_prop_value"
  """
  insert_tag_prop_value_one(
    """
    the row to be inserted
    """
    object: tag_prop_value_insert_input!

    """
    on conflict condition
    """
    on_conflict: tag_prop_value_on_conflict
  ): tag_prop_value

  """
  insert data into the table: "tag_style"
  """
  insert_tag_style(
    """
    the rows to be inserted
    """
    objects: [tag_style_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: tag_style_on_conflict
  ): tag_style_mutation_response

  """
  insert a single row into the table: "tag_style"
  """
  insert_tag_style_one(
    """
    the row to be inserted
    """
    object: tag_style_insert_input!

    """
    on conflict condition
    """
    on_conflict: tag_style_on_conflict
  ): tag_style

  """
  insert data into the table: "user"
  """
  insert_user(
    """
    the rows to be inserted
    """
    objects: [user_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """
    the row to be inserted
    """
    object: user_insert_input!

    """
    on conflict condition
    """
    on_conflict: user_on_conflict
  ): user

  """
  insert data into the table: "value_type"
  """
  insert_value_type(
    """
    the rows to be inserted
    """
    objects: [value_type_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: value_type_on_conflict
  ): value_type_mutation_response

  """
  insert a single row into the table: "value_type"
  """
  insert_value_type_one(
    """
    the row to be inserted
    """
    object: value_type_insert_input!

    """
    on conflict condition
    """
    on_conflict: value_type_on_conflict
  ): value_type

  """
  update data of the table: "app"
  """
  update_app(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: app_set_input

    """
    filter the rows which have to be updated
    """
    where: app_bool_exp!
  ): app_mutation_response

  """
  update single row of the table: "app"
  """
  update_app_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: app_set_input
    pk_columns: app_pk_columns_input!
  ): app

  """
  update data of the table: "atom"
  """
  update_atom(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: atom_set_input

    """
    filter the rows which have to be updated
    """
    where: atom_bool_exp!
  ): atom_mutation_response

  """
  update single row of the table: "atom"
  """
  update_atom_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: atom_set_input
    pk_columns: atom_pk_columns_input!
  ): atom

  """
  update data of the table: "atom_type"
  """
  update_atom_type(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: atom_type_set_input

    """
    filter the rows which have to be updated
    """
    where: atom_type_bool_exp!
  ): atom_type_mutation_response

  """
  update single row of the table: "atom_type"
  """
  update_atom_type_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: atom_type_set_input
    pk_columns: atom_type_pk_columns_input!
  ): atom_type

  """
  update data of the table: "category"
  """
  update_category(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: category_set_input

    """
    filter the rows which have to be updated
    """
    where: category_bool_exp!
  ): category_mutation_response

  """
  update single row of the table: "category"
  """
  update_category_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: category_set_input
    pk_columns: category_pk_columns_input!
  ): category

  """
  update data of the table: "component"
  """
  update_component(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: component_set_input

    """
    filter the rows which have to be updated
    """
    where: component_bool_exp!
  ): component_mutation_response

  """
  update single row of the table: "component"
  """
  update_component_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: component_set_input
    pk_columns: component_pk_columns_input!
  ): component

  """
  update data of the table: "component_element"
  """
  update_component_element(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: component_element_set_input

    """
    filter the rows which have to be updated
    """
    where: component_element_bool_exp!
  ): component_element_mutation_response

  """
  update single row of the table: "component_element"
  """
  update_component_element_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: component_element_set_input
    pk_columns: component_element_pk_columns_input!
  ): component_element

  """
  update data of the table: "component_link"
  """
  update_component_link(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: component_link_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: component_link_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: component_link_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: component_link_delete_key_input

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: component_link_inc_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: component_link_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: component_link_set_input

    """
    filter the rows which have to be updated
    """
    where: component_link_bool_exp!
  ): component_link_mutation_response

  """
  update single row of the table: "component_link"
  """
  update_component_link_by_pk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: component_link_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: component_link_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: component_link_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: component_link_delete_key_input

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: component_link_inc_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: component_link_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: component_link_set_input
    pk_columns: component_link_pk_columns_input!
  ): component_link

  """
  update data of the table: "hoc"
  """
  update_hoc(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: hoc_set_input

    """
    filter the rows which have to be updated
    """
    where: hoc_bool_exp!
  ): hoc_mutation_response

  """
  update single row of the table: "hoc"
  """
  update_hoc_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: hoc_set_input
    pk_columns: hoc_pk_columns_input!
  ): hoc

  """
  update data of the table: "hoc_component_element"
  """
  update_hoc_component_element(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: hoc_component_element_set_input

    """
    filter the rows which have to be updated
    """
    where: hoc_component_element_bool_exp!
  ): hoc_component_element_mutation_response

  """
  update single row of the table: "hoc_component_element"
  """
  update_hoc_component_element_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: hoc_component_element_set_input
    pk_columns: hoc_component_element_pk_columns_input!
  ): hoc_component_element

  """
  update data of the table: "lambda"
  """
  update_lambda(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: lambda_set_input

    """
    filter the rows which have to be updated
    """
    where: lambda_bool_exp!
  ): lambda_mutation_response

  """
  update single row of the table: "lambda"
  """
  update_lambda_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: lambda_set_input
    pk_columns: lambda_pk_columns_input!
  ): lambda

  """
  update data of the table: "library"
  """
  update_library(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: library_set_input

    """
    filter the rows which have to be updated
    """
    where: library_bool_exp!
  ): library_mutation_response

  """
  update single row of the table: "library"
  """
  update_library_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: library_set_input
    pk_columns: library_pk_columns_input!
  ): library

  """
  update data of the table: "page"
  """
  update_page(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_set_input

    """
    filter the rows which have to be updated
    """
    where: page_bool_exp!
  ): page_mutation_response

  """
  update single row of the table: "page"
  """
  update_page_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_set_input
    pk_columns: page_pk_columns_input!
  ): page

  """
  update data of the table: "page_element"
  """
  update_page_element(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_element_set_input

    """
    filter the rows which have to be updated
    """
    where: page_element_bool_exp!
  ): page_element_mutation_response

  """
  update single row of the table: "page_element"
  """
  update_page_element_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_element_set_input
    pk_columns: page_element_pk_columns_input!
  ): page_element

  """
  update data of the table: "page_link"
  """
  update_page_link(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: page_link_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: page_link_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: page_link_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: page_link_delete_key_input

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: page_link_inc_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: page_link_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_link_set_input

    """
    filter the rows which have to be updated
    """
    where: page_link_bool_exp!
  ): page_link_mutation_response

  """
  update single row of the table: "page_link"
  """
  update_page_link_by_pk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: page_link_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: page_link_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: page_link_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: page_link_delete_key_input

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: page_link_inc_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: page_link_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_link_set_input
    pk_columns: page_link_pk_columns_input!
  ): page_link

  """
  update data of the table: "prop"
  """
  update_prop(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_set_input

    """
    filter the rows which have to be updated
    """
    where: prop_bool_exp!
  ): prop_mutation_response

  """
  update single row of the table: "prop"
  """
  update_prop_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_set_input
    pk_columns: prop_pk_columns_input!
  ): prop

  """
  update data of the table: "prop_c"
  """
  update_prop_c(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_c_set_input

    """
    filter the rows which have to be updated
    """
    where: prop_c_bool_exp!
  ): prop_c_mutation_response

  """
  update single row of the table: "prop_c"
  """
  update_prop_c_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_c_set_input
    pk_columns: prop_c_pk_columns_input!
  ): prop_c

  """
  update data of the table: "prop_type"
  """
  update_prop_type(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_type_set_input

    """
    filter the rows which have to be updated
    """
    where: prop_type_bool_exp!
  ): prop_type_mutation_response

  """
  update single row of the table: "prop_type"
  """
  update_prop_type_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_type_set_input
    pk_columns: prop_type_pk_columns_input!
  ): prop_type

  """
  update data of the table: "prop_type_c"
  """
  update_prop_type_c(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_type_c_set_input

    """
    filter the rows which have to be updated
    """
    where: prop_type_c_bool_exp!
  ): prop_type_c_mutation_response

  """
  update single row of the table: "prop_type_c"
  """
  update_prop_type_c_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_type_c_set_input
    pk_columns: prop_type_c_pk_columns_input!
  ): prop_type_c

  """
  update data of the table: "prop_value"
  """
  update_prop_value(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_value_set_input

    """
    filter the rows which have to be updated
    """
    where: prop_value_bool_exp!
  ): prop_value_mutation_response

  """
  update single row of the table: "prop_value"
  """
  update_prop_value_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: prop_value_set_input
    pk_columns: prop_value_pk_columns_input!
  ): prop_value

  """
  update data of the table: "style"
  """
  update_style(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: style_set_input

    """
    filter the rows which have to be updated
    """
    where: style_bool_exp!
  ): style_mutation_response

  """
  update data of the table: "style_atom"
  """
  update_style_atom(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: style_atom_set_input

    """
    filter the rows which have to be updated
    """
    where: style_atom_bool_exp!
  ): style_atom_mutation_response

  """
  update single row of the table: "style_atom"
  """
  update_style_atom_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: style_atom_set_input
    pk_columns: style_atom_pk_columns_input!
  ): style_atom

  """
  update single row of the table: "style"
  """
  update_style_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: style_set_input
    pk_columns: style_pk_columns_input!
  ): style

  """
  update data of the table: "style_component_element"
  """
  update_style_component_element(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: style_component_element_set_input

    """
    filter the rows which have to be updated
    """
    where: style_component_element_bool_exp!
  ): style_component_element_mutation_response

  """
  update single row of the table: "style_component_element"
  """
  update_style_component_element_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: style_component_element_set_input
    pk_columns: style_component_element_pk_columns_input!
  ): style_component_element

  """
  update data of the table: "style_page_element"
  """
  update_style_page_element(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: style_page_element_set_input

    """
    filter the rows which have to be updated
    """
    where: style_page_element_bool_exp!
  ): style_page_element_mutation_response

  """
  update single row of the table: "style_page_element"
  """
  update_style_page_element_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: style_page_element_set_input
    pk_columns: style_page_element_pk_columns_input!
  ): style_page_element

  """
  update data of the table: "tag"
  """
  update_tag(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_set_input

    """
    filter the rows which have to be updated
    """
    where: tag_bool_exp!
  ): tag_mutation_response

  """
  update data of the table: "tag_atom"
  """
  update_tag_atom(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_atom_set_input

    """
    filter the rows which have to be updated
    """
    where: tag_atom_bool_exp!
  ): tag_atom_mutation_response

  """
  update single row of the table: "tag_atom"
  """
  update_tag_atom_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_atom_set_input
    pk_columns: tag_atom_pk_columns_input!
  ): tag_atom

  """
  update single row of the table: "tag"
  """
  update_tag_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_set_input
    pk_columns: tag_pk_columns_input!
  ): tag

  """
  update data of the table: "tag_component"
  """
  update_tag_component(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_component_set_input

    """
    filter the rows which have to be updated
    """
    where: tag_component_bool_exp!
  ): tag_component_mutation_response

  """
  update single row of the table: "tag_component"
  """
  update_tag_component_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_component_set_input
    pk_columns: tag_component_pk_columns_input!
  ): tag_component

  """
  update data of the table: "tag_hoc"
  """
  update_tag_hoc(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_hoc_set_input

    """
    filter the rows which have to be updated
    """
    where: tag_hoc_bool_exp!
  ): tag_hoc_mutation_response

  """
  update single row of the table: "tag_hoc"
  """
  update_tag_hoc_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_hoc_set_input
    pk_columns: tag_hoc_pk_columns_input!
  ): tag_hoc

  """
  update data of the table: "tag_prop_c"
  """
  update_tag_prop_c(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_prop_c_set_input

    """
    filter the rows which have to be updated
    """
    where: tag_prop_c_bool_exp!
  ): tag_prop_c_mutation_response

  """
  update single row of the table: "tag_prop_c"
  """
  update_tag_prop_c_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_prop_c_set_input
    pk_columns: tag_prop_c_pk_columns_input!
  ): tag_prop_c

  """
  update data of the table: "tag_prop_type_c"
  """
  update_tag_prop_type_c(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_prop_type_c_set_input

    """
    filter the rows which have to be updated
    """
    where: tag_prop_type_c_bool_exp!
  ): tag_prop_type_c_mutation_response

  """
  update single row of the table: "tag_prop_type_c"
  """
  update_tag_prop_type_c_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_prop_type_c_set_input
    pk_columns: tag_prop_type_c_pk_columns_input!
  ): tag_prop_type_c

  """
  update data of the table: "tag_prop_value"
  """
  update_tag_prop_value(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_prop_value_set_input

    """
    filter the rows which have to be updated
    """
    where: tag_prop_value_bool_exp!
  ): tag_prop_value_mutation_response

  """
  update single row of the table: "tag_prop_value"
  """
  update_tag_prop_value_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_prop_value_set_input
    pk_columns: tag_prop_value_pk_columns_input!
  ): tag_prop_value

  """
  update data of the table: "tag_style"
  """
  update_tag_style(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_style_set_input

    """
    filter the rows which have to be updated
    """
    where: tag_style_bool_exp!
  ): tag_style_mutation_response

  """
  update single row of the table: "tag_style"
  """
  update_tag_style_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_style_set_input
    pk_columns: tag_style_pk_columns_input!
  ): tag_style

  """
  update data of the table: "user"
  """
  update_user(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: user_set_input

    """
    filter the rows which have to be updated
    """
    where: user_bool_exp!
  ): user_mutation_response

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  update data of the table: "value_type"
  """
  update_value_type(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: value_type_set_input

    """
    filter the rows which have to be updated
    """
    where: value_type_bool_exp!
  ): value_type_mutation_response

  """
  update single row of the table: "value_type"
  """
  update_value_type_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: value_type_set_input
    pk_columns: value_type_pk_columns_input!
  ): value_type
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc

  """
  in ascending order, nulls first
  """
  asc_nulls_first

  """
  in ascending order, nulls last
  """
  asc_nulls_last

  """
  in descending order, nulls first
  """
  desc

  """
  in descending order, nulls first
  """
  desc_nulls_first

  """
  in descending order, nulls last
  """
  desc_nulls_last
}

"""
columns and relationships of "page"
"""
type page {
  """
  An object relationship
  """
  app: app!
  app_id: uuid!

  """
  An array relationship
  """
  elements(
    """
    distinct select on columns
    """
    distinct_on: [page_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_element_order_by!]

    """
    filter the rows returned
    """
    where: page_element_bool_exp
  ): [page_element!]!

  """
  An aggregate relationship
  """
  elements_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_element_order_by!]

    """
    filter the rows returned
    """
    where: page_element_bool_exp
  ): page_element_aggregate!
  id: uuid!

  """
  An array relationship
  """
  links(
    """
    distinct select on columns
    """
    distinct_on: [page_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_link_order_by!]

    """
    filter the rows returned
    """
    where: page_link_bool_exp
  ): [page_link!]!

  """
  An aggregate relationship
  """
  links_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_link_order_by!]

    """
    filter the rows returned
    """
    where: page_link_bool_exp
  ): page_link_aggregate!
  name: String!
}

"""
aggregated selection of "page"
"""
type page_aggregate {
  aggregate: page_aggregate_fields
  nodes: [page!]!
}

"""
aggregate fields of "page"
"""
type page_aggregate_fields {
  count(columns: [page_select_column!], distinct: Boolean): Int!
  max: page_max_fields
  min: page_min_fields
}

"""
order by aggregate values of table "page"
"""
input page_aggregate_order_by {
  count: order_by
  max: page_max_order_by
  min: page_min_order_by
}

"""
input type for inserting array relation for remote table "page"
"""
input page_arr_rel_insert_input {
  data: [page_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: page_on_conflict
}

"""
Boolean expression to filter rows from the table "page". All fields are combined with a logical 'AND'.
"""
input page_bool_exp {
  _and: [page_bool_exp!]
  _not: page_bool_exp
  _or: [page_bool_exp!]
  app: app_bool_exp
  app_id: uuid_comparison_exp
  elements: page_element_bool_exp
  id: uuid_comparison_exp
  links: page_link_bool_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "page"
"""
enum page_constraint {
  """
  unique or primary key constraint
  """
  pages_pkey
}

"""
columns and relationships of "page_element"
"""
type page_element {
  """
  An object relationship
  """
  component: component!
  component_id: uuid!
  id: uuid!
  name: String

  """
  An object relationship
  """
  page: page!
  page_id: uuid!
  prop_c_id: uuid

  """
  An object relationship
  """
  props: prop_c

  """
  An array relationship
  """
  styles(
    """
    distinct select on columns
    """
    distinct_on: [style_page_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_page_element_order_by!]

    """
    filter the rows returned
    """
    where: style_page_element_bool_exp
  ): [style_page_element!]!

  """
  An aggregate relationship
  """
  styles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [style_page_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_page_element_order_by!]

    """
    filter the rows returned
    """
    where: style_page_element_bool_exp
  ): style_page_element_aggregate!
}

"""
aggregated selection of "page_element"
"""
type page_element_aggregate {
  aggregate: page_element_aggregate_fields
  nodes: [page_element!]!
}

"""
aggregate fields of "page_element"
"""
type page_element_aggregate_fields {
  count(columns: [page_element_select_column!], distinct: Boolean): Int!
  max: page_element_max_fields
  min: page_element_min_fields
}

"""
order by aggregate values of table "page_element"
"""
input page_element_aggregate_order_by {
  count: order_by
  max: page_element_max_order_by
  min: page_element_min_order_by
}

"""
input type for inserting array relation for remote table "page_element"
"""
input page_element_arr_rel_insert_input {
  data: [page_element_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: page_element_on_conflict
}

"""
Boolean expression to filter rows from the table "page_element". All fields are combined with a logical 'AND'.
"""
input page_element_bool_exp {
  _and: [page_element_bool_exp!]
  _not: page_element_bool_exp
  _or: [page_element_bool_exp!]
  component: component_bool_exp
  component_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  page: page_bool_exp
  page_id: uuid_comparison_exp
  prop_c_id: uuid_comparison_exp
  props: prop_c_bool_exp
  styles: style_page_element_bool_exp
}

"""
unique or primary key constraints on table "page_element"
"""
enum page_element_constraint {
  """
  unique or primary key constraint
  """
  elements_pkey
}

"""
input type for inserting data into table "page_element"
"""
input page_element_insert_input {
  component: component_obj_rel_insert_input
  component_id: uuid
  id: uuid
  name: String
  page: page_obj_rel_insert_input
  page_id: uuid
  prop_c_id: uuid
  props: prop_c_obj_rel_insert_input
  styles: style_page_element_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type page_element_max_fields {
  component_id: uuid
  id: uuid
  name: String
  page_id: uuid
  prop_c_id: uuid
}

"""
order by max() on columns of table "page_element"
"""
input page_element_max_order_by {
  component_id: order_by
  id: order_by
  name: order_by
  page_id: order_by
  prop_c_id: order_by
}

"""
aggregate min on columns
"""
type page_element_min_fields {
  component_id: uuid
  id: uuid
  name: String
  page_id: uuid
  prop_c_id: uuid
}

"""
order by min() on columns of table "page_element"
"""
input page_element_min_order_by {
  component_id: order_by
  id: order_by
  name: order_by
  page_id: order_by
  prop_c_id: order_by
}

"""
response of any mutation on the table "page_element"
"""
type page_element_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [page_element!]!
}

"""
input type for inserting object relation for remote table "page_element"
"""
input page_element_obj_rel_insert_input {
  data: page_element_insert_input!

  """
  on conflict condition
  """
  on_conflict: page_element_on_conflict
}

"""
on conflict condition type for table "page_element"
"""
input page_element_on_conflict {
  constraint: page_element_constraint!
  update_columns: [page_element_update_column!]!
  where: page_element_bool_exp
}

"""
Ordering options when selecting data from "page_element".
"""
input page_element_order_by {
  component: component_order_by
  component_id: order_by
  id: order_by
  name: order_by
  page: page_order_by
  page_id: order_by
  prop_c_id: order_by
  props: prop_c_order_by
  styles_aggregate: style_page_element_aggregate_order_by
}

"""
primary key columns input for table: page_element
"""
input page_element_pk_columns_input {
  id: uuid!
}

"""
select columns of table "page_element"
"""
enum page_element_select_column {
  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  page_id

  """
  column name
  """
  prop_c_id
}

"""
input type for updating data in table "page_element"
"""
input page_element_set_input {
  component_id: uuid
  id: uuid
  name: String
  page_id: uuid
  prop_c_id: uuid
}

"""
update columns of table "page_element"
"""
enum page_element_update_column {
  """
  column name
  """
  component_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  page_id

  """
  column name
  """
  prop_c_id
}

"""
input type for inserting data into table "page"
"""
input page_insert_input {
  app: app_obj_rel_insert_input
  app_id: uuid
  elements: page_element_arr_rel_insert_input
  id: uuid
  links: page_link_arr_rel_insert_input
  name: String
}

"""
columns and relationships of "page_link"
"""
type page_link {
  id: uuid!
  order: Int

  """
  An object relationship
  """
  page: page!
  page_id: uuid!
  props(
    """
    JSON select path
    """
    path: String
  ): jsonb

  """
  An object relationship
  """
  sourceComponentElement: component_element!

  """
  An object relationship
  """
  sourcePageElement: page_element!
  source_component_element_id: uuid!
  source_page_element_id: uuid!

  """
  An object relationship
  """
  targetPageElement: page_element!
  target_page_element_id: uuid!
}

"""
aggregated selection of "page_link"
"""
type page_link_aggregate {
  aggregate: page_link_aggregate_fields
  nodes: [page_link!]!
}

"""
aggregate fields of "page_link"
"""
type page_link_aggregate_fields {
  avg: page_link_avg_fields
  count(columns: [page_link_select_column!], distinct: Boolean): Int!
  max: page_link_max_fields
  min: page_link_min_fields
  stddev: page_link_stddev_fields
  stddev_pop: page_link_stddev_pop_fields
  stddev_samp: page_link_stddev_samp_fields
  sum: page_link_sum_fields
  var_pop: page_link_var_pop_fields
  var_samp: page_link_var_samp_fields
  variance: page_link_variance_fields
}

"""
order by aggregate values of table "page_link"
"""
input page_link_aggregate_order_by {
  avg: page_link_avg_order_by
  count: order_by
  max: page_link_max_order_by
  min: page_link_min_order_by
  stddev: page_link_stddev_order_by
  stddev_pop: page_link_stddev_pop_order_by
  stddev_samp: page_link_stddev_samp_order_by
  sum: page_link_sum_order_by
  var_pop: page_link_var_pop_order_by
  var_samp: page_link_var_samp_order_by
  variance: page_link_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input page_link_append_input {
  props: jsonb
}

"""
input type for inserting array relation for remote table "page_link"
"""
input page_link_arr_rel_insert_input {
  data: [page_link_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: page_link_on_conflict
}

"""
aggregate avg on columns
"""
type page_link_avg_fields {
  order: Float
}

"""
order by avg() on columns of table "page_link"
"""
input page_link_avg_order_by {
  order: order_by
}

"""
Boolean expression to filter rows from the table "page_link". All fields are combined with a logical 'AND'.
"""
input page_link_bool_exp {
  _and: [page_link_bool_exp!]
  _not: page_link_bool_exp
  _or: [page_link_bool_exp!]
  id: uuid_comparison_exp
  order: Int_comparison_exp
  page: page_bool_exp
  page_id: uuid_comparison_exp
  props: jsonb_comparison_exp
  sourceComponentElement: component_element_bool_exp
  sourcePageElement: page_element_bool_exp
  source_component_element_id: uuid_comparison_exp
  source_page_element_id: uuid_comparison_exp
  targetPageElement: page_element_bool_exp
  target_page_element_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "page_link"
"""
enum page_link_constraint {
  """
  unique or primary key constraint
  """
  page_links_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input page_link_delete_at_path_input {
  props: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input page_link_delete_elem_input {
  props: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input page_link_delete_key_input {
  props: String
}

"""
input type for incrementing numeric columns in table "page_link"
"""
input page_link_inc_input {
  order: Int
}

"""
input type for inserting data into table "page_link"
"""
input page_link_insert_input {
  id: uuid
  order: Int
  page: page_obj_rel_insert_input
  page_id: uuid
  props: jsonb
  sourceComponentElement: component_element_obj_rel_insert_input
  sourcePageElement: page_element_obj_rel_insert_input
  source_component_element_id: uuid
  source_page_element_id: uuid
  targetPageElement: page_element_obj_rel_insert_input
  target_page_element_id: uuid
}

"""
aggregate max on columns
"""
type page_link_max_fields {
  id: uuid
  order: Int
  page_id: uuid
  source_component_element_id: uuid
  source_page_element_id: uuid
  target_page_element_id: uuid
}

"""
order by max() on columns of table "page_link"
"""
input page_link_max_order_by {
  id: order_by
  order: order_by
  page_id: order_by
  source_component_element_id: order_by
  source_page_element_id: order_by
  target_page_element_id: order_by
}

"""
aggregate min on columns
"""
type page_link_min_fields {
  id: uuid
  order: Int
  page_id: uuid
  source_component_element_id: uuid
  source_page_element_id: uuid
  target_page_element_id: uuid
}

"""
order by min() on columns of table "page_link"
"""
input page_link_min_order_by {
  id: order_by
  order: order_by
  page_id: order_by
  source_component_element_id: order_by
  source_page_element_id: order_by
  target_page_element_id: order_by
}

"""
response of any mutation on the table "page_link"
"""
type page_link_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [page_link!]!
}

"""
on conflict condition type for table "page_link"
"""
input page_link_on_conflict {
  constraint: page_link_constraint!
  update_columns: [page_link_update_column!]!
  where: page_link_bool_exp
}

"""
Ordering options when selecting data from "page_link".
"""
input page_link_order_by {
  id: order_by
  order: order_by
  page: page_order_by
  page_id: order_by
  props: order_by
  sourceComponentElement: component_element_order_by
  sourcePageElement: page_element_order_by
  source_component_element_id: order_by
  source_page_element_id: order_by
  targetPageElement: page_element_order_by
  target_page_element_id: order_by
}

"""
primary key columns input for table: page_link
"""
input page_link_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input page_link_prepend_input {
  props: jsonb
}

"""
select columns of table "page_link"
"""
enum page_link_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  order

  """
  column name
  """
  page_id

  """
  column name
  """
  props

  """
  column name
  """
  source_component_element_id

  """
  column name
  """
  source_page_element_id

  """
  column name
  """
  target_page_element_id
}

"""
input type for updating data in table "page_link"
"""
input page_link_set_input {
  id: uuid
  order: Int
  page_id: uuid
  props: jsonb
  source_component_element_id: uuid
  source_page_element_id: uuid
  target_page_element_id: uuid
}

"""
aggregate stddev on columns
"""
type page_link_stddev_fields {
  order: Float
}

"""
order by stddev() on columns of table "page_link"
"""
input page_link_stddev_order_by {
  order: order_by
}

"""
aggregate stddev_pop on columns
"""
type page_link_stddev_pop_fields {
  order: Float
}

"""
order by stddev_pop() on columns of table "page_link"
"""
input page_link_stddev_pop_order_by {
  order: order_by
}

"""
aggregate stddev_samp on columns
"""
type page_link_stddev_samp_fields {
  order: Float
}

"""
order by stddev_samp() on columns of table "page_link"
"""
input page_link_stddev_samp_order_by {
  order: order_by
}

"""
aggregate sum on columns
"""
type page_link_sum_fields {
  order: Int
}

"""
order by sum() on columns of table "page_link"
"""
input page_link_sum_order_by {
  order: order_by
}

"""
update columns of table "page_link"
"""
enum page_link_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  order

  """
  column name
  """
  page_id

  """
  column name
  """
  props

  """
  column name
  """
  source_component_element_id

  """
  column name
  """
  source_page_element_id

  """
  column name
  """
  target_page_element_id
}

"""
aggregate var_pop on columns
"""
type page_link_var_pop_fields {
  order: Float
}

"""
order by var_pop() on columns of table "page_link"
"""
input page_link_var_pop_order_by {
  order: order_by
}

"""
aggregate var_samp on columns
"""
type page_link_var_samp_fields {
  order: Float
}

"""
order by var_samp() on columns of table "page_link"
"""
input page_link_var_samp_order_by {
  order: order_by
}

"""
aggregate variance on columns
"""
type page_link_variance_fields {
  order: Float
}

"""
order by variance() on columns of table "page_link"
"""
input page_link_variance_order_by {
  order: order_by
}

"""
aggregate max on columns
"""
type page_max_fields {
  app_id: uuid
  id: uuid
  name: String
}

"""
order by max() on columns of table "page"
"""
input page_max_order_by {
  app_id: order_by
  id: order_by
  name: order_by
}

"""
aggregate min on columns
"""
type page_min_fields {
  app_id: uuid
  id: uuid
  name: String
}

"""
order by min() on columns of table "page"
"""
input page_min_order_by {
  app_id: order_by
  id: order_by
  name: order_by
}

"""
response of any mutation on the table "page"
"""
type page_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [page!]!
}

"""
input type for inserting object relation for remote table "page"
"""
input page_obj_rel_insert_input {
  data: page_insert_input!

  """
  on conflict condition
  """
  on_conflict: page_on_conflict
}

"""
on conflict condition type for table "page"
"""
input page_on_conflict {
  constraint: page_constraint!
  update_columns: [page_update_column!]!
  where: page_bool_exp
}

"""
Ordering options when selecting data from "page".
"""
input page_order_by {
  app: app_order_by
  app_id: order_by
  elements_aggregate: page_element_aggregate_order_by
  id: order_by
  links_aggregate: page_link_aggregate_order_by
  name: order_by
}

"""
primary key columns input for table: page
"""
input page_pk_columns_input {
  id: uuid!
}

"""
select columns of table "page"
"""
enum page_select_column {
  """
  column name
  """
  app_id

  """
  column name
  """
  id

  """
  column name
  """
  name
}

"""
input type for updating data in table "page"
"""
input page_set_input {
  app_id: uuid
  id: uuid
  name: String
}

"""
update columns of table "page"
"""
enum page_update_column {
  """
  column name
  """
  app_id

  """
  column name
  """
  id

  """
  column name
  """
  name
}

"""
columns and relationships of "prop"
"""
type prop {
  id: uuid!

  """
  An object relationship
  """
  propCollection: prop_c!
  prop_c_id: uuid!
  prop_type_id: uuid!

  """
  An object relationship
  """
  type: prop_type!

  """
  An array relationship
  """
  values(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_bool_exp
  ): [prop_value!]!

  """
  An aggregate relationship
  """
  values_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_bool_exp
  ): prop_value_aggregate!
}

"""
aggregated selection of "prop"
"""
type prop_aggregate {
  aggregate: prop_aggregate_fields
  nodes: [prop!]!
}

"""
aggregate fields of "prop"
"""
type prop_aggregate_fields {
  count(columns: [prop_select_column!], distinct: Boolean): Int!
  max: prop_max_fields
  min: prop_min_fields
}

"""
order by aggregate values of table "prop"
"""
input prop_aggregate_order_by {
  count: order_by
  max: prop_max_order_by
  min: prop_min_order_by
}

"""
input type for inserting array relation for remote table "prop"
"""
input prop_arr_rel_insert_input {
  data: [prop_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: prop_on_conflict
}

"""
Boolean expression to filter rows from the table "prop". All fields are combined with a logical 'AND'.
"""
input prop_bool_exp {
  _and: [prop_bool_exp!]
  _not: prop_bool_exp
  _or: [prop_bool_exp!]
  id: uuid_comparison_exp
  propCollection: prop_c_bool_exp
  prop_c_id: uuid_comparison_exp
  prop_type_id: uuid_comparison_exp
  type: prop_type_bool_exp
  values: prop_value_bool_exp
}

"""
columns and relationships of "prop_c"
"""
type prop_c {
  id: uuid!
  label: String
  libary_id: uuid!

  """
  An object relationship
  """
  library: library!

  """
  An array relationship
  """
  props(
    """
    distinct select on columns
    """
    distinct_on: [prop_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_order_by!]

    """
    filter the rows returned
    """
    where: prop_bool_exp
  ): [prop!]!

  """
  An aggregate relationship
  """
  props_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_order_by!]

    """
    filter the rows returned
    """
    where: prop_bool_exp
  ): prop_aggregate!

  """
  An array relationship
  """
  tags(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_c_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_c_bool_exp
  ): [tag_prop_c!]!

  """
  An aggregate relationship
  """
  tags_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_c_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_c_bool_exp
  ): tag_prop_c_aggregate!
}

"""
aggregated selection of "prop_c"
"""
type prop_c_aggregate {
  aggregate: prop_c_aggregate_fields
  nodes: [prop_c!]!
}

"""
aggregate fields of "prop_c"
"""
type prop_c_aggregate_fields {
  count(columns: [prop_c_select_column!], distinct: Boolean): Int!
  max: prop_c_max_fields
  min: prop_c_min_fields
}

"""
order by aggregate values of table "prop_c"
"""
input prop_c_aggregate_order_by {
  count: order_by
  max: prop_c_max_order_by
  min: prop_c_min_order_by
}

"""
input type for inserting array relation for remote table "prop_c"
"""
input prop_c_arr_rel_insert_input {
  data: [prop_c_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: prop_c_on_conflict
}

"""
Boolean expression to filter rows from the table "prop_c". All fields are combined with a logical 'AND'.
"""
input prop_c_bool_exp {
  _and: [prop_c_bool_exp!]
  _not: prop_c_bool_exp
  _or: [prop_c_bool_exp!]
  id: uuid_comparison_exp
  label: String_comparison_exp
  libary_id: uuid_comparison_exp
  library: library_bool_exp
  props: prop_bool_exp
  tags: tag_prop_c_bool_exp
}

"""
unique or primary key constraints on table "prop_c"
"""
enum prop_c_constraint {
  """
  unique or primary key constraint
  """
  prop_c_pkey
}

"""
input type for inserting data into table "prop_c"
"""
input prop_c_insert_input {
  id: uuid
  label: String
  libary_id: uuid
  library: library_obj_rel_insert_input
  props: prop_arr_rel_insert_input
  tags: tag_prop_c_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type prop_c_max_fields {
  id: uuid
  label: String
  libary_id: uuid
}

"""
order by max() on columns of table "prop_c"
"""
input prop_c_max_order_by {
  id: order_by
  label: order_by
  libary_id: order_by
}

"""
aggregate min on columns
"""
type prop_c_min_fields {
  id: uuid
  label: String
  libary_id: uuid
}

"""
order by min() on columns of table "prop_c"
"""
input prop_c_min_order_by {
  id: order_by
  label: order_by
  libary_id: order_by
}

"""
response of any mutation on the table "prop_c"
"""
type prop_c_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [prop_c!]!
}

"""
input type for inserting object relation for remote table "prop_c"
"""
input prop_c_obj_rel_insert_input {
  data: prop_c_insert_input!

  """
  on conflict condition
  """
  on_conflict: prop_c_on_conflict
}

"""
on conflict condition type for table "prop_c"
"""
input prop_c_on_conflict {
  constraint: prop_c_constraint!
  update_columns: [prop_c_update_column!]!
  where: prop_c_bool_exp
}

"""
Ordering options when selecting data from "prop_c".
"""
input prop_c_order_by {
  id: order_by
  label: order_by
  libary_id: order_by
  library: library_order_by
  props_aggregate: prop_aggregate_order_by
  tags_aggregate: tag_prop_c_aggregate_order_by
}

"""
primary key columns input for table: prop_c
"""
input prop_c_pk_columns_input {
  id: uuid!
}

"""
select columns of table "prop_c"
"""
enum prop_c_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  label

  """
  column name
  """
  libary_id
}

"""
input type for updating data in table "prop_c"
"""
input prop_c_set_input {
  id: uuid
  label: String
  libary_id: uuid
}

"""
update columns of table "prop_c"
"""
enum prop_c_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  label

  """
  column name
  """
  libary_id
}

"""
unique or primary key constraints on table "prop"
"""
enum prop_constraint {
  """
  unique or primary key constraint
  """
  props_pkey
}

"""
input type for inserting data into table "prop"
"""
input prop_insert_input {
  id: uuid
  propCollection: prop_c_obj_rel_insert_input
  prop_c_id: uuid
  prop_type_id: uuid
  type: prop_type_obj_rel_insert_input
  values: prop_value_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type prop_max_fields {
  id: uuid
  prop_c_id: uuid
  prop_type_id: uuid
}

"""
order by max() on columns of table "prop"
"""
input prop_max_order_by {
  id: order_by
  prop_c_id: order_by
  prop_type_id: order_by
}

"""
aggregate min on columns
"""
type prop_min_fields {
  id: uuid
  prop_c_id: uuid
  prop_type_id: uuid
}

"""
order by min() on columns of table "prop"
"""
input prop_min_order_by {
  id: order_by
  prop_c_id: order_by
  prop_type_id: order_by
}

"""
response of any mutation on the table "prop"
"""
type prop_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [prop!]!
}

"""
input type for inserting object relation for remote table "prop"
"""
input prop_obj_rel_insert_input {
  data: prop_insert_input!

  """
  on conflict condition
  """
  on_conflict: prop_on_conflict
}

"""
on conflict condition type for table "prop"
"""
input prop_on_conflict {
  constraint: prop_constraint!
  update_columns: [prop_update_column!]!
  where: prop_bool_exp
}

"""
Ordering options when selecting data from "prop".
"""
input prop_order_by {
  id: order_by
  propCollection: prop_c_order_by
  prop_c_id: order_by
  prop_type_id: order_by
  type: prop_type_order_by
  values_aggregate: prop_value_aggregate_order_by
}

"""
primary key columns input for table: prop
"""
input prop_pk_columns_input {
  id: uuid!
}

"""
select columns of table "prop"
"""
enum prop_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  prop_c_id

  """
  column name
  """
  prop_type_id
}

"""
input type for updating data in table "prop"
"""
input prop_set_input {
  id: uuid
  prop_c_id: uuid
  prop_type_id: uuid
}

"""
columns and relationships of "prop_type"
"""
type prop_type {
  id: uuid!
  isArray: Boolean!
  key: String!

  """
  An object relationship
  """
  propTypeCollection: prop_type_c!
  prop_type_c_id: uuid!

  """
  An object relationship
  """
  type: value_type!
  value_type: value_type_enum!
}

"""
aggregated selection of "prop_type"
"""
type prop_type_aggregate {
  aggregate: prop_type_aggregate_fields
  nodes: [prop_type!]!
}

"""
aggregate fields of "prop_type"
"""
type prop_type_aggregate_fields {
  count(columns: [prop_type_select_column!], distinct: Boolean): Int!
  max: prop_type_max_fields
  min: prop_type_min_fields
}

"""
order by aggregate values of table "prop_type"
"""
input prop_type_aggregate_order_by {
  count: order_by
  max: prop_type_max_order_by
  min: prop_type_min_order_by
}

"""
input type for inserting array relation for remote table "prop_type"
"""
input prop_type_arr_rel_insert_input {
  data: [prop_type_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: prop_type_on_conflict
}

"""
Boolean expression to filter rows from the table "prop_type". All fields are combined with a logical 'AND'.
"""
input prop_type_bool_exp {
  _and: [prop_type_bool_exp!]
  _not: prop_type_bool_exp
  _or: [prop_type_bool_exp!]
  id: uuid_comparison_exp
  isArray: Boolean_comparison_exp
  key: String_comparison_exp
  propTypeCollection: prop_type_c_bool_exp
  prop_type_c_id: uuid_comparison_exp
  type: value_type_bool_exp
  value_type: value_type_enum_comparison_exp
}

"""
columns and relationships of "prop_type_c"
"""
type prop_type_c {
  id: uuid!
  label: String

  """
  An object relationship
  """
  library: library!
  library_id: uuid!

  """
  An array relationship
  """
  propTypes(
    """
    distinct select on columns
    """
    distinct_on: [prop_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_type_order_by!]

    """
    filter the rows returned
    """
    where: prop_type_bool_exp
  ): [prop_type!]!

  """
  An aggregate relationship
  """
  propTypes_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_type_order_by!]

    """
    filter the rows returned
    """
    where: prop_type_bool_exp
  ): prop_type_aggregate!

  """
  An array relationship
  """
  tags(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_type_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_type_c_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_type_c_bool_exp
  ): [tag_prop_type_c!]!

  """
  An aggregate relationship
  """
  tags_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_type_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_type_c_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_type_c_bool_exp
  ): tag_prop_type_c_aggregate!
}

"""
aggregated selection of "prop_type_c"
"""
type prop_type_c_aggregate {
  aggregate: prop_type_c_aggregate_fields
  nodes: [prop_type_c!]!
}

"""
aggregate fields of "prop_type_c"
"""
type prop_type_c_aggregate_fields {
  count(columns: [prop_type_c_select_column!], distinct: Boolean): Int!
  max: prop_type_c_max_fields
  min: prop_type_c_min_fields
}

"""
order by aggregate values of table "prop_type_c"
"""
input prop_type_c_aggregate_order_by {
  count: order_by
  max: prop_type_c_max_order_by
  min: prop_type_c_min_order_by
}

"""
input type for inserting array relation for remote table "prop_type_c"
"""
input prop_type_c_arr_rel_insert_input {
  data: [prop_type_c_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: prop_type_c_on_conflict
}

"""
Boolean expression to filter rows from the table "prop_type_c". All fields are combined with a logical 'AND'.
"""
input prop_type_c_bool_exp {
  _and: [prop_type_c_bool_exp!]
  _not: prop_type_c_bool_exp
  _or: [prop_type_c_bool_exp!]
  id: uuid_comparison_exp
  label: String_comparison_exp
  library: library_bool_exp
  library_id: uuid_comparison_exp
  propTypes: prop_type_bool_exp
  tags: tag_prop_type_c_bool_exp
}

"""
unique or primary key constraints on table "prop_type_c"
"""
enum prop_type_c_constraint {
  """
  unique or primary key constraint
  """
  prop_type_c_pkey
}

"""
input type for inserting data into table "prop_type_c"
"""
input prop_type_c_insert_input {
  id: uuid
  label: String
  library: library_obj_rel_insert_input
  library_id: uuid
  propTypes: prop_type_arr_rel_insert_input
  tags: tag_prop_type_c_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type prop_type_c_max_fields {
  id: uuid
  label: String
  library_id: uuid
}

"""
order by max() on columns of table "prop_type_c"
"""
input prop_type_c_max_order_by {
  id: order_by
  label: order_by
  library_id: order_by
}

"""
aggregate min on columns
"""
type prop_type_c_min_fields {
  id: uuid
  label: String
  library_id: uuid
}

"""
order by min() on columns of table "prop_type_c"
"""
input prop_type_c_min_order_by {
  id: order_by
  label: order_by
  library_id: order_by
}

"""
response of any mutation on the table "prop_type_c"
"""
type prop_type_c_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [prop_type_c!]!
}

"""
input type for inserting object relation for remote table "prop_type_c"
"""
input prop_type_c_obj_rel_insert_input {
  data: prop_type_c_insert_input!

  """
  on conflict condition
  """
  on_conflict: prop_type_c_on_conflict
}

"""
on conflict condition type for table "prop_type_c"
"""
input prop_type_c_on_conflict {
  constraint: prop_type_c_constraint!
  update_columns: [prop_type_c_update_column!]!
  where: prop_type_c_bool_exp
}

"""
Ordering options when selecting data from "prop_type_c".
"""
input prop_type_c_order_by {
  id: order_by
  label: order_by
  library: library_order_by
  library_id: order_by
  propTypes_aggregate: prop_type_aggregate_order_by
  tags_aggregate: tag_prop_type_c_aggregate_order_by
}

"""
primary key columns input for table: prop_type_c
"""
input prop_type_c_pk_columns_input {
  id: uuid!
}

"""
select columns of table "prop_type_c"
"""
enum prop_type_c_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  label

  """
  column name
  """
  library_id
}

"""
input type for updating data in table "prop_type_c"
"""
input prop_type_c_set_input {
  id: uuid
  label: String
  library_id: uuid
}

"""
update columns of table "prop_type_c"
"""
enum prop_type_c_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  label

  """
  column name
  """
  library_id
}

"""
unique or primary key constraints on table "prop_type"
"""
enum prop_type_constraint {
  """
  unique or primary key constraint
  """
  prop_type_key_prop_type_c_id_key

  """
  unique or primary key constraint
  """
  prop_type_pkey
}

"""
input type for inserting data into table "prop_type"
"""
input prop_type_insert_input {
  id: uuid
  isArray: Boolean
  key: String
  propTypeCollection: prop_type_c_obj_rel_insert_input
  prop_type_c_id: uuid
  type: value_type_obj_rel_insert_input
  value_type: value_type_enum
}

"""
aggregate max on columns
"""
type prop_type_max_fields {
  id: uuid
  key: String
  prop_type_c_id: uuid
}

"""
order by max() on columns of table "prop_type"
"""
input prop_type_max_order_by {
  id: order_by
  key: order_by
  prop_type_c_id: order_by
}

"""
aggregate min on columns
"""
type prop_type_min_fields {
  id: uuid
  key: String
  prop_type_c_id: uuid
}

"""
order by min() on columns of table "prop_type"
"""
input prop_type_min_order_by {
  id: order_by
  key: order_by
  prop_type_c_id: order_by
}

"""
response of any mutation on the table "prop_type"
"""
type prop_type_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [prop_type!]!
}

"""
input type for inserting object relation for remote table "prop_type"
"""
input prop_type_obj_rel_insert_input {
  data: prop_type_insert_input!

  """
  on conflict condition
  """
  on_conflict: prop_type_on_conflict
}

"""
on conflict condition type for table "prop_type"
"""
input prop_type_on_conflict {
  constraint: prop_type_constraint!
  update_columns: [prop_type_update_column!]!
  where: prop_type_bool_exp
}

"""
Ordering options when selecting data from "prop_type".
"""
input prop_type_order_by {
  id: order_by
  isArray: order_by
  key: order_by
  propTypeCollection: prop_type_c_order_by
  prop_type_c_id: order_by
  type: value_type_order_by
  value_type: order_by
}

"""
primary key columns input for table: prop_type
"""
input prop_type_pk_columns_input {
  id: uuid!
}

"""
select columns of table "prop_type"
"""
enum prop_type_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  isArray

  """
  column name
  """
  key

  """
  column name
  """
  prop_type_c_id

  """
  column name
  """
  value_type
}

"""
input type for updating data in table "prop_type"
"""
input prop_type_set_input {
  id: uuid
  isArray: Boolean
  key: String
  prop_type_c_id: uuid
  value_type: value_type_enum
}

"""
update columns of table "prop_type"
"""
enum prop_type_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  isArray

  """
  column name
  """
  key

  """
  column name
  """
  prop_type_c_id

  """
  column name
  """
  value_type
}

"""
update columns of table "prop"
"""
enum prop_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  prop_c_id

  """
  column name
  """
  prop_type_id
}

"""
columns and relationships of "prop_value"
"""
type prop_value {
  id: uuid!

  """
  An object relationship
  """
  prop: prop!

  """
  This is the prop that owns this value
  """
  prop_id: uuid!

  """
  An array relationship
  """
  tags(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_value_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_value_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_value_bool_exp
  ): [tag_prop_value!]!

  """
  An aggregate relationship
  """
  tags_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_value_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_value_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_value_bool_exp
  ): tag_prop_value_aggregate!
  type: value_type_enum!

  """
  An object relationship
  """
  typeEntity: value_type!
  value: String
}

"""
aggregated selection of "prop_value"
"""
type prop_value_aggregate {
  aggregate: prop_value_aggregate_fields
  nodes: [prop_value!]!
}

"""
aggregate fields of "prop_value"
"""
type prop_value_aggregate_fields {
  count(columns: [prop_value_select_column!], distinct: Boolean): Int!
  max: prop_value_max_fields
  min: prop_value_min_fields
}

"""
order by aggregate values of table "prop_value"
"""
input prop_value_aggregate_order_by {
  count: order_by
  max: prop_value_max_order_by
  min: prop_value_min_order_by
}

"""
input type for inserting array relation for remote table "prop_value"
"""
input prop_value_arr_rel_insert_input {
  data: [prop_value_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: prop_value_on_conflict
}

"""
Boolean expression to filter rows from the table "prop_value". All fields are combined with a logical 'AND'.
"""
input prop_value_bool_exp {
  _and: [prop_value_bool_exp!]
  _not: prop_value_bool_exp
  _or: [prop_value_bool_exp!]
  id: uuid_comparison_exp
  prop: prop_bool_exp
  prop_id: uuid_comparison_exp
  tags: tag_prop_value_bool_exp
  type: value_type_enum_comparison_exp
  typeEntity: value_type_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "prop_value"
"""
enum prop_value_constraint {
  """
  unique or primary key constraint
  """
  prop_values_pkey
}

"""
input type for inserting data into table "prop_value"
"""
input prop_value_insert_input {
  id: uuid
  prop: prop_obj_rel_insert_input

  """
  This is the prop that owns this value
  """
  prop_id: uuid
  tags: tag_prop_value_arr_rel_insert_input
  type: value_type_enum
  typeEntity: value_type_obj_rel_insert_input
  value: String
}

"""
aggregate max on columns
"""
type prop_value_max_fields {
  id: uuid

  """
  This is the prop that owns this value
  """
  prop_id: uuid
  value: String
}

"""
order by max() on columns of table "prop_value"
"""
input prop_value_max_order_by {
  id: order_by

  """
  This is the prop that owns this value
  """
  prop_id: order_by
  value: order_by
}

"""
aggregate min on columns
"""
type prop_value_min_fields {
  id: uuid

  """
  This is the prop that owns this value
  """
  prop_id: uuid
  value: String
}

"""
order by min() on columns of table "prop_value"
"""
input prop_value_min_order_by {
  id: order_by

  """
  This is the prop that owns this value
  """
  prop_id: order_by
  value: order_by
}

"""
response of any mutation on the table "prop_value"
"""
type prop_value_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [prop_value!]!
}

"""
input type for inserting object relation for remote table "prop_value"
"""
input prop_value_obj_rel_insert_input {
  data: prop_value_insert_input!

  """
  on conflict condition
  """
  on_conflict: prop_value_on_conflict
}

"""
on conflict condition type for table "prop_value"
"""
input prop_value_on_conflict {
  constraint: prop_value_constraint!
  update_columns: [prop_value_update_column!]!
  where: prop_value_bool_exp
}

"""
Ordering options when selecting data from "prop_value".
"""
input prop_value_order_by {
  id: order_by
  prop: prop_order_by
  prop_id: order_by
  tags_aggregate: tag_prop_value_aggregate_order_by
  type: order_by
  typeEntity: value_type_order_by
  value: order_by
}

"""
primary key columns input for table: prop_value
"""
input prop_value_pk_columns_input {
  id: uuid!
}

"""
select columns of table "prop_value"
"""
enum prop_value_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  prop_id

  """
  column name
  """
  type

  """
  column name
  """
  value
}

"""
input type for updating data in table "prop_value"
"""
input prop_value_set_input {
  id: uuid

  """
  This is the prop that owns this value
  """
  prop_id: uuid
  type: value_type_enum
  value: String
}

"""
update columns of table "prop_value"
"""
enum prop_value_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  prop_id

  """
  column name
  """
  type

  """
  column name
  """
  value
}

type query_root {
  """
  fetch data from the table: "app"
  """
  app(
    """
    distinct select on columns
    """
    distinct_on: [app_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [app_order_by!]

    """
    filter the rows returned
    """
    where: app_bool_exp
  ): [app!]!

  """
  fetch aggregated fields from the table: "app"
  """
  app_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [app_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [app_order_by!]

    """
    filter the rows returned
    """
    where: app_bool_exp
  ): app_aggregate!

  """
  fetch data from the table: "app" using primary key columns
  """
  app_by_pk(id: uuid!): app

  """
  fetch data from the table: "atom"
  """
  atom(
    """
    distinct select on columns
    """
    distinct_on: [atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_order_by!]

    """
    filter the rows returned
    """
    where: atom_bool_exp
  ): [atom!]!

  """
  fetch aggregated fields from the table: "atom"
  """
  atom_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_order_by!]

    """
    filter the rows returned
    """
    where: atom_bool_exp
  ): atom_aggregate!

  """
  fetch data from the table: "atom" using primary key columns
  """
  atom_by_pk(id: uuid!): atom

  """
  fetch data from the table: "atom_type"
  """
  atom_type(
    """
    distinct select on columns
    """
    distinct_on: [atom_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_type_order_by!]

    """
    filter the rows returned
    """
    where: atom_type_bool_exp
  ): [atom_type!]!

  """
  fetch aggregated fields from the table: "atom_type"
  """
  atom_type_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [atom_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_type_order_by!]

    """
    filter the rows returned
    """
    where: atom_type_bool_exp
  ): atom_type_aggregate!

  """
  fetch data from the table: "atom_type" using primary key columns
  """
  atom_type_by_pk(value: String!): atom_type

  """
  fetch data from the table: "category"
  """
  category(
    """
    distinct select on columns
    """
    distinct_on: [category_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [category_order_by!]

    """
    filter the rows returned
    """
    where: category_bool_exp
  ): [category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  category_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [category_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [category_order_by!]

    """
    filter the rows returned
    """
    where: category_bool_exp
  ): category_aggregate!

  """
  fetch data from the table: "category" using primary key columns
  """
  category_by_pk(id: uuid!): category

  """
  fetch data from the table: "component"
  """
  component(
    """
    distinct select on columns
    """
    distinct_on: [component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_order_by!]

    """
    filter the rows returned
    """
    where: component_bool_exp
  ): [component!]!

  """
  fetch aggregated fields from the table: "component"
  """
  component_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_order_by!]

    """
    filter the rows returned
    """
    where: component_bool_exp
  ): component_aggregate!

  """
  fetch data from the table: "component" using primary key columns
  """
  component_by_pk(id: uuid!): component

  """
  fetch data from the table: "component_element"
  """
  component_element(
    """
    distinct select on columns
    """
    distinct_on: [component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_element_order_by!]

    """
    filter the rows returned
    """
    where: component_element_bool_exp
  ): [component_element!]!

  """
  fetch aggregated fields from the table: "component_element"
  """
  component_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_element_order_by!]

    """
    filter the rows returned
    """
    where: component_element_bool_exp
  ): component_element_aggregate!

  """
  fetch data from the table: "component_element" using primary key columns
  """
  component_element_by_pk(id: uuid!): component_element

  """
  fetch data from the table: "component_link"
  """
  component_link(
    """
    distinct select on columns
    """
    distinct_on: [component_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_link_order_by!]

    """
    filter the rows returned
    """
    where: component_link_bool_exp
  ): [component_link!]!

  """
  fetch aggregated fields from the table: "component_link"
  """
  component_link_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_link_order_by!]

    """
    filter the rows returned
    """
    where: component_link_bool_exp
  ): component_link_aggregate!

  """
  fetch data from the table: "component_link" using primary key columns
  """
  component_link_by_pk(id: uuid!): component_link

  """
  execute function "get_current_user" which returns "user"
  """
  get_current_user(
    """
    input parameters for function "get_current_user"
    """
    args: get_current_user_args!

    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): [user!]!

  """
  execute function "get_current_user" and query aggregates on result of table type "user"
  """
  get_current_user_aggregate(
    """
    input parameters for function "get_current_user"
    """
    args: get_current_user_args!

    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): user_aggregate!

  """
  fetch data from the table: "hoc"
  """
  hoc(
    """
    distinct select on columns
    """
    distinct_on: [hoc_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [hoc_order_by!]

    """
    filter the rows returned
    """
    where: hoc_bool_exp
  ): [hoc!]!

  """
  fetch aggregated fields from the table: "hoc"
  """
  hoc_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [hoc_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [hoc_order_by!]

    """
    filter the rows returned
    """
    where: hoc_bool_exp
  ): hoc_aggregate!

  """
  fetch data from the table: "hoc" using primary key columns
  """
  hoc_by_pk(id: uuid!): hoc

  """
  fetch data from the table: "hoc_component_element"
  """
  hoc_component_element(
    """
    distinct select on columns
    """
    distinct_on: [hoc_component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [hoc_component_element_order_by!]

    """
    filter the rows returned
    """
    where: hoc_component_element_bool_exp
  ): [hoc_component_element!]!

  """
  fetch aggregated fields from the table: "hoc_component_element"
  """
  hoc_component_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [hoc_component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [hoc_component_element_order_by!]

    """
    filter the rows returned
    """
    where: hoc_component_element_bool_exp
  ): hoc_component_element_aggregate!

  """
  fetch data from the table: "hoc_component_element" using primary key columns
  """
  hoc_component_element_by_pk(
    component_element_id: uuid!
    hoc_id: uuid!
  ): hoc_component_element

  """
  fetch data from the table: "lambda"
  """
  lambda(
    """
    distinct select on columns
    """
    distinct_on: [lambda_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [lambda_order_by!]

    """
    filter the rows returned
    """
    where: lambda_bool_exp
  ): [lambda!]!

  """
  fetch aggregated fields from the table: "lambda"
  """
  lambda_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [lambda_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [lambda_order_by!]

    """
    filter the rows returned
    """
    where: lambda_bool_exp
  ): lambda_aggregate!

  """
  fetch data from the table: "lambda" using primary key columns
  """
  lambda_by_pk(id: uuid!): lambda

  """
  fetch data from the table: "library"
  """
  library(
    """
    distinct select on columns
    """
    distinct_on: [library_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [library_order_by!]

    """
    filter the rows returned
    """
    where: library_bool_exp
  ): [library!]!

  """
  fetch aggregated fields from the table: "library"
  """
  library_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [library_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [library_order_by!]

    """
    filter the rows returned
    """
    where: library_bool_exp
  ): library_aggregate!

  """
  fetch data from the table: "library" using primary key columns
  """
  library_by_pk(id: uuid!): library

  """
  fetch data from the table: "page"
  """
  page(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): [page!]!

  """
  fetch aggregated fields from the table: "page"
  """
  page_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): page_aggregate!

  """
  fetch data from the table: "page" using primary key columns
  """
  page_by_pk(id: uuid!): page

  """
  fetch data from the table: "page_element"
  """
  page_element(
    """
    distinct select on columns
    """
    distinct_on: [page_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_element_order_by!]

    """
    filter the rows returned
    """
    where: page_element_bool_exp
  ): [page_element!]!

  """
  fetch aggregated fields from the table: "page_element"
  """
  page_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_element_order_by!]

    """
    filter the rows returned
    """
    where: page_element_bool_exp
  ): page_element_aggregate!

  """
  fetch data from the table: "page_element" using primary key columns
  """
  page_element_by_pk(id: uuid!): page_element

  """
  fetch data from the table: "page_link"
  """
  page_link(
    """
    distinct select on columns
    """
    distinct_on: [page_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_link_order_by!]

    """
    filter the rows returned
    """
    where: page_link_bool_exp
  ): [page_link!]!

  """
  fetch aggregated fields from the table: "page_link"
  """
  page_link_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_link_order_by!]

    """
    filter the rows returned
    """
    where: page_link_bool_exp
  ): page_link_aggregate!

  """
  fetch data from the table: "page_link" using primary key columns
  """
  page_link_by_pk(id: uuid!): page_link

  """
  fetch data from the table: "prop"
  """
  prop(
    """
    distinct select on columns
    """
    distinct_on: [prop_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_order_by!]

    """
    filter the rows returned
    """
    where: prop_bool_exp
  ): [prop!]!

  """
  fetch aggregated fields from the table: "prop"
  """
  prop_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_order_by!]

    """
    filter the rows returned
    """
    where: prop_bool_exp
  ): prop_aggregate!

  """
  fetch data from the table: "prop" using primary key columns
  """
  prop_by_pk(id: uuid!): prop

  """
  fetch data from the table: "prop_c"
  """
  prop_c(
    """
    distinct select on columns
    """
    distinct_on: [prop_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_c_order_by!]

    """
    filter the rows returned
    """
    where: prop_c_bool_exp
  ): [prop_c!]!

  """
  fetch aggregated fields from the table: "prop_c"
  """
  prop_c_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_c_order_by!]

    """
    filter the rows returned
    """
    where: prop_c_bool_exp
  ): prop_c_aggregate!

  """
  fetch data from the table: "prop_c" using primary key columns
  """
  prop_c_by_pk(id: uuid!): prop_c

  """
  fetch data from the table: "prop_type"
  """
  prop_type(
    """
    distinct select on columns
    """
    distinct_on: [prop_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_type_order_by!]

    """
    filter the rows returned
    """
    where: prop_type_bool_exp
  ): [prop_type!]!

  """
  fetch aggregated fields from the table: "prop_type"
  """
  prop_type_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_type_order_by!]

    """
    filter the rows returned
    """
    where: prop_type_bool_exp
  ): prop_type_aggregate!

  """
  fetch data from the table: "prop_type" using primary key columns
  """
  prop_type_by_pk(id: uuid!): prop_type

  """
  fetch data from the table: "prop_type_c"
  """
  prop_type_c(
    """
    distinct select on columns
    """
    distinct_on: [prop_type_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_type_c_order_by!]

    """
    filter the rows returned
    """
    where: prop_type_c_bool_exp
  ): [prop_type_c!]!

  """
  fetch aggregated fields from the table: "prop_type_c"
  """
  prop_type_c_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_type_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_type_c_order_by!]

    """
    filter the rows returned
    """
    where: prop_type_c_bool_exp
  ): prop_type_c_aggregate!

  """
  fetch data from the table: "prop_type_c" using primary key columns
  """
  prop_type_c_by_pk(id: uuid!): prop_type_c

  """
  fetch data from the table: "prop_value"
  """
  prop_value(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_bool_exp
  ): [prop_value!]!

  """
  fetch aggregated fields from the table: "prop_value"
  """
  prop_value_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_bool_exp
  ): prop_value_aggregate!

  """
  fetch data from the table: "prop_value" using primary key columns
  """
  prop_value_by_pk(id: uuid!): prop_value

  """
  fetch data from the table: "style"
  """
  style(
    """
    distinct select on columns
    """
    distinct_on: [style_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_order_by!]

    """
    filter the rows returned
    """
    where: style_bool_exp
  ): [style!]!

  """
  fetch aggregated fields from the table: "style"
  """
  style_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [style_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_order_by!]

    """
    filter the rows returned
    """
    where: style_bool_exp
  ): style_aggregate!

  """
  fetch data from the table: "style_atom"
  """
  style_atom(
    """
    distinct select on columns
    """
    distinct_on: [style_atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_atom_order_by!]

    """
    filter the rows returned
    """
    where: style_atom_bool_exp
  ): [style_atom!]!

  """
  fetch aggregated fields from the table: "style_atom"
  """
  style_atom_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [style_atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_atom_order_by!]

    """
    filter the rows returned
    """
    where: style_atom_bool_exp
  ): style_atom_aggregate!

  """
  fetch data from the table: "style_atom" using primary key columns
  """
  style_atom_by_pk(atom_id: uuid!, style_id: uuid!): style_atom

  """
  fetch data from the table: "style" using primary key columns
  """
  style_by_pk(id: uuid!): style

  """
  fetch data from the table: "style_component_element"
  """
  style_component_element(
    """
    distinct select on columns
    """
    distinct_on: [style_component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_component_element_order_by!]

    """
    filter the rows returned
    """
    where: style_component_element_bool_exp
  ): [style_component_element!]!

  """
  fetch aggregated fields from the table: "style_component_element"
  """
  style_component_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [style_component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_component_element_order_by!]

    """
    filter the rows returned
    """
    where: style_component_element_bool_exp
  ): style_component_element_aggregate!

  """
  fetch data from the table: "style_component_element" using primary key columns
  """
  style_component_element_by_pk(
    component_element_id: uuid!
    style_id: uuid!
  ): style_component_element

  """
  fetch data from the table: "style_page_element"
  """
  style_page_element(
    """
    distinct select on columns
    """
    distinct_on: [style_page_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_page_element_order_by!]

    """
    filter the rows returned
    """
    where: style_page_element_bool_exp
  ): [style_page_element!]!

  """
  fetch aggregated fields from the table: "style_page_element"
  """
  style_page_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [style_page_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_page_element_order_by!]

    """
    filter the rows returned
    """
    where: style_page_element_bool_exp
  ): style_page_element_aggregate!

  """
  fetch data from the table: "style_page_element" using primary key columns
  """
  style_page_element_by_pk(
    page_element_id: uuid!
    style_id: uuid!
  ): style_page_element

  """
  fetch data from the table: "tag"
  """
  tag(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): [tag!]!

  """
  fetch aggregated fields from the table: "tag"
  """
  tag_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): tag_aggregate!

  """
  fetch data from the table: "tag_atom"
  """
  tag_atom(
    """
    distinct select on columns
    """
    distinct_on: [tag_atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_atom_order_by!]

    """
    filter the rows returned
    """
    where: tag_atom_bool_exp
  ): [tag_atom!]!

  """
  fetch aggregated fields from the table: "tag_atom"
  """
  tag_atom_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_atom_order_by!]

    """
    filter the rows returned
    """
    where: tag_atom_bool_exp
  ): tag_atom_aggregate!

  """
  fetch data from the table: "tag_atom" using primary key columns
  """
  tag_atom_by_pk(atom_id: uuid!, tag_id: uuid!): tag_atom

  """
  fetch data from the table: "tag" using primary key columns
  """
  tag_by_pk(id: uuid!): tag

  """
  fetch data from the table: "tag_component"
  """
  tag_component(
    """
    distinct select on columns
    """
    distinct_on: [tag_component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_component_order_by!]

    """
    filter the rows returned
    """
    where: tag_component_bool_exp
  ): [tag_component!]!

  """
  fetch aggregated fields from the table: "tag_component"
  """
  tag_component_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_component_order_by!]

    """
    filter the rows returned
    """
    where: tag_component_bool_exp
  ): tag_component_aggregate!

  """
  fetch data from the table: "tag_component" using primary key columns
  """
  tag_component_by_pk(component_id: uuid!, tag_id: uuid!): tag_component

  """
  fetch data from the table: "tag_hoc"
  """
  tag_hoc(
    """
    distinct select on columns
    """
    distinct_on: [tag_hoc_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_hoc_order_by!]

    """
    filter the rows returned
    """
    where: tag_hoc_bool_exp
  ): [tag_hoc!]!

  """
  fetch aggregated fields from the table: "tag_hoc"
  """
  tag_hoc_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_hoc_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_hoc_order_by!]

    """
    filter the rows returned
    """
    where: tag_hoc_bool_exp
  ): tag_hoc_aggregate!

  """
  fetch data from the table: "tag_hoc" using primary key columns
  """
  tag_hoc_by_pk(hoc_id: uuid!, tag_id: uuid!): tag_hoc

  """
  fetch data from the table: "tag_prop_c"
  """
  tag_prop_c(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_c_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_c_bool_exp
  ): [tag_prop_c!]!

  """
  fetch aggregated fields from the table: "tag_prop_c"
  """
  tag_prop_c_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_c_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_c_bool_exp
  ): tag_prop_c_aggregate!

  """
  fetch data from the table: "tag_prop_c" using primary key columns
  """
  tag_prop_c_by_pk(prop_c_id: uuid!, tag_id: uuid!): tag_prop_c

  """
  fetch data from the table: "tag_prop_type_c"
  """
  tag_prop_type_c(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_type_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_type_c_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_type_c_bool_exp
  ): [tag_prop_type_c!]!

  """
  fetch aggregated fields from the table: "tag_prop_type_c"
  """
  tag_prop_type_c_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_type_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_type_c_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_type_c_bool_exp
  ): tag_prop_type_c_aggregate!

  """
  fetch data from the table: "tag_prop_type_c" using primary key columns
  """
  tag_prop_type_c_by_pk(prop_type_c_id: uuid!, tag_id: uuid!): tag_prop_type_c

  """
  fetch data from the table: "tag_prop_value"
  """
  tag_prop_value(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_value_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_value_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_value_bool_exp
  ): [tag_prop_value!]!

  """
  fetch aggregated fields from the table: "tag_prop_value"
  """
  tag_prop_value_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_value_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_value_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_value_bool_exp
  ): tag_prop_value_aggregate!

  """
  fetch data from the table: "tag_prop_value" using primary key columns
  """
  tag_prop_value_by_pk(prop_value_id: uuid!, tag_id: uuid!): tag_prop_value

  """
  fetch data from the table: "tag_style"
  """
  tag_style(
    """
    distinct select on columns
    """
    distinct_on: [tag_style_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_style_order_by!]

    """
    filter the rows returned
    """
    where: tag_style_bool_exp
  ): [tag_style!]!

  """
  fetch aggregated fields from the table: "tag_style"
  """
  tag_style_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_style_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_style_order_by!]

    """
    filter the rows returned
    """
    where: tag_style_bool_exp
  ): tag_style_aggregate!

  """
  fetch data from the table: "tag_style" using primary key columns
  """
  tag_style_by_pk(style_id: uuid!, tag_id: uuid!): tag_style

  """
  fetch data from the table: "user"
  """
  user(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): user_aggregate!

  """
  fetch data from the table: "user" using primary key columns
  """
  user_by_pk(id: String!): user

  """
  fetch data from the table: "value_type"
  """
  value_type(
    """
    distinct select on columns
    """
    distinct_on: [value_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [value_type_order_by!]

    """
    filter the rows returned
    """
    where: value_type_bool_exp
  ): [value_type!]!

  """
  fetch aggregated fields from the table: "value_type"
  """
  value_type_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [value_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [value_type_order_by!]

    """
    filter the rows returned
    """
    where: value_type_bool_exp
  ): value_type_aggregate!

  """
  fetch data from the table: "value_type" using primary key columns
  """
  value_type_by_pk(value: String!): value_type
}

"""
columns and relationships of "style"
"""
type style {
  id: uuid!

  """
  An object relationship
  """
  library: library!
  library_id: uuid!
  name: String!

  """
  An object relationship
  """
  propCollection: prop_c
  prop_c_id: uuid
}

"""
aggregated selection of "style"
"""
type style_aggregate {
  aggregate: style_aggregate_fields
  nodes: [style!]!
}

"""
aggregate fields of "style"
"""
type style_aggregate_fields {
  count(columns: [style_select_column!], distinct: Boolean): Int!
  max: style_max_fields
  min: style_min_fields
}

"""
order by aggregate values of table "style"
"""
input style_aggregate_order_by {
  count: order_by
  max: style_max_order_by
  min: style_min_order_by
}

"""
input type for inserting array relation for remote table "style"
"""
input style_arr_rel_insert_input {
  data: [style_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: style_on_conflict
}

"""
columns and relationships of "style_atom"
"""
type style_atom {
  """
  An object relationship
  """
  atom: atom!
  atom_id: uuid!

  """
  An object relationship
  """
  style: style!
  style_id: uuid!
}

"""
aggregated selection of "style_atom"
"""
type style_atom_aggregate {
  aggregate: style_atom_aggregate_fields
  nodes: [style_atom!]!
}

"""
aggregate fields of "style_atom"
"""
type style_atom_aggregate_fields {
  count(columns: [style_atom_select_column!], distinct: Boolean): Int!
  max: style_atom_max_fields
  min: style_atom_min_fields
}

"""
order by aggregate values of table "style_atom"
"""
input style_atom_aggregate_order_by {
  count: order_by
  max: style_atom_max_order_by
  min: style_atom_min_order_by
}

"""
input type for inserting array relation for remote table "style_atom"
"""
input style_atom_arr_rel_insert_input {
  data: [style_atom_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: style_atom_on_conflict
}

"""
Boolean expression to filter rows from the table "style_atom". All fields are combined with a logical 'AND'.
"""
input style_atom_bool_exp {
  _and: [style_atom_bool_exp!]
  _not: style_atom_bool_exp
  _or: [style_atom_bool_exp!]
  atom: atom_bool_exp
  atom_id: uuid_comparison_exp
  style: style_bool_exp
  style_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "style_atom"
"""
enum style_atom_constraint {
  """
  unique or primary key constraint
  """
  style_atom_pkey
}

"""
input type for inserting data into table "style_atom"
"""
input style_atom_insert_input {
  atom: atom_obj_rel_insert_input
  atom_id: uuid
  style: style_obj_rel_insert_input
  style_id: uuid
}

"""
aggregate max on columns
"""
type style_atom_max_fields {
  atom_id: uuid
  style_id: uuid
}

"""
order by max() on columns of table "style_atom"
"""
input style_atom_max_order_by {
  atom_id: order_by
  style_id: order_by
}

"""
aggregate min on columns
"""
type style_atom_min_fields {
  atom_id: uuid
  style_id: uuid
}

"""
order by min() on columns of table "style_atom"
"""
input style_atom_min_order_by {
  atom_id: order_by
  style_id: order_by
}

"""
response of any mutation on the table "style_atom"
"""
type style_atom_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [style_atom!]!
}

"""
on conflict condition type for table "style_atom"
"""
input style_atom_on_conflict {
  constraint: style_atom_constraint!
  update_columns: [style_atom_update_column!]!
  where: style_atom_bool_exp
}

"""
Ordering options when selecting data from "style_atom".
"""
input style_atom_order_by {
  atom: atom_order_by
  atom_id: order_by
  style: style_order_by
  style_id: order_by
}

"""
primary key columns input for table: style_atom
"""
input style_atom_pk_columns_input {
  atom_id: uuid!
  style_id: uuid!
}

"""
select columns of table "style_atom"
"""
enum style_atom_select_column {
  """
  column name
  """
  atom_id

  """
  column name
  """
  style_id
}

"""
input type for updating data in table "style_atom"
"""
input style_atom_set_input {
  atom_id: uuid
  style_id: uuid
}

"""
update columns of table "style_atom"
"""
enum style_atom_update_column {
  """
  column name
  """
  atom_id

  """
  column name
  """
  style_id
}

"""
Boolean expression to filter rows from the table "style". All fields are combined with a logical 'AND'.
"""
input style_bool_exp {
  _and: [style_bool_exp!]
  _not: style_bool_exp
  _or: [style_bool_exp!]
  id: uuid_comparison_exp
  library: library_bool_exp
  library_id: uuid_comparison_exp
  name: String_comparison_exp
  propCollection: prop_c_bool_exp
  prop_c_id: uuid_comparison_exp
}

"""
columns and relationships of "style_component_element"
"""
type style_component_element {
  """
  An object relationship
  """
  componentElement: component_element!
  component_element_id: uuid!

  """
  An object relationship
  """
  style: style!
  style_id: uuid!
}

"""
aggregated selection of "style_component_element"
"""
type style_component_element_aggregate {
  aggregate: style_component_element_aggregate_fields
  nodes: [style_component_element!]!
}

"""
aggregate fields of "style_component_element"
"""
type style_component_element_aggregate_fields {
  count(
    columns: [style_component_element_select_column!]
    distinct: Boolean
  ): Int!
  max: style_component_element_max_fields
  min: style_component_element_min_fields
}

"""
order by aggregate values of table "style_component_element"
"""
input style_component_element_aggregate_order_by {
  count: order_by
  max: style_component_element_max_order_by
  min: style_component_element_min_order_by
}

"""
input type for inserting array relation for remote table "style_component_element"
"""
input style_component_element_arr_rel_insert_input {
  data: [style_component_element_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: style_component_element_on_conflict
}

"""
Boolean expression to filter rows from the table "style_component_element". All fields are combined with a logical 'AND'.
"""
input style_component_element_bool_exp {
  _and: [style_component_element_bool_exp!]
  _not: style_component_element_bool_exp
  _or: [style_component_element_bool_exp!]
  componentElement: component_element_bool_exp
  component_element_id: uuid_comparison_exp
  style: style_bool_exp
  style_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "style_component_element"
"""
enum style_component_element_constraint {
  """
  unique or primary key constraint
  """
  style_component_element_pkey
}

"""
input type for inserting data into table "style_component_element"
"""
input style_component_element_insert_input {
  componentElement: component_element_obj_rel_insert_input
  component_element_id: uuid
  style: style_obj_rel_insert_input
  style_id: uuid
}

"""
aggregate max on columns
"""
type style_component_element_max_fields {
  component_element_id: uuid
  style_id: uuid
}

"""
order by max() on columns of table "style_component_element"
"""
input style_component_element_max_order_by {
  component_element_id: order_by
  style_id: order_by
}

"""
aggregate min on columns
"""
type style_component_element_min_fields {
  component_element_id: uuid
  style_id: uuid
}

"""
order by min() on columns of table "style_component_element"
"""
input style_component_element_min_order_by {
  component_element_id: order_by
  style_id: order_by
}

"""
response of any mutation on the table "style_component_element"
"""
type style_component_element_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [style_component_element!]!
}

"""
on conflict condition type for table "style_component_element"
"""
input style_component_element_on_conflict {
  constraint: style_component_element_constraint!
  update_columns: [style_component_element_update_column!]!
  where: style_component_element_bool_exp
}

"""
Ordering options when selecting data from "style_component_element".
"""
input style_component_element_order_by {
  componentElement: component_element_order_by
  component_element_id: order_by
  style: style_order_by
  style_id: order_by
}

"""
primary key columns input for table: style_component_element
"""
input style_component_element_pk_columns_input {
  component_element_id: uuid!
  style_id: uuid!
}

"""
select columns of table "style_component_element"
"""
enum style_component_element_select_column {
  """
  column name
  """
  component_element_id

  """
  column name
  """
  style_id
}

"""
input type for updating data in table "style_component_element"
"""
input style_component_element_set_input {
  component_element_id: uuid
  style_id: uuid
}

"""
update columns of table "style_component_element"
"""
enum style_component_element_update_column {
  """
  column name
  """
  component_element_id

  """
  column name
  """
  style_id
}

"""
unique or primary key constraints on table "style"
"""
enum style_constraint {
  """
  unique or primary key constraint
  """
  styles_pkey
}

"""
input type for inserting data into table "style"
"""
input style_insert_input {
  id: uuid
  library: library_obj_rel_insert_input
  library_id: uuid
  name: String
  propCollection: prop_c_obj_rel_insert_input
  prop_c_id: uuid
}

"""
aggregate max on columns
"""
type style_max_fields {
  id: uuid
  library_id: uuid
  name: String
  prop_c_id: uuid
}

"""
order by max() on columns of table "style"
"""
input style_max_order_by {
  id: order_by
  library_id: order_by
  name: order_by
  prop_c_id: order_by
}

"""
aggregate min on columns
"""
type style_min_fields {
  id: uuid
  library_id: uuid
  name: String
  prop_c_id: uuid
}

"""
order by min() on columns of table "style"
"""
input style_min_order_by {
  id: order_by
  library_id: order_by
  name: order_by
  prop_c_id: order_by
}

"""
response of any mutation on the table "style"
"""
type style_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [style!]!
}

"""
input type for inserting object relation for remote table "style"
"""
input style_obj_rel_insert_input {
  data: style_insert_input!

  """
  on conflict condition
  """
  on_conflict: style_on_conflict
}

"""
on conflict condition type for table "style"
"""
input style_on_conflict {
  constraint: style_constraint!
  update_columns: [style_update_column!]!
  where: style_bool_exp
}

"""
Ordering options when selecting data from "style".
"""
input style_order_by {
  id: order_by
  library: library_order_by
  library_id: order_by
  name: order_by
  propCollection: prop_c_order_by
  prop_c_id: order_by
}

"""
columns and relationships of "style_page_element"
"""
type style_page_element {
  """
  An object relationship
  """
  pageElement: page_element!
  page_element_id: uuid!

  """
  An object relationship
  """
  style: style!
  style_id: uuid!
}

"""
aggregated selection of "style_page_element"
"""
type style_page_element_aggregate {
  aggregate: style_page_element_aggregate_fields
  nodes: [style_page_element!]!
}

"""
aggregate fields of "style_page_element"
"""
type style_page_element_aggregate_fields {
  count(columns: [style_page_element_select_column!], distinct: Boolean): Int!
  max: style_page_element_max_fields
  min: style_page_element_min_fields
}

"""
order by aggregate values of table "style_page_element"
"""
input style_page_element_aggregate_order_by {
  count: order_by
  max: style_page_element_max_order_by
  min: style_page_element_min_order_by
}

"""
input type for inserting array relation for remote table "style_page_element"
"""
input style_page_element_arr_rel_insert_input {
  data: [style_page_element_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: style_page_element_on_conflict
}

"""
Boolean expression to filter rows from the table "style_page_element". All fields are combined with a logical 'AND'.
"""
input style_page_element_bool_exp {
  _and: [style_page_element_bool_exp!]
  _not: style_page_element_bool_exp
  _or: [style_page_element_bool_exp!]
  pageElement: page_element_bool_exp
  page_element_id: uuid_comparison_exp
  style: style_bool_exp
  style_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "style_page_element"
"""
enum style_page_element_constraint {
  """
  unique or primary key constraint
  """
  style_page_element_pkey
}

"""
input type for inserting data into table "style_page_element"
"""
input style_page_element_insert_input {
  pageElement: page_element_obj_rel_insert_input
  page_element_id: uuid
  style: style_obj_rel_insert_input
  style_id: uuid
}

"""
aggregate max on columns
"""
type style_page_element_max_fields {
  page_element_id: uuid
  style_id: uuid
}

"""
order by max() on columns of table "style_page_element"
"""
input style_page_element_max_order_by {
  page_element_id: order_by
  style_id: order_by
}

"""
aggregate min on columns
"""
type style_page_element_min_fields {
  page_element_id: uuid
  style_id: uuid
}

"""
order by min() on columns of table "style_page_element"
"""
input style_page_element_min_order_by {
  page_element_id: order_by
  style_id: order_by
}

"""
response of any mutation on the table "style_page_element"
"""
type style_page_element_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [style_page_element!]!
}

"""
on conflict condition type for table "style_page_element"
"""
input style_page_element_on_conflict {
  constraint: style_page_element_constraint!
  update_columns: [style_page_element_update_column!]!
  where: style_page_element_bool_exp
}

"""
Ordering options when selecting data from "style_page_element".
"""
input style_page_element_order_by {
  pageElement: page_element_order_by
  page_element_id: order_by
  style: style_order_by
  style_id: order_by
}

"""
primary key columns input for table: style_page_element
"""
input style_page_element_pk_columns_input {
  page_element_id: uuid!
  style_id: uuid!
}

"""
select columns of table "style_page_element"
"""
enum style_page_element_select_column {
  """
  column name
  """
  page_element_id

  """
  column name
  """
  style_id
}

"""
input type for updating data in table "style_page_element"
"""
input style_page_element_set_input {
  page_element_id: uuid
  style_id: uuid
}

"""
update columns of table "style_page_element"
"""
enum style_page_element_update_column {
  """
  column name
  """
  page_element_id

  """
  column name
  """
  style_id
}

"""
primary key columns input for table: style
"""
input style_pk_columns_input {
  id: uuid!
}

"""
select columns of table "style"
"""
enum style_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  library_id

  """
  column name
  """
  name

  """
  column name
  """
  prop_c_id
}

"""
input type for updating data in table "style"
"""
input style_set_input {
  id: uuid
  library_id: uuid
  name: String
  prop_c_id: uuid
}

"""
update columns of table "style"
"""
enum style_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  library_id

  """
  column name
  """
  name

  """
  column name
  """
  prop_c_id
}

type subscription_root {
  """
  fetch data from the table: "app"
  """
  app(
    """
    distinct select on columns
    """
    distinct_on: [app_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [app_order_by!]

    """
    filter the rows returned
    """
    where: app_bool_exp
  ): [app!]!

  """
  fetch aggregated fields from the table: "app"
  """
  app_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [app_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [app_order_by!]

    """
    filter the rows returned
    """
    where: app_bool_exp
  ): app_aggregate!

  """
  fetch data from the table: "app" using primary key columns
  """
  app_by_pk(id: uuid!): app

  """
  fetch data from the table: "atom"
  """
  atom(
    """
    distinct select on columns
    """
    distinct_on: [atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_order_by!]

    """
    filter the rows returned
    """
    where: atom_bool_exp
  ): [atom!]!

  """
  fetch aggregated fields from the table: "atom"
  """
  atom_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_order_by!]

    """
    filter the rows returned
    """
    where: atom_bool_exp
  ): atom_aggregate!

  """
  fetch data from the table: "atom" using primary key columns
  """
  atom_by_pk(id: uuid!): atom

  """
  fetch data from the table: "atom_type"
  """
  atom_type(
    """
    distinct select on columns
    """
    distinct_on: [atom_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_type_order_by!]

    """
    filter the rows returned
    """
    where: atom_type_bool_exp
  ): [atom_type!]!

  """
  fetch aggregated fields from the table: "atom_type"
  """
  atom_type_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [atom_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [atom_type_order_by!]

    """
    filter the rows returned
    """
    where: atom_type_bool_exp
  ): atom_type_aggregate!

  """
  fetch data from the table: "atom_type" using primary key columns
  """
  atom_type_by_pk(value: String!): atom_type

  """
  fetch data from the table: "category"
  """
  category(
    """
    distinct select on columns
    """
    distinct_on: [category_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [category_order_by!]

    """
    filter the rows returned
    """
    where: category_bool_exp
  ): [category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  category_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [category_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [category_order_by!]

    """
    filter the rows returned
    """
    where: category_bool_exp
  ): category_aggregate!

  """
  fetch data from the table: "category" using primary key columns
  """
  category_by_pk(id: uuid!): category

  """
  fetch data from the table: "component"
  """
  component(
    """
    distinct select on columns
    """
    distinct_on: [component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_order_by!]

    """
    filter the rows returned
    """
    where: component_bool_exp
  ): [component!]!

  """
  fetch aggregated fields from the table: "component"
  """
  component_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_order_by!]

    """
    filter the rows returned
    """
    where: component_bool_exp
  ): component_aggregate!

  """
  fetch data from the table: "component" using primary key columns
  """
  component_by_pk(id: uuid!): component

  """
  fetch data from the table: "component_element"
  """
  component_element(
    """
    distinct select on columns
    """
    distinct_on: [component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_element_order_by!]

    """
    filter the rows returned
    """
    where: component_element_bool_exp
  ): [component_element!]!

  """
  fetch aggregated fields from the table: "component_element"
  """
  component_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_element_order_by!]

    """
    filter the rows returned
    """
    where: component_element_bool_exp
  ): component_element_aggregate!

  """
  fetch data from the table: "component_element" using primary key columns
  """
  component_element_by_pk(id: uuid!): component_element

  """
  fetch data from the table: "component_link"
  """
  component_link(
    """
    distinct select on columns
    """
    distinct_on: [component_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_link_order_by!]

    """
    filter the rows returned
    """
    where: component_link_bool_exp
  ): [component_link!]!

  """
  fetch aggregated fields from the table: "component_link"
  """
  component_link_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [component_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [component_link_order_by!]

    """
    filter the rows returned
    """
    where: component_link_bool_exp
  ): component_link_aggregate!

  """
  fetch data from the table: "component_link" using primary key columns
  """
  component_link_by_pk(id: uuid!): component_link

  """
  execute function "get_current_user" which returns "user"
  """
  get_current_user(
    """
    input parameters for function "get_current_user"
    """
    args: get_current_user_args!

    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): [user!]!

  """
  execute function "get_current_user" and query aggregates on result of table type "user"
  """
  get_current_user_aggregate(
    """
    input parameters for function "get_current_user"
    """
    args: get_current_user_args!

    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): user_aggregate!

  """
  fetch data from the table: "hoc"
  """
  hoc(
    """
    distinct select on columns
    """
    distinct_on: [hoc_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [hoc_order_by!]

    """
    filter the rows returned
    """
    where: hoc_bool_exp
  ): [hoc!]!

  """
  fetch aggregated fields from the table: "hoc"
  """
  hoc_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [hoc_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [hoc_order_by!]

    """
    filter the rows returned
    """
    where: hoc_bool_exp
  ): hoc_aggregate!

  """
  fetch data from the table: "hoc" using primary key columns
  """
  hoc_by_pk(id: uuid!): hoc

  """
  fetch data from the table: "hoc_component_element"
  """
  hoc_component_element(
    """
    distinct select on columns
    """
    distinct_on: [hoc_component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [hoc_component_element_order_by!]

    """
    filter the rows returned
    """
    where: hoc_component_element_bool_exp
  ): [hoc_component_element!]!

  """
  fetch aggregated fields from the table: "hoc_component_element"
  """
  hoc_component_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [hoc_component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [hoc_component_element_order_by!]

    """
    filter the rows returned
    """
    where: hoc_component_element_bool_exp
  ): hoc_component_element_aggregate!

  """
  fetch data from the table: "hoc_component_element" using primary key columns
  """
  hoc_component_element_by_pk(
    component_element_id: uuid!
    hoc_id: uuid!
  ): hoc_component_element

  """
  fetch data from the table: "lambda"
  """
  lambda(
    """
    distinct select on columns
    """
    distinct_on: [lambda_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [lambda_order_by!]

    """
    filter the rows returned
    """
    where: lambda_bool_exp
  ): [lambda!]!

  """
  fetch aggregated fields from the table: "lambda"
  """
  lambda_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [lambda_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [lambda_order_by!]

    """
    filter the rows returned
    """
    where: lambda_bool_exp
  ): lambda_aggregate!

  """
  fetch data from the table: "lambda" using primary key columns
  """
  lambda_by_pk(id: uuid!): lambda

  """
  fetch data from the table: "library"
  """
  library(
    """
    distinct select on columns
    """
    distinct_on: [library_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [library_order_by!]

    """
    filter the rows returned
    """
    where: library_bool_exp
  ): [library!]!

  """
  fetch aggregated fields from the table: "library"
  """
  library_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [library_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [library_order_by!]

    """
    filter the rows returned
    """
    where: library_bool_exp
  ): library_aggregate!

  """
  fetch data from the table: "library" using primary key columns
  """
  library_by_pk(id: uuid!): library

  """
  fetch data from the table: "page"
  """
  page(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): [page!]!

  """
  fetch aggregated fields from the table: "page"
  """
  page_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): page_aggregate!

  """
  fetch data from the table: "page" using primary key columns
  """
  page_by_pk(id: uuid!): page

  """
  fetch data from the table: "page_element"
  """
  page_element(
    """
    distinct select on columns
    """
    distinct_on: [page_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_element_order_by!]

    """
    filter the rows returned
    """
    where: page_element_bool_exp
  ): [page_element!]!

  """
  fetch aggregated fields from the table: "page_element"
  """
  page_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_element_order_by!]

    """
    filter the rows returned
    """
    where: page_element_bool_exp
  ): page_element_aggregate!

  """
  fetch data from the table: "page_element" using primary key columns
  """
  page_element_by_pk(id: uuid!): page_element

  """
  fetch data from the table: "page_link"
  """
  page_link(
    """
    distinct select on columns
    """
    distinct_on: [page_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_link_order_by!]

    """
    filter the rows returned
    """
    where: page_link_bool_exp
  ): [page_link!]!

  """
  fetch aggregated fields from the table: "page_link"
  """
  page_link_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_link_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_link_order_by!]

    """
    filter the rows returned
    """
    where: page_link_bool_exp
  ): page_link_aggregate!

  """
  fetch data from the table: "page_link" using primary key columns
  """
  page_link_by_pk(id: uuid!): page_link

  """
  fetch data from the table: "prop"
  """
  prop(
    """
    distinct select on columns
    """
    distinct_on: [prop_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_order_by!]

    """
    filter the rows returned
    """
    where: prop_bool_exp
  ): [prop!]!

  """
  fetch aggregated fields from the table: "prop"
  """
  prop_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_order_by!]

    """
    filter the rows returned
    """
    where: prop_bool_exp
  ): prop_aggregate!

  """
  fetch data from the table: "prop" using primary key columns
  """
  prop_by_pk(id: uuid!): prop

  """
  fetch data from the table: "prop_c"
  """
  prop_c(
    """
    distinct select on columns
    """
    distinct_on: [prop_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_c_order_by!]

    """
    filter the rows returned
    """
    where: prop_c_bool_exp
  ): [prop_c!]!

  """
  fetch aggregated fields from the table: "prop_c"
  """
  prop_c_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_c_order_by!]

    """
    filter the rows returned
    """
    where: prop_c_bool_exp
  ): prop_c_aggregate!

  """
  fetch data from the table: "prop_c" using primary key columns
  """
  prop_c_by_pk(id: uuid!): prop_c

  """
  fetch data from the table: "prop_type"
  """
  prop_type(
    """
    distinct select on columns
    """
    distinct_on: [prop_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_type_order_by!]

    """
    filter the rows returned
    """
    where: prop_type_bool_exp
  ): [prop_type!]!

  """
  fetch aggregated fields from the table: "prop_type"
  """
  prop_type_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_type_order_by!]

    """
    filter the rows returned
    """
    where: prop_type_bool_exp
  ): prop_type_aggregate!

  """
  fetch data from the table: "prop_type" using primary key columns
  """
  prop_type_by_pk(id: uuid!): prop_type

  """
  fetch data from the table: "prop_type_c"
  """
  prop_type_c(
    """
    distinct select on columns
    """
    distinct_on: [prop_type_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_type_c_order_by!]

    """
    filter the rows returned
    """
    where: prop_type_c_bool_exp
  ): [prop_type_c!]!

  """
  fetch aggregated fields from the table: "prop_type_c"
  """
  prop_type_c_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_type_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_type_c_order_by!]

    """
    filter the rows returned
    """
    where: prop_type_c_bool_exp
  ): prop_type_c_aggregate!

  """
  fetch data from the table: "prop_type_c" using primary key columns
  """
  prop_type_c_by_pk(id: uuid!): prop_type_c

  """
  fetch data from the table: "prop_value"
  """
  prop_value(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_bool_exp
  ): [prop_value!]!

  """
  fetch aggregated fields from the table: "prop_value"
  """
  prop_value_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [prop_value_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [prop_value_order_by!]

    """
    filter the rows returned
    """
    where: prop_value_bool_exp
  ): prop_value_aggregate!

  """
  fetch data from the table: "prop_value" using primary key columns
  """
  prop_value_by_pk(id: uuid!): prop_value

  """
  fetch data from the table: "style"
  """
  style(
    """
    distinct select on columns
    """
    distinct_on: [style_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_order_by!]

    """
    filter the rows returned
    """
    where: style_bool_exp
  ): [style!]!

  """
  fetch aggregated fields from the table: "style"
  """
  style_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [style_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_order_by!]

    """
    filter the rows returned
    """
    where: style_bool_exp
  ): style_aggregate!

  """
  fetch data from the table: "style_atom"
  """
  style_atom(
    """
    distinct select on columns
    """
    distinct_on: [style_atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_atom_order_by!]

    """
    filter the rows returned
    """
    where: style_atom_bool_exp
  ): [style_atom!]!

  """
  fetch aggregated fields from the table: "style_atom"
  """
  style_atom_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [style_atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_atom_order_by!]

    """
    filter the rows returned
    """
    where: style_atom_bool_exp
  ): style_atom_aggregate!

  """
  fetch data from the table: "style_atom" using primary key columns
  """
  style_atom_by_pk(atom_id: uuid!, style_id: uuid!): style_atom

  """
  fetch data from the table: "style" using primary key columns
  """
  style_by_pk(id: uuid!): style

  """
  fetch data from the table: "style_component_element"
  """
  style_component_element(
    """
    distinct select on columns
    """
    distinct_on: [style_component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_component_element_order_by!]

    """
    filter the rows returned
    """
    where: style_component_element_bool_exp
  ): [style_component_element!]!

  """
  fetch aggregated fields from the table: "style_component_element"
  """
  style_component_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [style_component_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_component_element_order_by!]

    """
    filter the rows returned
    """
    where: style_component_element_bool_exp
  ): style_component_element_aggregate!

  """
  fetch data from the table: "style_component_element" using primary key columns
  """
  style_component_element_by_pk(
    component_element_id: uuid!
    style_id: uuid!
  ): style_component_element

  """
  fetch data from the table: "style_page_element"
  """
  style_page_element(
    """
    distinct select on columns
    """
    distinct_on: [style_page_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_page_element_order_by!]

    """
    filter the rows returned
    """
    where: style_page_element_bool_exp
  ): [style_page_element!]!

  """
  fetch aggregated fields from the table: "style_page_element"
  """
  style_page_element_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [style_page_element_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [style_page_element_order_by!]

    """
    filter the rows returned
    """
    where: style_page_element_bool_exp
  ): style_page_element_aggregate!

  """
  fetch data from the table: "style_page_element" using primary key columns
  """
  style_page_element_by_pk(
    page_element_id: uuid!
    style_id: uuid!
  ): style_page_element

  """
  fetch data from the table: "tag"
  """
  tag(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): [tag!]!

  """
  fetch aggregated fields from the table: "tag"
  """
  tag_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): tag_aggregate!

  """
  fetch data from the table: "tag_atom"
  """
  tag_atom(
    """
    distinct select on columns
    """
    distinct_on: [tag_atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_atom_order_by!]

    """
    filter the rows returned
    """
    where: tag_atom_bool_exp
  ): [tag_atom!]!

  """
  fetch aggregated fields from the table: "tag_atom"
  """
  tag_atom_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_atom_order_by!]

    """
    filter the rows returned
    """
    where: tag_atom_bool_exp
  ): tag_atom_aggregate!

  """
  fetch data from the table: "tag_atom" using primary key columns
  """
  tag_atom_by_pk(atom_id: uuid!, tag_id: uuid!): tag_atom

  """
  fetch data from the table: "tag" using primary key columns
  """
  tag_by_pk(id: uuid!): tag

  """
  fetch data from the table: "tag_component"
  """
  tag_component(
    """
    distinct select on columns
    """
    distinct_on: [tag_component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_component_order_by!]

    """
    filter the rows returned
    """
    where: tag_component_bool_exp
  ): [tag_component!]!

  """
  fetch aggregated fields from the table: "tag_component"
  """
  tag_component_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_component_order_by!]

    """
    filter the rows returned
    """
    where: tag_component_bool_exp
  ): tag_component_aggregate!

  """
  fetch data from the table: "tag_component" using primary key columns
  """
  tag_component_by_pk(component_id: uuid!, tag_id: uuid!): tag_component

  """
  fetch data from the table: "tag_hoc"
  """
  tag_hoc(
    """
    distinct select on columns
    """
    distinct_on: [tag_hoc_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_hoc_order_by!]

    """
    filter the rows returned
    """
    where: tag_hoc_bool_exp
  ): [tag_hoc!]!

  """
  fetch aggregated fields from the table: "tag_hoc"
  """
  tag_hoc_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_hoc_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_hoc_order_by!]

    """
    filter the rows returned
    """
    where: tag_hoc_bool_exp
  ): tag_hoc_aggregate!

  """
  fetch data from the table: "tag_hoc" using primary key columns
  """
  tag_hoc_by_pk(hoc_id: uuid!, tag_id: uuid!): tag_hoc

  """
  fetch data from the table: "tag_prop_c"
  """
  tag_prop_c(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_c_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_c_bool_exp
  ): [tag_prop_c!]!

  """
  fetch aggregated fields from the table: "tag_prop_c"
  """
  tag_prop_c_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_c_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_c_bool_exp
  ): tag_prop_c_aggregate!

  """
  fetch data from the table: "tag_prop_c" using primary key columns
  """
  tag_prop_c_by_pk(prop_c_id: uuid!, tag_id: uuid!): tag_prop_c

  """
  fetch data from the table: "tag_prop_type_c"
  """
  tag_prop_type_c(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_type_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_type_c_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_type_c_bool_exp
  ): [tag_prop_type_c!]!

  """
  fetch aggregated fields from the table: "tag_prop_type_c"
  """
  tag_prop_type_c_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_type_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_type_c_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_type_c_bool_exp
  ): tag_prop_type_c_aggregate!

  """
  fetch data from the table: "tag_prop_type_c" using primary key columns
  """
  tag_prop_type_c_by_pk(prop_type_c_id: uuid!, tag_id: uuid!): tag_prop_type_c

  """
  fetch data from the table: "tag_prop_value"
  """
  tag_prop_value(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_value_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_value_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_value_bool_exp
  ): [tag_prop_value!]!

  """
  fetch aggregated fields from the table: "tag_prop_value"
  """
  tag_prop_value_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_value_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_value_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_value_bool_exp
  ): tag_prop_value_aggregate!

  """
  fetch data from the table: "tag_prop_value" using primary key columns
  """
  tag_prop_value_by_pk(prop_value_id: uuid!, tag_id: uuid!): tag_prop_value

  """
  fetch data from the table: "tag_style"
  """
  tag_style(
    """
    distinct select on columns
    """
    distinct_on: [tag_style_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_style_order_by!]

    """
    filter the rows returned
    """
    where: tag_style_bool_exp
  ): [tag_style!]!

  """
  fetch aggregated fields from the table: "tag_style"
  """
  tag_style_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_style_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_style_order_by!]

    """
    filter the rows returned
    """
    where: tag_style_bool_exp
  ): tag_style_aggregate!

  """
  fetch data from the table: "tag_style" using primary key columns
  """
  tag_style_by_pk(style_id: uuid!, tag_id: uuid!): tag_style

  """
  fetch data from the table: "user"
  """
  user(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): user_aggregate!

  """
  fetch data from the table: "user" using primary key columns
  """
  user_by_pk(id: String!): user

  """
  fetch data from the table: "value_type"
  """
  value_type(
    """
    distinct select on columns
    """
    distinct_on: [value_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [value_type_order_by!]

    """
    filter the rows returned
    """
    where: value_type_bool_exp
  ): [value_type!]!

  """
  fetch aggregated fields from the table: "value_type"
  """
  value_type_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [value_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [value_type_order_by!]

    """
    filter the rows returned
    """
    where: value_type_bool_exp
  ): value_type_aggregate!

  """
  fetch data from the table: "value_type" using primary key columns
  """
  value_type_by_pk(value: String!): value_type
}

"""
columns and relationships of "tag"
"""
type tag {
  """
  An array relationship
  """
  atoms(
    """
    distinct select on columns
    """
    distinct_on: [tag_atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_atom_order_by!]

    """
    filter the rows returned
    """
    where: tag_atom_bool_exp
  ): [tag_atom!]!

  """
  An aggregate relationship
  """
  atoms_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_atom_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_atom_order_by!]

    """
    filter the rows returned
    """
    where: tag_atom_bool_exp
  ): tag_atom_aggregate!

  """
  An object relationship
  """
  category: category
  category_id: uuid

  """
  An array relationship
  """
  components(
    """
    distinct select on columns
    """
    distinct_on: [tag_component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_component_order_by!]

    """
    filter the rows returned
    """
    where: tag_component_bool_exp
  ): [tag_component!]!

  """
  An aggregate relationship
  """
  components_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_component_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_component_order_by!]

    """
    filter the rows returned
    """
    where: tag_component_bool_exp
  ): tag_component_aggregate!

  """
  An array relationship
  """
  hocs(
    """
    distinct select on columns
    """
    distinct_on: [tag_hoc_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_hoc_order_by!]

    """
    filter the rows returned
    """
    where: tag_hoc_bool_exp
  ): [tag_hoc!]!

  """
  An aggregate relationship
  """
  hocs_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_hoc_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_hoc_order_by!]

    """
    filter the rows returned
    """
    where: tag_hoc_bool_exp
  ): tag_hoc_aggregate!
  id: uuid!
  label: String!

  """
  An object relationship
  """
  library: library!
  library_id: uuid!

  """
  An array relationship
  """
  propCollections(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_c_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_c_bool_exp
  ): [tag_prop_c!]!

  """
  An aggregate relationship
  """
  propCollections_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_c_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_c_bool_exp
  ): tag_prop_c_aggregate!

  """
  An array relationship
  """
  propTypeCollections(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_type_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_type_c_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_type_c_bool_exp
  ): [tag_prop_type_c!]!

  """
  An aggregate relationship
  """
  propTypeCollections_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_type_c_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_type_c_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_type_c_bool_exp
  ): tag_prop_type_c_aggregate!

  """
  An array relationship
  """
  propValues(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_value_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_value_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_value_bool_exp
  ): [tag_prop_value!]!

  """
  An aggregate relationship
  """
  propValues_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_prop_value_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_prop_value_order_by!]

    """
    filter the rows returned
    """
    where: tag_prop_value_bool_exp
  ): tag_prop_value_aggregate!

  """
  An array relationship
  """
  styles(
    """
    distinct select on columns
    """
    distinct_on: [tag_style_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_style_order_by!]

    """
    filter the rows returned
    """
    where: tag_style_bool_exp
  ): [tag_style!]!

  """
  An aggregate relationship
  """
  styles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_style_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_style_order_by!]

    """
    filter the rows returned
    """
    where: tag_style_bool_exp
  ): tag_style_aggregate!
}

"""
aggregated selection of "tag"
"""
type tag_aggregate {
  aggregate: tag_aggregate_fields
  nodes: [tag!]!
}

"""
aggregate fields of "tag"
"""
type tag_aggregate_fields {
  count(columns: [tag_select_column!], distinct: Boolean): Int!
  max: tag_max_fields
  min: tag_min_fields
}

"""
order by aggregate values of table "tag"
"""
input tag_aggregate_order_by {
  count: order_by
  max: tag_max_order_by
  min: tag_min_order_by
}

"""
input type for inserting array relation for remote table "tag"
"""
input tag_arr_rel_insert_input {
  data: [tag_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: tag_on_conflict
}

"""
columns and relationships of "tag_atom"
"""
type tag_atom {
  """
  An object relationship
  """
  atom: atom!
  atom_id: uuid!

  """
  An object relationship
  """
  tag: tag!
  tag_id: uuid!
}

"""
aggregated selection of "tag_atom"
"""
type tag_atom_aggregate {
  aggregate: tag_atom_aggregate_fields
  nodes: [tag_atom!]!
}

"""
aggregate fields of "tag_atom"
"""
type tag_atom_aggregate_fields {
  count(columns: [tag_atom_select_column!], distinct: Boolean): Int!
  max: tag_atom_max_fields
  min: tag_atom_min_fields
}

"""
order by aggregate values of table "tag_atom"
"""
input tag_atom_aggregate_order_by {
  count: order_by
  max: tag_atom_max_order_by
  min: tag_atom_min_order_by
}

"""
input type for inserting array relation for remote table "tag_atom"
"""
input tag_atom_arr_rel_insert_input {
  data: [tag_atom_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: tag_atom_on_conflict
}

"""
Boolean expression to filter rows from the table "tag_atom". All fields are combined with a logical 'AND'.
"""
input tag_atom_bool_exp {
  _and: [tag_atom_bool_exp!]
  _not: tag_atom_bool_exp
  _or: [tag_atom_bool_exp!]
  atom: atom_bool_exp
  atom_id: uuid_comparison_exp
  tag: tag_bool_exp
  tag_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "tag_atom"
"""
enum tag_atom_constraint {
  """
  unique or primary key constraint
  """
  tag_atom_pkey
}

"""
input type for inserting data into table "tag_atom"
"""
input tag_atom_insert_input {
  atom: atom_obj_rel_insert_input
  atom_id: uuid
  tag: tag_obj_rel_insert_input
  tag_id: uuid
}

"""
aggregate max on columns
"""
type tag_atom_max_fields {
  atom_id: uuid
  tag_id: uuid
}

"""
order by max() on columns of table "tag_atom"
"""
input tag_atom_max_order_by {
  atom_id: order_by
  tag_id: order_by
}

"""
aggregate min on columns
"""
type tag_atom_min_fields {
  atom_id: uuid
  tag_id: uuid
}

"""
order by min() on columns of table "tag_atom"
"""
input tag_atom_min_order_by {
  atom_id: order_by
  tag_id: order_by
}

"""
response of any mutation on the table "tag_atom"
"""
type tag_atom_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [tag_atom!]!
}

"""
on conflict condition type for table "tag_atom"
"""
input tag_atom_on_conflict {
  constraint: tag_atom_constraint!
  update_columns: [tag_atom_update_column!]!
  where: tag_atom_bool_exp
}

"""
Ordering options when selecting data from "tag_atom".
"""
input tag_atom_order_by {
  atom: atom_order_by
  atom_id: order_by
  tag: tag_order_by
  tag_id: order_by
}

"""
primary key columns input for table: tag_atom
"""
input tag_atom_pk_columns_input {
  atom_id: uuid!
  tag_id: uuid!
}

"""
select columns of table "tag_atom"
"""
enum tag_atom_select_column {
  """
  column name
  """
  atom_id

  """
  column name
  """
  tag_id
}

"""
input type for updating data in table "tag_atom"
"""
input tag_atom_set_input {
  atom_id: uuid
  tag_id: uuid
}

"""
update columns of table "tag_atom"
"""
enum tag_atom_update_column {
  """
  column name
  """
  atom_id

  """
  column name
  """
  tag_id
}

"""
Boolean expression to filter rows from the table "tag". All fields are combined with a logical 'AND'.
"""
input tag_bool_exp {
  _and: [tag_bool_exp!]
  _not: tag_bool_exp
  _or: [tag_bool_exp!]
  atoms: tag_atom_bool_exp
  category: category_bool_exp
  category_id: uuid_comparison_exp
  components: tag_component_bool_exp
  hocs: tag_hoc_bool_exp
  id: uuid_comparison_exp
  label: String_comparison_exp
  library: library_bool_exp
  library_id: uuid_comparison_exp
  propCollections: tag_prop_c_bool_exp
  propTypeCollections: tag_prop_type_c_bool_exp
  propValues: tag_prop_value_bool_exp
  styles: tag_style_bool_exp
}

"""
columns and relationships of "tag_component"
"""
type tag_component {
  """
  An object relationship
  """
  component: component!
  component_id: uuid!

  """
  An object relationship
  """
  tag: tag!
  tag_id: uuid!
}

"""
aggregated selection of "tag_component"
"""
type tag_component_aggregate {
  aggregate: tag_component_aggregate_fields
  nodes: [tag_component!]!
}

"""
aggregate fields of "tag_component"
"""
type tag_component_aggregate_fields {
  count(columns: [tag_component_select_column!], distinct: Boolean): Int!
  max: tag_component_max_fields
  min: tag_component_min_fields
}

"""
order by aggregate values of table "tag_component"
"""
input tag_component_aggregate_order_by {
  count: order_by
  max: tag_component_max_order_by
  min: tag_component_min_order_by
}

"""
input type for inserting array relation for remote table "tag_component"
"""
input tag_component_arr_rel_insert_input {
  data: [tag_component_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: tag_component_on_conflict
}

"""
Boolean expression to filter rows from the table "tag_component". All fields are combined with a logical 'AND'.
"""
input tag_component_bool_exp {
  _and: [tag_component_bool_exp!]
  _not: tag_component_bool_exp
  _or: [tag_component_bool_exp!]
  component: component_bool_exp
  component_id: uuid_comparison_exp
  tag: tag_bool_exp
  tag_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "tag_component"
"""
enum tag_component_constraint {
  """
  unique or primary key constraint
  """
  tag_component_pkey
}

"""
input type for inserting data into table "tag_component"
"""
input tag_component_insert_input {
  component: component_obj_rel_insert_input
  component_id: uuid
  tag: tag_obj_rel_insert_input
  tag_id: uuid
}

"""
aggregate max on columns
"""
type tag_component_max_fields {
  component_id: uuid
  tag_id: uuid
}

"""
order by max() on columns of table "tag_component"
"""
input tag_component_max_order_by {
  component_id: order_by
  tag_id: order_by
}

"""
aggregate min on columns
"""
type tag_component_min_fields {
  component_id: uuid
  tag_id: uuid
}

"""
order by min() on columns of table "tag_component"
"""
input tag_component_min_order_by {
  component_id: order_by
  tag_id: order_by
}

"""
response of any mutation on the table "tag_component"
"""
type tag_component_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [tag_component!]!
}

"""
on conflict condition type for table "tag_component"
"""
input tag_component_on_conflict {
  constraint: tag_component_constraint!
  update_columns: [tag_component_update_column!]!
  where: tag_component_bool_exp
}

"""
Ordering options when selecting data from "tag_component".
"""
input tag_component_order_by {
  component: component_order_by
  component_id: order_by
  tag: tag_order_by
  tag_id: order_by
}

"""
primary key columns input for table: tag_component
"""
input tag_component_pk_columns_input {
  component_id: uuid!
  tag_id: uuid!
}

"""
select columns of table "tag_component"
"""
enum tag_component_select_column {
  """
  column name
  """
  component_id

  """
  column name
  """
  tag_id
}

"""
input type for updating data in table "tag_component"
"""
input tag_component_set_input {
  component_id: uuid
  tag_id: uuid
}

"""
update columns of table "tag_component"
"""
enum tag_component_update_column {
  """
  column name
  """
  component_id

  """
  column name
  """
  tag_id
}

"""
unique or primary key constraints on table "tag"
"""
enum tag_constraint {
  """
  unique or primary key constraint
  """
  tags_pkey
}

"""
columns and relationships of "tag_hoc"
"""
type tag_hoc {
  """
  An object relationship
  """
  hoc: hoc!
  hoc_id: uuid!

  """
  An object relationship
  """
  tag: tag!
  tag_id: uuid!
}

"""
aggregated selection of "tag_hoc"
"""
type tag_hoc_aggregate {
  aggregate: tag_hoc_aggregate_fields
  nodes: [tag_hoc!]!
}

"""
aggregate fields of "tag_hoc"
"""
type tag_hoc_aggregate_fields {
  count(columns: [tag_hoc_select_column!], distinct: Boolean): Int!
  max: tag_hoc_max_fields
  min: tag_hoc_min_fields
}

"""
order by aggregate values of table "tag_hoc"
"""
input tag_hoc_aggregate_order_by {
  count: order_by
  max: tag_hoc_max_order_by
  min: tag_hoc_min_order_by
}

"""
input type for inserting array relation for remote table "tag_hoc"
"""
input tag_hoc_arr_rel_insert_input {
  data: [tag_hoc_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: tag_hoc_on_conflict
}

"""
Boolean expression to filter rows from the table "tag_hoc". All fields are combined with a logical 'AND'.
"""
input tag_hoc_bool_exp {
  _and: [tag_hoc_bool_exp!]
  _not: tag_hoc_bool_exp
  _or: [tag_hoc_bool_exp!]
  hoc: hoc_bool_exp
  hoc_id: uuid_comparison_exp
  tag: tag_bool_exp
  tag_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "tag_hoc"
"""
enum tag_hoc_constraint {
  """
  unique or primary key constraint
  """
  tag_hoc_pkey
}

"""
input type for inserting data into table "tag_hoc"
"""
input tag_hoc_insert_input {
  hoc: hoc_obj_rel_insert_input
  hoc_id: uuid
  tag: tag_obj_rel_insert_input
  tag_id: uuid
}

"""
aggregate max on columns
"""
type tag_hoc_max_fields {
  hoc_id: uuid
  tag_id: uuid
}

"""
order by max() on columns of table "tag_hoc"
"""
input tag_hoc_max_order_by {
  hoc_id: order_by
  tag_id: order_by
}

"""
aggregate min on columns
"""
type tag_hoc_min_fields {
  hoc_id: uuid
  tag_id: uuid
}

"""
order by min() on columns of table "tag_hoc"
"""
input tag_hoc_min_order_by {
  hoc_id: order_by
  tag_id: order_by
}

"""
response of any mutation on the table "tag_hoc"
"""
type tag_hoc_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [tag_hoc!]!
}

"""
on conflict condition type for table "tag_hoc"
"""
input tag_hoc_on_conflict {
  constraint: tag_hoc_constraint!
  update_columns: [tag_hoc_update_column!]!
  where: tag_hoc_bool_exp
}

"""
Ordering options when selecting data from "tag_hoc".
"""
input tag_hoc_order_by {
  hoc: hoc_order_by
  hoc_id: order_by
  tag: tag_order_by
  tag_id: order_by
}

"""
primary key columns input for table: tag_hoc
"""
input tag_hoc_pk_columns_input {
  hoc_id: uuid!
  tag_id: uuid!
}

"""
select columns of table "tag_hoc"
"""
enum tag_hoc_select_column {
  """
  column name
  """
  hoc_id

  """
  column name
  """
  tag_id
}

"""
input type for updating data in table "tag_hoc"
"""
input tag_hoc_set_input {
  hoc_id: uuid
  tag_id: uuid
}

"""
update columns of table "tag_hoc"
"""
enum tag_hoc_update_column {
  """
  column name
  """
  hoc_id

  """
  column name
  """
  tag_id
}

"""
input type for inserting data into table "tag"
"""
input tag_insert_input {
  atoms: tag_atom_arr_rel_insert_input
  category: category_obj_rel_insert_input
  category_id: uuid
  components: tag_component_arr_rel_insert_input
  hocs: tag_hoc_arr_rel_insert_input
  id: uuid
  label: String
  library: library_obj_rel_insert_input
  library_id: uuid
  propCollections: tag_prop_c_arr_rel_insert_input
  propTypeCollections: tag_prop_type_c_arr_rel_insert_input
  propValues: tag_prop_value_arr_rel_insert_input
  styles: tag_style_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type tag_max_fields {
  category_id: uuid
  id: uuid
  label: String
  library_id: uuid
}

"""
order by max() on columns of table "tag"
"""
input tag_max_order_by {
  category_id: order_by
  id: order_by
  label: order_by
  library_id: order_by
}

"""
aggregate min on columns
"""
type tag_min_fields {
  category_id: uuid
  id: uuid
  label: String
  library_id: uuid
}

"""
order by min() on columns of table "tag"
"""
input tag_min_order_by {
  category_id: order_by
  id: order_by
  label: order_by
  library_id: order_by
}

"""
response of any mutation on the table "tag"
"""
type tag_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [tag!]!
}

"""
input type for inserting object relation for remote table "tag"
"""
input tag_obj_rel_insert_input {
  data: tag_insert_input!

  """
  on conflict condition
  """
  on_conflict: tag_on_conflict
}

"""
on conflict condition type for table "tag"
"""
input tag_on_conflict {
  constraint: tag_constraint!
  update_columns: [tag_update_column!]!
  where: tag_bool_exp
}

"""
Ordering options when selecting data from "tag".
"""
input tag_order_by {
  atoms_aggregate: tag_atom_aggregate_order_by
  category: category_order_by
  category_id: order_by
  components_aggregate: tag_component_aggregate_order_by
  hocs_aggregate: tag_hoc_aggregate_order_by
  id: order_by
  label: order_by
  library: library_order_by
  library_id: order_by
  propCollections_aggregate: tag_prop_c_aggregate_order_by
  propTypeCollections_aggregate: tag_prop_type_c_aggregate_order_by
  propValues_aggregate: tag_prop_value_aggregate_order_by
  styles_aggregate: tag_style_aggregate_order_by
}

"""
primary key columns input for table: tag
"""
input tag_pk_columns_input {
  id: uuid!
}

"""
columns and relationships of "tag_prop_c"
"""
type tag_prop_c {
  """
  An object relationship
  """
  propCollection: prop_c!
  prop_c_id: uuid!

  """
  An object relationship
  """
  tag: tag!
  tag_id: uuid!
}

"""
aggregated selection of "tag_prop_c"
"""
type tag_prop_c_aggregate {
  aggregate: tag_prop_c_aggregate_fields
  nodes: [tag_prop_c!]!
}

"""
aggregate fields of "tag_prop_c"
"""
type tag_prop_c_aggregate_fields {
  count(columns: [tag_prop_c_select_column!], distinct: Boolean): Int!
  max: tag_prop_c_max_fields
  min: tag_prop_c_min_fields
}

"""
order by aggregate values of table "tag_prop_c"
"""
input tag_prop_c_aggregate_order_by {
  count: order_by
  max: tag_prop_c_max_order_by
  min: tag_prop_c_min_order_by
}

"""
input type for inserting array relation for remote table "tag_prop_c"
"""
input tag_prop_c_arr_rel_insert_input {
  data: [tag_prop_c_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: tag_prop_c_on_conflict
}

"""
Boolean expression to filter rows from the table "tag_prop_c". All fields are combined with a logical 'AND'.
"""
input tag_prop_c_bool_exp {
  _and: [tag_prop_c_bool_exp!]
  _not: tag_prop_c_bool_exp
  _or: [tag_prop_c_bool_exp!]
  propCollection: prop_c_bool_exp
  prop_c_id: uuid_comparison_exp
  tag: tag_bool_exp
  tag_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "tag_prop_c"
"""
enum tag_prop_c_constraint {
  """
  unique or primary key constraint
  """
  tag_prop_c_pkey
}

"""
input type for inserting data into table "tag_prop_c"
"""
input tag_prop_c_insert_input {
  propCollection: prop_c_obj_rel_insert_input
  prop_c_id: uuid
  tag: tag_obj_rel_insert_input
  tag_id: uuid
}

"""
aggregate max on columns
"""
type tag_prop_c_max_fields {
  prop_c_id: uuid
  tag_id: uuid
}

"""
order by max() on columns of table "tag_prop_c"
"""
input tag_prop_c_max_order_by {
  prop_c_id: order_by
  tag_id: order_by
}

"""
aggregate min on columns
"""
type tag_prop_c_min_fields {
  prop_c_id: uuid
  tag_id: uuid
}

"""
order by min() on columns of table "tag_prop_c"
"""
input tag_prop_c_min_order_by {
  prop_c_id: order_by
  tag_id: order_by
}

"""
response of any mutation on the table "tag_prop_c"
"""
type tag_prop_c_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [tag_prop_c!]!
}

"""
on conflict condition type for table "tag_prop_c"
"""
input tag_prop_c_on_conflict {
  constraint: tag_prop_c_constraint!
  update_columns: [tag_prop_c_update_column!]!
  where: tag_prop_c_bool_exp
}

"""
Ordering options when selecting data from "tag_prop_c".
"""
input tag_prop_c_order_by {
  propCollection: prop_c_order_by
  prop_c_id: order_by
  tag: tag_order_by
  tag_id: order_by
}

"""
primary key columns input for table: tag_prop_c
"""
input tag_prop_c_pk_columns_input {
  prop_c_id: uuid!
  tag_id: uuid!
}

"""
select columns of table "tag_prop_c"
"""
enum tag_prop_c_select_column {
  """
  column name
  """
  prop_c_id

  """
  column name
  """
  tag_id
}

"""
input type for updating data in table "tag_prop_c"
"""
input tag_prop_c_set_input {
  prop_c_id: uuid
  tag_id: uuid
}

"""
update columns of table "tag_prop_c"
"""
enum tag_prop_c_update_column {
  """
  column name
  """
  prop_c_id

  """
  column name
  """
  tag_id
}

"""
columns and relationships of "tag_prop_type_c"
"""
type tag_prop_type_c {
  """
  An object relationship
  """
  propTypeCollection: prop_type_c!
  prop_type_c_id: uuid!

  """
  An object relationship
  """
  tag: tag!
  tag_id: uuid!
}

"""
aggregated selection of "tag_prop_type_c"
"""
type tag_prop_type_c_aggregate {
  aggregate: tag_prop_type_c_aggregate_fields
  nodes: [tag_prop_type_c!]!
}

"""
aggregate fields of "tag_prop_type_c"
"""
type tag_prop_type_c_aggregate_fields {
  count(columns: [tag_prop_type_c_select_column!], distinct: Boolean): Int!
  max: tag_prop_type_c_max_fields
  min: tag_prop_type_c_min_fields
}

"""
order by aggregate values of table "tag_prop_type_c"
"""
input tag_prop_type_c_aggregate_order_by {
  count: order_by
  max: tag_prop_type_c_max_order_by
  min: tag_prop_type_c_min_order_by
}

"""
input type for inserting array relation for remote table "tag_prop_type_c"
"""
input tag_prop_type_c_arr_rel_insert_input {
  data: [tag_prop_type_c_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: tag_prop_type_c_on_conflict
}

"""
Boolean expression to filter rows from the table "tag_prop_type_c". All fields are combined with a logical 'AND'.
"""
input tag_prop_type_c_bool_exp {
  _and: [tag_prop_type_c_bool_exp!]
  _not: tag_prop_type_c_bool_exp
  _or: [tag_prop_type_c_bool_exp!]
  propTypeCollection: prop_type_c_bool_exp
  prop_type_c_id: uuid_comparison_exp
  tag: tag_bool_exp
  tag_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "tag_prop_type_c"
"""
enum tag_prop_type_c_constraint {
  """
  unique or primary key constraint
  """
  tag_prop_type_c_pkey
}

"""
input type for inserting data into table "tag_prop_type_c"
"""
input tag_prop_type_c_insert_input {
  propTypeCollection: prop_type_c_obj_rel_insert_input
  prop_type_c_id: uuid
  tag: tag_obj_rel_insert_input
  tag_id: uuid
}

"""
aggregate max on columns
"""
type tag_prop_type_c_max_fields {
  prop_type_c_id: uuid
  tag_id: uuid
}

"""
order by max() on columns of table "tag_prop_type_c"
"""
input tag_prop_type_c_max_order_by {
  prop_type_c_id: order_by
  tag_id: order_by
}

"""
aggregate min on columns
"""
type tag_prop_type_c_min_fields {
  prop_type_c_id: uuid
  tag_id: uuid
}

"""
order by min() on columns of table "tag_prop_type_c"
"""
input tag_prop_type_c_min_order_by {
  prop_type_c_id: order_by
  tag_id: order_by
}

"""
response of any mutation on the table "tag_prop_type_c"
"""
type tag_prop_type_c_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [tag_prop_type_c!]!
}

"""
on conflict condition type for table "tag_prop_type_c"
"""
input tag_prop_type_c_on_conflict {
  constraint: tag_prop_type_c_constraint!
  update_columns: [tag_prop_type_c_update_column!]!
  where: tag_prop_type_c_bool_exp
}

"""
Ordering options when selecting data from "tag_prop_type_c".
"""
input tag_prop_type_c_order_by {
  propTypeCollection: prop_type_c_order_by
  prop_type_c_id: order_by
  tag: tag_order_by
  tag_id: order_by
}

"""
primary key columns input for table: tag_prop_type_c
"""
input tag_prop_type_c_pk_columns_input {
  prop_type_c_id: uuid!
  tag_id: uuid!
}

"""
select columns of table "tag_prop_type_c"
"""
enum tag_prop_type_c_select_column {
  """
  column name
  """
  prop_type_c_id

  """
  column name
  """
  tag_id
}

"""
input type for updating data in table "tag_prop_type_c"
"""
input tag_prop_type_c_set_input {
  prop_type_c_id: uuid
  tag_id: uuid
}

"""
update columns of table "tag_prop_type_c"
"""
enum tag_prop_type_c_update_column {
  """
  column name
  """
  prop_type_c_id

  """
  column name
  """
  tag_id
}

"""
columns and relationships of "tag_prop_value"
"""
type tag_prop_value {
  """
  An object relationship
  """
  propValue: prop_value!
  prop_value_id: uuid!

  """
  An object relationship
  """
  tag: tag!
  tag_id: uuid!
}

"""
aggregated selection of "tag_prop_value"
"""
type tag_prop_value_aggregate {
  aggregate: tag_prop_value_aggregate_fields
  nodes: [tag_prop_value!]!
}

"""
aggregate fields of "tag_prop_value"
"""
type tag_prop_value_aggregate_fields {
  count(columns: [tag_prop_value_select_column!], distinct: Boolean): Int!
  max: tag_prop_value_max_fields
  min: tag_prop_value_min_fields
}

"""
order by aggregate values of table "tag_prop_value"
"""
input tag_prop_value_aggregate_order_by {
  count: order_by
  max: tag_prop_value_max_order_by
  min: tag_prop_value_min_order_by
}

"""
input type for inserting array relation for remote table "tag_prop_value"
"""
input tag_prop_value_arr_rel_insert_input {
  data: [tag_prop_value_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: tag_prop_value_on_conflict
}

"""
Boolean expression to filter rows from the table "tag_prop_value". All fields are combined with a logical 'AND'.
"""
input tag_prop_value_bool_exp {
  _and: [tag_prop_value_bool_exp!]
  _not: tag_prop_value_bool_exp
  _or: [tag_prop_value_bool_exp!]
  propValue: prop_value_bool_exp
  prop_value_id: uuid_comparison_exp
  tag: tag_bool_exp
  tag_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "tag_prop_value"
"""
enum tag_prop_value_constraint {
  """
  unique or primary key constraint
  """
  prop_value_tag_pkey
}

"""
input type for inserting data into table "tag_prop_value"
"""
input tag_prop_value_insert_input {
  propValue: prop_value_obj_rel_insert_input
  prop_value_id: uuid
  tag: tag_obj_rel_insert_input
  tag_id: uuid
}

"""
aggregate max on columns
"""
type tag_prop_value_max_fields {
  prop_value_id: uuid
  tag_id: uuid
}

"""
order by max() on columns of table "tag_prop_value"
"""
input tag_prop_value_max_order_by {
  prop_value_id: order_by
  tag_id: order_by
}

"""
aggregate min on columns
"""
type tag_prop_value_min_fields {
  prop_value_id: uuid
  tag_id: uuid
}

"""
order by min() on columns of table "tag_prop_value"
"""
input tag_prop_value_min_order_by {
  prop_value_id: order_by
  tag_id: order_by
}

"""
response of any mutation on the table "tag_prop_value"
"""
type tag_prop_value_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [tag_prop_value!]!
}

"""
on conflict condition type for table "tag_prop_value"
"""
input tag_prop_value_on_conflict {
  constraint: tag_prop_value_constraint!
  update_columns: [tag_prop_value_update_column!]!
  where: tag_prop_value_bool_exp
}

"""
Ordering options when selecting data from "tag_prop_value".
"""
input tag_prop_value_order_by {
  propValue: prop_value_order_by
  prop_value_id: order_by
  tag: tag_order_by
  tag_id: order_by
}

"""
primary key columns input for table: tag_prop_value
"""
input tag_prop_value_pk_columns_input {
  prop_value_id: uuid!
  tag_id: uuid!
}

"""
select columns of table "tag_prop_value"
"""
enum tag_prop_value_select_column {
  """
  column name
  """
  prop_value_id

  """
  column name
  """
  tag_id
}

"""
input type for updating data in table "tag_prop_value"
"""
input tag_prop_value_set_input {
  prop_value_id: uuid
  tag_id: uuid
}

"""
update columns of table "tag_prop_value"
"""
enum tag_prop_value_update_column {
  """
  column name
  """
  prop_value_id

  """
  column name
  """
  tag_id
}

"""
select columns of table "tag"
"""
enum tag_select_column {
  """
  column name
  """
  category_id

  """
  column name
  """
  id

  """
  column name
  """
  label

  """
  column name
  """
  library_id
}

"""
input type for updating data in table "tag"
"""
input tag_set_input {
  category_id: uuid
  id: uuid
  label: String
  library_id: uuid
}

"""
columns and relationships of "tag_style"
"""
type tag_style {
  """
  An object relationship
  """
  style: style!
  style_id: uuid!

  """
  An object relationship
  """
  tag: tag!
  tag_id: uuid!
}

"""
aggregated selection of "tag_style"
"""
type tag_style_aggregate {
  aggregate: tag_style_aggregate_fields
  nodes: [tag_style!]!
}

"""
aggregate fields of "tag_style"
"""
type tag_style_aggregate_fields {
  count(columns: [tag_style_select_column!], distinct: Boolean): Int!
  max: tag_style_max_fields
  min: tag_style_min_fields
}

"""
order by aggregate values of table "tag_style"
"""
input tag_style_aggregate_order_by {
  count: order_by
  max: tag_style_max_order_by
  min: tag_style_min_order_by
}

"""
input type for inserting array relation for remote table "tag_style"
"""
input tag_style_arr_rel_insert_input {
  data: [tag_style_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: tag_style_on_conflict
}

"""
Boolean expression to filter rows from the table "tag_style". All fields are combined with a logical 'AND'.
"""
input tag_style_bool_exp {
  _and: [tag_style_bool_exp!]
  _not: tag_style_bool_exp
  _or: [tag_style_bool_exp!]
  style: style_bool_exp
  style_id: uuid_comparison_exp
  tag: tag_bool_exp
  tag_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "tag_style"
"""
enum tag_style_constraint {
  """
  unique or primary key constraint
  """
  tag_style_pkey
}

"""
input type for inserting data into table "tag_style"
"""
input tag_style_insert_input {
  style: style_obj_rel_insert_input
  style_id: uuid
  tag: tag_obj_rel_insert_input
  tag_id: uuid
}

"""
aggregate max on columns
"""
type tag_style_max_fields {
  style_id: uuid
  tag_id: uuid
}

"""
order by max() on columns of table "tag_style"
"""
input tag_style_max_order_by {
  style_id: order_by
  tag_id: order_by
}

"""
aggregate min on columns
"""
type tag_style_min_fields {
  style_id: uuid
  tag_id: uuid
}

"""
order by min() on columns of table "tag_style"
"""
input tag_style_min_order_by {
  style_id: order_by
  tag_id: order_by
}

"""
response of any mutation on the table "tag_style"
"""
type tag_style_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [tag_style!]!
}

"""
on conflict condition type for table "tag_style"
"""
input tag_style_on_conflict {
  constraint: tag_style_constraint!
  update_columns: [tag_style_update_column!]!
  where: tag_style_bool_exp
}

"""
Ordering options when selecting data from "tag_style".
"""
input tag_style_order_by {
  style: style_order_by
  style_id: order_by
  tag: tag_order_by
  tag_id: order_by
}

"""
primary key columns input for table: tag_style
"""
input tag_style_pk_columns_input {
  style_id: uuid!
  tag_id: uuid!
}

"""
select columns of table "tag_style"
"""
enum tag_style_select_column {
  """
  column name
  """
  style_id

  """
  column name
  """
  tag_id
}

"""
input type for updating data in table "tag_style"
"""
input tag_style_set_input {
  style_id: uuid
  tag_id: uuid
}

"""
update columns of table "tag_style"
"""
enum tag_style_update_column {
  """
  column name
  """
  style_id

  """
  column name
  """
  tag_id
}

"""
update columns of table "tag"
"""
enum tag_update_column {
  """
  column name
  """
  category_id

  """
  column name
  """
  id

  """
  column name
  """
  label

  """
  column name
  """
  library_id
}

"""
columns and relationships of "user"
"""
type user {
  """
  An array relationship
  """
  apps(
    """
    distinct select on columns
    """
    distinct_on: [app_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [app_order_by!]

    """
    filter the rows returned
    """
    where: app_bool_exp
  ): [app!]!

  """
  An aggregate relationship
  """
  apps_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [app_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [app_order_by!]

    """
    filter the rows returned
    """
    where: app_bool_exp
  ): app_aggregate!
  id: String!

  """
  An array relationship
  """
  libraries(
    """
    distinct select on columns
    """
    distinct_on: [library_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [library_order_by!]

    """
    filter the rows returned
    """
    where: library_bool_exp
  ): [library!]!

  """
  An aggregate relationship
  """
  libraries_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [library_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [library_order_by!]

    """
    filter the rows returned
    """
    where: library_bool_exp
  ): library_aggregate!
  name: String
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  count(columns: [user_select_column!], distinct: Boolean): Int!
  max: user_max_fields
  min: user_min_fields
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  apps: app_bool_exp
  id: String_comparison_exp
  libraries: library_bool_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """
  unique or primary key constraint
  """
  users_pkey
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  apps: app_arr_rel_insert_input
  id: String
  libraries: library_arr_rel_insert_input
  name: String
}

"""
aggregate max on columns
"""
type user_max_fields {
  id: String
  name: String
}

"""
aggregate min on columns
"""
type user_min_fields {
  id: String
  name: String
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!

  """
  on conflict condition
  """
  on_conflict: user_on_conflict
}

"""
on conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]!
  where: user_bool_exp
}

"""
Ordering options when selecting data from "user".
"""
input user_order_by {
  apps_aggregate: app_aggregate_order_by
  id: order_by
  libraries_aggregate: library_aggregate_order_by
  name: order_by
}

"""
primary key columns input for table: user
"""
input user_pk_columns_input {
  id: String!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  name
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  id: String
  name: String
}

"""
update columns of table "user"
"""
enum user_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  name
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "value_type"
"""
type value_type {
  description: String
  value: String!
}

"""
aggregated selection of "value_type"
"""
type value_type_aggregate {
  aggregate: value_type_aggregate_fields
  nodes: [value_type!]!
}

"""
aggregate fields of "value_type"
"""
type value_type_aggregate_fields {
  count(columns: [value_type_select_column!], distinct: Boolean): Int!
  max: value_type_max_fields
  min: value_type_min_fields
}

"""
Boolean expression to filter rows from the table "value_type". All fields are combined with a logical 'AND'.
"""
input value_type_bool_exp {
  _and: [value_type_bool_exp!]
  _not: value_type_bool_exp
  _or: [value_type_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "value_type"
"""
enum value_type_constraint {
  """
  unique or primary key constraint
  """
  prop_value_types_pkey
}

enum value_type_enum {
  Boolean
  Lambda
  Number
  Prop
  String
}

"""
Boolean expression to compare columns of type "value_type_enum". All fields are combined with logical 'AND'.
"""
input value_type_enum_comparison_exp {
  _eq: value_type_enum
  _in: [value_type_enum!]
  _is_null: Boolean
  _neq: value_type_enum
  _nin: [value_type_enum!]
}

"""
input type for inserting data into table "value_type"
"""
input value_type_insert_input {
  description: String
  value: String
}

"""
aggregate max on columns
"""
type value_type_max_fields {
  description: String
  value: String
}

"""
aggregate min on columns
"""
type value_type_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "value_type"
"""
type value_type_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [value_type!]!
}

"""
input type for inserting object relation for remote table "value_type"
"""
input value_type_obj_rel_insert_input {
  data: value_type_insert_input!

  """
  on conflict condition
  """
  on_conflict: value_type_on_conflict
}

"""
on conflict condition type for table "value_type"
"""
input value_type_on_conflict {
  constraint: value_type_constraint!
  update_columns: [value_type_update_column!]!
  where: value_type_bool_exp
}

"""
Ordering options when selecting data from "value_type".
"""
input value_type_order_by {
  description: order_by
  value: order_by
}

"""
primary key columns input for table: value_type
"""
input value_type_pk_columns_input {
  value: String!
}

"""
select columns of table "value_type"
"""
enum value_type_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

"""
input type for updating data in table "value_type"
"""
input value_type_set_input {
  description: String
  value: String
}

"""
update columns of table "value_type"
"""
enum value_type_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  value
}
